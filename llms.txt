Project Structure:
📁 svgn
├── 📁 .github
│   └── 📁 workflows
│       ├── 📄 release.yml
│       ├── 📄 rust.yml
│       └── 📄 test-build-scripts.yml
├── 📁 docs
│   ├── 📁 _data
│   ├── 📁 _sass
│   │   └── 📁 custom
│   │       └── 📄 custom.scss
│   ├── 📄 _config.yml
│   └── 📄 Gemfile
├── 📁 issues
├── 📁 ref
│   └── 📁 svgo
│       ├── 📁 .github
│       │   ├── 📁 ISSUE_TEMPLATE
│       │   └── 📁 workflows
│       ├── 📁 bin
│       ├── 📁 docs
│       │   ├── 📁 02-usage
│       │   ├── 📁 04-plugins
│       │   └── 📁 06-migrations
│       ├── 📁 lib
│       │   ├── 📁 svgo
│       │   └── 📁 util
│       ├── 📁 logo
│       ├── 📁 plugins
│       ├── 📁 scripts
│       ├── 📁 test
│       │   ├── 📁 cli
│       │   ├── 📁 coa
│       │   │   ├── 📁 testFolderWithNoSvg
│       │   │   │   └── ... (depth limit reached)
│       │   │   ├── 📁 testSvg
│       │   │   │   └── ... (depth limit reached)
│       │   │   └── 📁 testSvgRecursively
│       │   │       └── ... (depth limit reached)
│       │   ├── 📁 fixtures
│       │   │   └── 📁 config-loader
│       │   │       └── ... (depth limit reached)
│       │   ├── 📁 plugins
│       │   ├── 📁 svg2js
│       │   └── 📁 svgo
│       └── 📁 test-d
│           └── 📁 lib
├── 📁 scripts
│   ├── 📄 benchmark1.sh
│   ├── 📄 build_linux.sh
│   ├── 📄 build_macos.sh
│   ├── 📄 build_windows.cmd
│   └── 📄 test1.sh
├── 📁 src
│   └── 📁 plugins
│       └── 📄 convert_one_stop_gradients.rs
├── 📁 svgn
│   ├── 📁 benches
│   │   └── 📄 optimization.rs
│   ├── 📁 examples
│   │   ├── 📄 test_css_debug.rs
│   │   └── 📄 test_style_plugins.rs
│   ├── 📁 src
│   │   ├── 📁 bin
│   │   │   └── 📄 svgn.rs
│   │   ├── 📁 plugins
│   │   │   ├── 📁 inline_styles
│   │   │   │   ├── 📄 inline_styles_converter.rs
│   │   │   │   └── 📄 inline_styles_selector.rs
│   │   │   ├── 📄 add_attributes_to_svg_element.rs
│   │   │   ├── 📄 add_classes_to_svg_element.rs
│   │   │   ├── 📄 cleanup_attrs.rs
│   │   │   ├── 📄 cleanup_enable_background.rs
│   │   │   ├── 📄 cleanup_ids.rs
│   │   │   ├── 📄 cleanup_list_of_values.rs
│   │   │   ├── 📄 cleanup_numeric_values.rs
│   │   │   ├── 📄 collapse_groups.rs
│   │   │   ├── 📄 convert_colors.rs
│   │   │   ├── 📄 convert_ellipse_to_circle.rs
│   │   │   ├── 📄 convert_one_stop_gradients.rs
│   │   │   ├── 📄 convert_path_data.rs
│   │   │   ├── 📄 convert_shape_to_path.rs
│   │   │   ├── 📄 convert_style_to_attrs.rs
│   │   │   ├── 📄 convert_transform.rs
│   │   │   ├── 📄 inline_styles.rs
│   │   │   ├── 📄 inline_styles_complex.rs
│   │   │   ├── 📄 inline_styles_converter.rs
│   │   │   ├── 📄 inline_styles_selector.rs
│   │   │   ├── 📄 merge_styles.rs
│   │   │   ├── 📄 minify_styles.rs
│   │   │   ├── 📄 mod.rs
│   │   │   ├── 📄 prefix_ids.rs
│   │   │   ├── 📄 remove_attributes_by_selector.rs
│   │   │   ├── 📄 remove_attrs.rs
│   │   │   ├── 📄 remove_comments.rs
│   │   │   ├── 📄 remove_deprecated_attrs.rs
│   │   │   ├── 📄 remove_desc.rs
│   │   │   ├── 📄 remove_dimensions.rs
│   │   │   ├── 📄 remove_doctype.rs
│   │   │   ├── 📄 remove_editors_ns_data.rs
│   │   │   ├── 📄 remove_elements_by_attr.rs
│   │   │   ├── 📄 remove_empty_attrs.rs
│   │   │   ├── 📄 remove_empty_containers.rs
│   │   │   ├── 📄 remove_empty_text.rs
│   │   │   ├── 📄 remove_hidden_elems.rs
│   │   │   ├── 📄 remove_metadata.rs
│   │   │   ├── 📄 remove_non_inheritable_group_attrs.rs
│   │   │   ├── 📄 remove_off_canvas_paths.rs
│   │   │   ├── 📄 remove_raster_images.rs
│   │   │   ├── 📄 remove_scripts.rs
│   │   │   ├── 📄 remove_style_element.rs
│   │   │   ├── 📄 remove_title.rs
│   │   │   ├── 📄 remove_unknowns_and_defaults.rs
│   │   │   ├── 📄 remove_unused_ns.rs
│   │   │   ├── 📄 remove_useless_defs.rs
│   │   │   ├── 📄 remove_useless_stroke_and_fill.rs
│   │   │   ├── 📄 remove_useless_transforms.rs
│   │   │   ├── 📄 remove_view_box.rs
│   │   │   ├── 📄 remove_xlink.rs
│   │   │   ├── 📄 remove_xml_proc_inst.rs
│   │   │   ├── 📄 remove_xmlns.rs
│   │   │   ├── 📄 sort_attrs.rs
│   │   │   └── 📄 sort_defs_children.rs
│   │   ├── 📄 ast.rs
│   │   ├── 📄 collections.rs
│   │   ├── 📄 config.rs
│   │   ├── 📄 config.rs.bak
│   │   ├── 📄 lib.rs
│   │   ├── 📄 optimizer.rs
│   │   ├── 📄 parser.rs
│   │   ├── 📄 plugin.rs
│   │   └── 📄 stringifier.rs
│   ├── 📁 tests
│   │   ├── 📁 plugins
│   │   │   ├── 📄 cleanup_attrs.rs
│   │   │   ├── 📄 cleanup_ids.rs
│   │   │   ├── 📄 convert_colors.rs
│   │   │   ├── 📄 convert_ellipse_to_circle.rs
│   │   │   ├── 📄 convert_one_stop_gradients.rs
│   │   │   ├── 📄 convert_path_data.rs
│   │   │   ├── 📄 inline_styles.rs
│   │   │   ├── 📄 remove_attributes_by_selector.rs
│   │   │   ├── 📄 remove_comments.rs
│   │   │   ├── 📄 remove_deprecated_attrs.rs
│   │   │   ├── 📄 remove_dimensions.rs
│   │   │   └── 📄 remove_empty_attrs.rs
│   │   ├── 📄 fixture_tests.rs
│   │   ├── 📄 integration_test.rs
│   │   ├── 📄 plugins.rs
│   │   └── 📄 svgo_compatibility_tests.rs
│   ├── 📄 build.rs
│   └── 📄 Cargo.toml
├── 📁 target
│   ├── 📁 aarch64-apple-darwin
│   │   └── 📁 release
│   │       ├── 📁 deps
│   │       ├── 📁 examples
│   │       └── 📁 incremental
│   ├── 📁 debug
│   │   ├── 📁 deps
│   │   ├── 📁 examples
│   │   └── 📁 incremental
│   │       ├── 📁 build_script_build-1bdvp8gtts0db
│   │       │   └── 📁 s-h8vvlw1eif-12aqlvj-7bzc9opvynm3696xlt8erhcqb
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 build_script_build-21pdzctxlcdmp
│   │       │   └── 📁 s-h8vz5bw5da-0p69g6r-cx67xfynw4vssm3ju9fk0reia
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 build_script_build-2lvgo5t97kf52
│   │       │   └── 📁 s-h8ww1zu7wv-0c34mwy-b820y8amizfbbbqe4e3j4w9fu
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 build_script_build-2no91pxjtlvbt
│   │       │   └── 📁 s-h8vvl61geu-0updjie-754cmt0sl1sqig74syuo84xtr
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 fixture_tests-04qkxn61x8ptz
│   │       │   └── 📁 s-h8x14c7357-1ppoxzq-2aalvclu2ryyj25wyut2f7qa8
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 fixture_tests-0ply0uphy5qym
│   │       │   └── 📁 s-h8vy5za5t7-0f3dhok-f2uek7626qhxmg09wpsldq1h9
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 fixture_tests-0v7af11a5wett
│   │       │   └── 📁 s-h8vz1ymvll-1rnyjrn-1qa97yztpzgsgtcdmv5eek20f
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 fixture_tests-2drs5cv96m6x6
│   │       │   └── 📁 s-h8vxb2y1j5-1jusbwk-0egcjqwfq4nf9i8fu3y3p4iys
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 fixture_tests-2gaps0wbpfl9o
│   │       │   └── 📁 s-h8wlfix8xs-1pitcp5-9xq2t9cu8725z79j2z4hhol1e
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 fixture_tests-3c4fq7xgqryar
│   │       │   └── 📁 s-h8wz79qn6l-18x6huh-4ozm1a8csr704xvmhoi1rpisf
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 fixture_tests-3nt7vqt04i75y
│   │       │   └── 📁 s-h8wv2mvx37-0pr0tw8-76477za0o45cmczcozioy8gyc
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 integration_test-0qdnrv6fbibj4
│   │       │   └── 📁 s-h8vy5z9rzq-1gcazsl-5mvbcikd9kzr6cpbk3ct3evgv
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 integration_test-1fye0zngj15tq
│   │       │   └── 📁 s-h8wz79so1m-1o5eing-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 integration_test-1yospmh98a6ii
│   │       │   └── 📁 s-h8x14c5x3z-1ehxsa6-dbehkrhnzy1lnnb5eqkatyts6
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 integration_test-289jpq8zntzlt
│   │       │   └── 📁 s-h8wlfix3li-1c0sudl-ehitses9di4nwy7aga1pqlckh
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 integration_test-29fzxkmxuq349
│   │       │   └── 📁 s-h8wv2mvc56-07h3v4r-66e7w40in8v161m2tis062d9n
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 integration_test-35ytdq8177af9
│   │       │   └── 📁 s-h8vxb2xsav-1mdpn86-bmhxkyfr6gcdasn55ilvmxanx
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 integration_test-3avu2nzkohr66
│   │       │   └── 📁 s-h8vz1ymsyx-0yo3a0f-b79iu84hef26byjk3fkcdxpi5
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 optimization-07fqd68iv2es5
│   │       │   └── 📁 s-h8wz79r1ia-0an7y91-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 optimization-17w1dpl2szylt
│   │       │   └── 📁 s-h8wlfixcyv-1l6145r-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 optimization-24qkikkuezmz2
│   │       │   └── 📁 s-h8wv2mvxuc-13kr6xf-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 optimization-3dfbl0mh211aa
│   │       │   └── 📁 s-h8vy5za0m5-1q20n6u-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 plugins-01jcsqph3ayfa
│   │       │   └── 📁 s-h8vy5z9qci-0a34xmr-a1cqsx08tnf0g91xlc07tq4vv
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 plugins-03r40vtg2kskg
│   │       │   └── 📁 s-h8vz1ymfyp-0bkltf0-876921evfqexfm7ei5upl72w0
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 plugins-17u8mdyh8nksy
│   │       │   └── 📁 s-h8vxb2xqol-1i80qxa-ahrzn0eoho4v4fs9icir4qh18
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 plugins-1mwooxcm57zl5
│   │       │   └── 📁 s-h8wv2mvgxd-0rhvt38-9wkfxzdpppepf0l31d55g695r
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 plugins-2b75l6iv6hmr9
│   │       │   └── 📁 s-h8wlfixdhq-02byig5-3fx9onlvel2yz06y7je3vdgd0
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 plugins-3do6i2bze19d7
│   │       │   └── 📁 s-h8wz79ov5k-0kbltx5-cb3kckv1wvfo7o8cro5nx7th4
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 plugins-3h3qbxszk3i0n
│   │       │   └── 📁 s-h8x14c696x-1ipjy1r-bhup2g5cjz0cm6znfbk1xeqa5
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-005rkcjeongye
│   │       │   └── 📁 s-h8vz1u4zde-16l6y1l-delgivoc9912fy7ako87t5e5e
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-01wbtozjph2i0
│   │       │   └── 📁 s-h8vz1ymg8i-1qnqf76-e1n4i575zyfrj06zbz25iuss2
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-02mbnowxjxo1w
│   │       │   └── 📁 s-h8x14c9kc2-0ppjht0-4shw7m4hxgxltmklvrmkw08rh
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-09muhj9jcze26
│   │       │   └── 📁 s-h8wlfix1h9-1oreiby-47zko5a8unin3lki782a7xkaq
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0aul98x5qlu32
│   │       │   └── 📁 s-h8vxb2y3bh-1oj3fjb-968480v27xguthhnlwcrok8zb
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0c2q0622tyvit
│   │       │   └── 📁 s-h8wv2mvtwn-0tzl83i-ac5xelx7tu72c280tb3dqlgjg
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0clx1rfy3fl56
│   │       │   └── 📁 s-h8vy0xu2m4-1fi6nc6-8kgtlewppt4f7cp8pcxu8dwqt
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0dt3a5dv8rnf7
│   │       │   └── 📁 s-h8x0h2a6uf-0lo2sun-2e2hsts6fjgzbkll3lth113eb
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0g1g5cqluatjo
│   │       │   └── 📁 s-h8x0ai50ve-0lbwzb9-8x7l5vck32fuwutvvz6v5gjuk
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0h2kstmafyw4c
│   │       │   └── 📁 s-h8wz79srnf-0wpzvln-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0n2li25y90h3k
│   │       │   └── 📁 s-h8wz72nft1-0qj20ip-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0s1ueb1mz1md4
│   │       │   └── 📁 s-h8vy896qw9-1kmsvvl-78d3ssu25bffevfc5j3kfya90
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0s3aogn9y75wy
│   │       │   ├── 📁 s-h8vy8ya2ij-1nzdwkf-ckwsc7co8pgrqfehycmsf2q6e
│   │       │   │   └── ... (depth limit reached)
│   │       │   └── 📁 s-h8wlgzf38h-12q2c93-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0wwq0xehcwrym
│   │       │   └── 📁 s-h8vvlffns1-1iqvdlu-3fr3gkwrj002cfnfs8v1d0vkw
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0x8b1gml46p0g
│   │       │   └── 📁 s-h8x14ga7pj-0eoj6gr-4lcdxws18r4lk5qzgu6gzb9ac
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-0xr22q2li5f6e
│   │       │   └── 📁 s-h8wz79slo7-18ndj1d-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-13fgx0qv2imo9
│   │       │   └── 📁 s-h8vxb2xsm4-0vekycq-cekbhqoqob44304h74ca0p6yc
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-16m4msdj71xla
│   │       │   └── 📁 s-h8x148g3s1-0axxsv0-cs5asctj4synd3o80e2iuuxq6
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-1bp5730z55td3
│   │       │   └── 📁 s-h8vxsn8nmj-1aq357o-41dvo3qd8fjtp093h600d4ccw
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-1d7ohcv94dgpe
│   │       │   ├── 📁 s-h8x0gxsuwn-1hpsrr2-0771ohntjp0mv36ploag2lqan
│   │       │   │   └── ... (depth limit reached)
│   │       │   └── 📁 s-h8x0zpwen0-0zibnb4-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-1m9uirifvmxna
│   │       │   └── 📁 s-h8x14c751h-09zxyre-3yfq3vvx8c5uxnzsto0kl97cc
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-1we9em8jemp43
│   │       │   └── 📁 s-h8vy5za2ro-01qee1t-3rc33npe6n78q2p3ehum71g3m
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-24jqwsv1fnqjr
│   │       │   └── 📁 s-h8vxyatkyf-0z8ogr7-695cm7h1d224t0f43e3mmgq7e
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-27qkkyrxexkjd
│   │       │   └── 📁 s-h8vy91o996-0tyxdve-2a0b38u7y7hyfb3mxx28kqjw3
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-28nazeeqzbwem
│   │       │   └── 📁 s-h8vz1u8g4i-1bm356r-ew58w6faof2jdq9pcbygo6hqy
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-29hy9lsugk9os
│   │       │   └── 📁 s-h8x14iny1n-0ti4tqj-0apngrpjxzvodow82fcyu6sez
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-2duj3jprwpexu
│   │       │   └── 📁 s-h8wlfixf6o-1mb62me-ecilleoye1it0ynt2jf6ohw64
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-2iffub482thnt
│   │       │   └── 📁 s-h8wv2mvhno-1e9j7pz-arupovx8f0kkux5k8i3i6icrg
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-2mzelzwefeknn
│   │       │   └── 📁 s-h8vy5yac0u-0h7dwbh-6eacg6ze51g599otndq4x839k
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-2ns5rfv87t9ta
│   │       │   └── 📁 s-h8wz72ng4g-07lkann-9ghf9seyqlwr86960k800ngtr
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-2rmy7yzgckr3o
│   │       │   └── 📁 s-h8vy5yac4w-0rd2u1o-7pdsdub5b0b9bejhzkssh35gb
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-2tns3rwtx94yj
│   │       │   └── 📁 s-h8wv2m10c1-0yrvg5w-dak9tz6xb2mbh665c5pyqa3tl
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-2u97lia1lgp1m
│   │       │   └── 📁 s-h8vvldook1-17qd51w-4uhzy02cd4qrdun2axf78o8vn
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-34f3amqcxmf28
│   │       │   └── 📁 s-h8vz5c4113-1vh6154-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-381scq06xq25y
│   │       │   └── 📁 s-h8wlfhoauz-1lb9l0o-7ib9qoxuz4lztht8ygyqf7mam
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-3a29bjdw1ebb3
│   │       │   ├── 📁 s-h8vwflwlhj-0wj7zxn-0fenwmik8e5vzpehqtqfupe5y
│   │       │   │   └── ... (depth limit reached)
│   │       │   └── 📁 s-h8vxyvuxyo-0kabapr-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-3g8lbw6vupqyr
│   │       │   └── 📁 s-h8vy13hne6-1cmetxo-9wppxolmwiabhnemwoxyhcvwn
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-3hb61y1xvrwcr
│   │       │   └── 📁 s-h8wv2m10c1-0r2mnwt-dg84arxbio956ernh94dg3spp
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-3jlqspzqbxclx
│   │       │   └── 📁 s-h8x148dhtz-1dmextk-8kgp328ex7gnsu7kvz6j36it3
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-3mdn4o2lu1v1e
│   │       │   └── 📁 s-h8x0ahumhh-078zazs-4e2n4mkzzjnewu5qga3dlmdto
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-3mzybu9a7g9sf
│   │       │   └── 📁 s-h8wlfhoauz-1tg106y-062hw5l9yc3c96kx174aeavu8
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-3ni3utjhvege9
│   │       │   └── 📁 s-h8vy166hgl-1gsqdky-8tij859tjxgf8zxyvdh5e7d6p
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-3sx0w5q7pw7eb
│   │       │   └── 📁 s-h8vz1yma3e-0hxgbc0-5nii4f8a95hclr91b9m98ntuv
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgn-3tahqurn4wt44
│   │       │   └── 📁 s-h8vy5za1xg-0ihqec2-a1fjgdguy17qnpns80nkzd5xf
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgo_compatibility_tests-05t4q3ujpsvg9
│   │       │   └── 📁 s-h8x14c6kl4-0geuwre-ejb4nmuk0n9ei68iw6wh7n4g7
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgo_compatibility_tests-0plkr3wurhayh
│   │       │   └── 📁 s-h8vy5za51b-1rao4cd-1oqsgf0i3u12da0k2o9tiu40q
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgo_compatibility_tests-16cyj5ilsnpam
│   │       │   └── 📁 s-h8wlfix3v7-0l3cmfz-6ce7ncjpqlwo1lh4j586v1tzc
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgo_compatibility_tests-2el6kr49uyiww
│   │       │   └── 📁 s-h8wz79sah9-0mnrdln-working
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgo_compatibility_tests-2y3i4ms1acm2w
│   │       │   └── 📁 s-h8vxb2xs1d-0eoui62-55rvrmiq1clt9o6qx5pnqc3r9
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgo_compatibility_tests-3dr4asvtde3oa
│   │       │   └── 📁 s-h8vz1ymvze-1vgsp1c-46ba2ts5tlmokoczekey20q99
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 svgo_compatibility_tests-3ivj451f73v9e
│   │       │   └── 📁 s-h8wv2mvsvq-0byn9f7-f30g3hv1issfw9tt51enwpoxu
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 test_css_debug-0z5zpsjshjwvm
│   │       │   └── 📁 s-h8wv2mvi75-045pu6i-1fbaddolsga4a7cq4u64jtnxc
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 test_css_debug-1ober9ort6tmj
│   │       │   └── 📁 s-h8wz79s5fd-0hgtc7z-bws2232q9piyr3aktyguyp6ah
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 test_css_debug-1wfss9twgmiia
│   │       │   └── 📁 s-h8x14c6ho2-05xjo29-ehhbjpfmg3bvhmpaf9bkv2o7i
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 test_style_plugins-0bn9mgtuwuxsv
│   │       │   └── 📁 s-h8wlfix7a2-1rf6qc8-0n61m4mnr29rzvg5fawpdny2t
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 test_style_plugins-1kii98er1arnn
│   │       │   └── 📁 s-h8wv2mvptj-0v8yalf-5zabw05wlhxepbghws6rkpd7o
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 test_style_plugins-1qzy2fdg29x5e
│   │       │   └── 📁 s-h8vy5z9u21-11jodij-cvy8guk5tl64kahhqcm4dk1na
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 test_style_plugins-1v1us3lp5ztwb
│   │       │   └── 📁 s-h8vz1ymb8v-0suv5ul-2ef09jm0rcozvh1mp0sfmty2h
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 test_style_plugins-1xih4easbz52t
│   │       │   └── 📁 s-h8wz79s76q-0wd9k32-eebw0fvniz67n3oq1yb7ptmvv
│   │       │       └── ... (depth limit reached)
│   │       ├── 📁 test_style_plugins-2b05ra89z0gr5
│   │       │   └── 📁 s-h8vxb2y10x-01h8pmm-25cymxyp3n51qcdakxgx9sw1y
│   │       │       └── ... (depth limit reached)
│   │       └── 📁 test_style_plugins-3or25hxn02lc4
│   │           └── 📁 s-h8x14c70zv-0cznggh-ckv43gahtwqrducfvepltqk6p
│   │               └── ... (depth limit reached)
│   ├── 📁 release
│   │   ├── 📁 deps
│   │   ├── 📁 examples
│   │   └── 📁 incremental
│   ├── 📁 rust-analyzer
│   │   └── 📁 metadata
│   │       ├── 📁 sysroot
│   │       └── 📁 workspace
│   ├── 📁 tmp
│   └── 📁 x86_64-apple-darwin
│       └── 📁 release
│           ├── 📁 deps
│           ├── 📁 examples
│           └── 📁 incremental
├── 📁 testdata
│   └── 📁 emoji
├── 📁 tools
│   └── 📄 set-cargo-version.sh
├── 📁 work
├── 📄 .gitignore
├── 📄 build.sh
├── 📄 Cargo.toml
├── 📄 generate_compatibility_tests.py
├── 📄 LICENSE
├── 📄 package.json
└── 📄 test_css_debug.rs


Relative File Path: .github/workflows/release.yml

```yaml
name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.2.3)'
        required: true
        type: string

permissions:
  contents: write

jobs:
  # Create release
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Get version from tag
        id: get_version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.tag }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version: ${VERSION}"
      
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          release_name: Release ${{ steps.get_version.outputs.version }}
          draft: true
          prerelease: false

  # Build releases for each platform
  build:
    name: Build ${{ matrix.name }}
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            name: Linux
            script: scripts/build_linux.sh
            artifacts_path: dist/linux
            target: x86_64-unknown-linux-gnu
          - os: macos-latest
            name: macOS
            script: scripts/build_macos.sh
            artifacts_path: dist/macos
            # macOS will build universal binary
          - os: windows-latest
            name: Windows
            script: scripts/build_windows.cmd
            artifacts_path: dist/windows
            target: x86_64-pc-windows-msvc

    steps:
      - uses: actions/checkout@v4
      
      - name: Setup version
        shell: bash
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "VERSION=${VERSION}" >> $GITHUB_ENV
          # Update Cargo.toml version if needed
          if [[ -f "./tools/set-cargo-version.sh" ]]; then
            chmod +x ./tools/set-cargo-version.sh
            ./tools/set-cargo-version.sh "$VERSION"
          else
            echo "Warning: set-cargo-version.sh not found"
          fi
      
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target || '' }}
      
      - name: Add macOS targets
        if: matrix.os == 'macos-latest'
        run: |
          rustup target add x86_64-apple-darwin
          rustup target add aarch64-apple-darwin
      
      - name: Cache cargo registry
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            svgn/target
          key: ${{ runner.os }}-cargo-release-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-release-
            ${{ runner.os }}-cargo-
      
      # Install platform-specific build dependencies
      - name: Install Linux dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev rpm
      
      - name: Install Windows dependencies
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          # Uncomment to install optional dependencies
          # choco install wixtoolset -y
          # choco install innosetup -y
          Write-Host "Windows build environment ready"
      
      - name: Make build script executable
        if: matrix.os != 'windows-latest'
        run: chmod +x ${{ matrix.script }}
      
      # Run platform-specific build script
      - name: Build Release
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            cmd.exe //c "${{ matrix.script }}"
          else
            ./${{ matrix.script }}
          fi
      
      - name: List build artifacts
        shell: bash
        run: |
          echo "=== Build artifacts in ${{ matrix.artifacts_path }} ==="
          ls -la "${{ matrix.artifacts_path }}/" || echo "No artifacts found"
          echo "=== Finding all distribution files ==="
          find "${{ matrix.artifacts_path }}" -type f -name "svgn-*" | head -20
      
      # Upload artifacts to GitHub Actions (for debugging)
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: svgn-${{ matrix.name }}-${{ needs.create-release.outputs.version }}
          path: ${{ matrix.artifacts_path }}/*
          if-no-files-found: error
      
      # Upload release assets
      - name: Upload Release Assets
        shell: bash
        run: |
          # Function to upload a file
          upload_file() {
            local file="$1"
            local name=$(basename "$file")
            echo "Uploading $name..."
            curl -sS \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@$file" \
              "${{ needs.create-release.outputs.upload_url }}?name=$name" \
              > /dev/null
          }
          
          # Find and upload all release files
          cd "${{ matrix.artifacts_path }}"
          for file in svgn-*; do
            if [[ -f "$file" ]]; then
              upload_file "$file"
            fi
          done

  # Publish release
  publish:
    name: Publish Release
    needs: [create-release, build]
    runs-on: ubuntu-latest
    steps:
      - name: Publish release
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const tag = '${{ needs.create-release.outputs.version }}';
            
            // Find the release by tag
            const releases = await github.rest.repos.listReleases({
              owner,
              repo
            });
            
            const release = releases.data.find(r => r.tag_name === tag);
            if (!release) {
              throw new Error(`Release with tag ${tag} not found`);
            }
            
            // Update release to published
            await github.rest.repos.updateRelease({
              owner,
              repo,
              release_id: release.id,
              draft: false
            });
            
            console.log(`Published release ${tag}`);
```

Relative File Path: .github/workflows/rust.yml

```yaml
name: Rust

permissions:
  contents: read
  security-events: write

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # Quick format and lint checks
  check:
    name: Check
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
    - name: Check formatting
      run: cargo fmt --all -- --check
    - name: Run clippy
      run: cargo clippy --all-targets --all-features -- -D warnings

  # Build and test on multiple platforms
  test:
    name: Test Suite
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        rust: [stable]
        include:
          # Test on minimum supported Rust version (MSRV)
          - os: ubuntu-latest
            rust: "1.70.0"  # Adjust based on your MSRV
    steps:
    - uses: actions/checkout@v4
    - name: Setup Rust ${{ matrix.rust }}
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
    - name: Cache cargo dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ matrix.rust }}-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-${{ matrix.rust }}-
          ${{ runner.os }}-cargo-
    - name: Build
      run: |
        cd svgn
        cargo build --verbose
    - name: Run tests
      run: |
        cd svgn
        cargo test --verbose
    - name: Run doc tests
      run: |
        cd svgn
        cargo test --doc --verbose
    
  # Security audit
  security:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: rustsec/audit-check@v1.4.1
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
  # Code coverage (optional)
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
    - name: Install tarpaulin
      run: cargo install cargo-tarpaulin
    - name: Generate coverage
      run: |
        cd svgn
        cargo tarpaulin --out Xml --verbose
    - name: Upload coverage to codecov
      uses: codecov/codecov-action@v3
      with:
        files: ./svgn/cobertura.xml
        fail_ci_if_error: false
```

Relative File Path: .github/workflows/test-build-scripts.yml

```yaml
name: Test Build Scripts

on:
  pull_request:
    paths:
      - 'scripts/**'
      - '.github/workflows/test-build-scripts.yml'
  workflow_dispatch:

jobs:
  test-scripts:
    name: Test ${{ matrix.name }} Build Script
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            name: Linux
            script: scripts/build_linux.sh
          - os: macos-latest
            name: macOS
            script: scripts/build_macos.sh
          - os: windows-latest
            name: Windows
            script: scripts/build_windows.cmd
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: |
            ${{ matrix.os == 'macos-latest' && 'x86_64-apple-darwin,aarch64-apple-darwin' || '' }}
      
      - name: Make script executable
        if: matrix.os != 'windows-latest'
        run: chmod +x ${{ matrix.script }}
      
      - name: Run build script
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            cmd.exe //c "${{ matrix.script }}"
          else
            ./${{ matrix.script }}
          fi
      
      - name: Verify artifacts
        shell: bash
        run: |
          echo "=== Checking build artifacts ==="
          if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            ls -la dist/macos/
            # Verify universal binary
            file dist/macos/svgn
            lipo -info dist/macos/svgn
          elif [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            ls -la dist/linux/
            file dist/linux/svgn
          elif [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ls -la dist/windows/
          fi
```

Relative File Path: .gitignore

```
.DS_Store
.idea/
*.pdb
**/*.rs.bk
**/mutants.out*/
debug
ref/
target/
/testdata/emoji

```

Relative File Path: Cargo.toml

```toml
# this_file: Cargo.toml

[workspace]
members = ["svgn"]
default-members = ["svgn"]
resolver = "2"

[workspace.package]
version = "1.2.3"
edition = "2021"
authors = ["Adam Twardoch <adam@twardoch.com>"]
license = "MIT"
repository = "https://github.com/twardoch/svgn"
homepage = "https://github.com/twardoch/svgn"

[workspace.dependencies]
# Core dependencies
clap = { version = "4.4", features = ["derive"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
thiserror = "1.0"

# XML parsing
quick-xml = "0.31"
roxmltree = "0.20"

# CSS parsing
cssparser = "0.31"
selectors = "0.25"
lightningcss = "1.0.0-alpha.67"

# Utils
regex = "1.10"
indexmap = "2.0"
base64 = "0.22"
urlencoding = "2.1"
once_cell = "1.19.0"
toml = "0.8"

# Path processing
lyon = "1.0"

# Matrix operations
nalgebra = "0.33"

# Optional: SVG utilities
usvg = { version = "0.42" }

# Dev dependencies
assert_cmd = "2.0"
predicates = "3.0"
tempfile = "3.8"
criterion = "0.5"

# WASM support
wasm-bindgen = "0.2"
js-sys = "0.3"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"
```

Relative File Path: LICENSE

```
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

Relative File Path: build.sh

```bash
#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
set -e

{
    echo "Generating code snapshot in ./llms.txt ..."
    uvx codetoprompt --compress --output llms.txt --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock" .

    echo "Building the svgn project..."
    # Build the project in release mode for optimized binaries
    cargo build --release

    echo "Running tests..."
    # Run all unit and integration tests
    cargo test

    echo "Running linter (clippy)..."
    # Run clippy to catch common mistakes and improve code quality
    cargo clippy -- -D warnings

    echo "Checking code formatting..."
    # Check if code is formatted according to rustfmt rules
    cargo fmt --check

    echo "Build and verification complete."
    echo "To run the optimized binary, use: ./target/release/svgn"

    ./target/release/svgn --help
} >build.log.txt 2>&1

echo "build log created in: build.log.txt"

```

Relative File Path: docs/Gemfile

```
source 'https://rubygems.org'

gem 'github-pages', group: :jekyll_plugins
```

Relative File Path: docs/_config.yml

```yaml
remote_theme: just-the-docs/just-the-docs

# GitHub Pages plugins
plugins:
  - jekyll-remote-theme
  - jekyll-sitemap
  - jekyll-feed

# Site settings
title: svgn
description: SVG optimizer, API-compatible Rust port of svgo
baseurl: "/svgn"
url: "https://twardoch.github.io"

# Just the Docs specific settings
search_enabled: true
search:
  heading_level: 2
  previews: 3
  preview_words_before: 5
  preview_words_after: 10
  tokenizer_separator: /[\s/]+/
  rel_url: true
  button: false

# Navigation
nav_sort: case_insensitive
nav_external_links:
  - title: GitHub Repository
    url: https://github.com/twardoch/svgn
  - title: SVGO Reference
    url: https://github.com/svg/svgo

# Footer
footer_content: "Copyright &copy; 2024 Adam Twardoch. Distributed under the MIT License."

# Color scheme
color_scheme: light

# Enable copy to clipboard
enable_copy_code_button: true

# Aux links
aux_links:
  "View on GitHub":
    - "https://github.com/twardoch/svgn"

# Collections
collections:
  data:
    output: true
```

Relative File Path: docs/_sass/custom/custom.scss

```
// Custom styles for SVGN documentation

// Color theme overrides
$body-background-color: $white;
$sidebar-color: $grey-lt-100;
$border-color: $grey-lt-100;

// Custom styling
.code-example {
  border: 1px solid $border-color;
  border-radius: 6px;
  padding: 16px;
  margin-bottom: 16px;
  background-color: $grey-lt-000;
}

// Table styling improvements
table {
  border-collapse: collapse;
  width: 100%;
  margin-bottom: 16px;
  
  th, td {
    border: 1px solid $border-color;
    padding: 8px 12px;
    text-align: left;
  }
  
  th {
    background-color: $grey-lt-000;
    font-weight: 600;
  }
}

// Improve code block styling
pre.highlight {
  padding: 16px;
  border-radius: 6px;
  border: 1px solid $border-color;
}

// Better link styling
a {
  text-decoration: none;
  
  &:hover {
    text-decoration: underline;
  }
}
```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/generate_compatibility_tests.py
# Language: python

import os
import re

def normalize_svg((svg_string)):

def generate_rust_test_file((fixtures_dir, output_file)):


Relative File Path: package.json

```json
{
  "dependencies": {},
  "devDependencies": {
    "svgo": "^4.0.0"
  }
... (file content truncated to first 5 lines)
```

Relative File Path: scripts/benchmark1.sh

```bash
#!/usr/bin/env bash
# this_file: scripts/benchmark1.sh

set -euo pipefail
cd $(dirname "$0")/..

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
TEMP_DIR=$(mktemp -d)
SVG_DIR="${1:-testdata}"
ITERATIONS="${2:-3}"
MIN_FILES="${3:-10}"

cleanup() {
    rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

log() {
    echo -e "${BLUE}[BENCHMARK]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# Check if tools exist
check_tools() {
    log "Checking required tools..."

    if ! command -v npx >/dev/null 2>&1; then
        error "npx not found. Please install Node.js and npm."
        exit 1
    fi

    if ! npx svgo --version >/dev/null 2>&1; then
        error "svgo not found. Please install svgo with 'npm install -g svgo'."
        exit 1
    fi

    if ! command -v bc >/dev/null 2>&1; then
        error "bc (basic calculator) not found. Please install bc (e.g., 'apt install bc' or 'brew install bc')."
        exit 1
    fi

    if [[ ! -f "./target/release/svgn" ]]; then
        error "./target/release/svgn not found. Please build with 'cargo build --release'."
        exit 1
    fi

    if ! ./target/release/svgn --version >/dev/null 2>&1; then
        error "./target/release/svgn not executable or failed to run. Please build with 'cargo build --release'."
        exit 1
    fi

    success "All tools available"
}

# Find SVG files recursively
find_svg_files() {
    log "Finding SVG files recursively in $SVG_DIR..."

    if [[ ! -d "$SVG_DIR" ]]; then
        error "Directory $SVG_DIR does not exist"
        exit 1
    fi

    mapfile -t svg_files < <(find "$SVG_DIR" -type f -name "*.svg" -not -path '*/\.*')

    if [[ ${#svg_files[@]} -lt $MIN_FILES ]]; then
        error "Found only ${#svg_files[@]} SVG files, need at least $MIN_FILES"
        exit 1
    fi

    success "Found ${#svg_files[@]} SVG files"
}

# Benchmark a single tool
benchmark_tool() {
    local tool_name="$1"
    local tool_cmd="$2"
    local files=("${@:3}")

    log "Benchmarking $tool_name (${#files[@]} files, $ITERATIONS iterations)..."

    local total_time=0
    local successful_files=0
    local failed_files=0

    # Create a subdirectory for this tool's outputs
    local tool_output_dir="$TEMP_DIR/$tool_name"
    mkdir -p "$tool_output_dir"

    for iteration in $(seq 1 $ITERATIONS); do
        log "  Iteration $iteration/$ITERATIONS"
        local iteration_time=0

        # Create iteration-specific directory
        local iteration_dir="$tool_output_dir/iteration_$iteration"
        mkdir -p "$iteration_dir"

        for svg_file in "${files[@]}"; do
            local output_file="$iteration_dir/$(basename "$svg_file")"

            # Time the command
            local start_time=$(date +%s.%N)
            if eval "$tool_cmd \"$svg_file\" > \"$output_file\" 2>/dev/null"; then
                local end_time=$(date +%s.%N)
                local file_time=$(echo "$end_time - $start_time" | bc -l 2>/dev/null || echo "0")
                iteration_time=$(echo "$iteration_time + $file_time" | bc -l 2>/dev/null || echo "$iteration_time")
                ((successful_files++))
            else
                ((failed_files++))
            fi
        done

        total_time=$(echo "$total_time + $iteration_time" | bc -l 2>/dev/null || echo "$total_time")
        log "    Iteration time: ${iteration_time}s"
    done

    local avg_time="0"
    local avg_per_file="0"

    if [[ "$ITERATIONS" -gt 0 ]] && [[ "$total_time" != "0" ]]; then
        avg_time=$(echo "scale=6; $total_time / $ITERATIONS" | bc -l 2>/dev/null || echo "0")
    fi

    if [[ "${#files[@]}" -gt 0 ]] && [[ "$avg_time" != "0" ]]; then
        avg_per_file=$(echo "scale=6; $avg_time / ${#files[@]}" | bc -l 2>/dev/null || echo "0")
    fi

    log "  $tool_name completed: total_time=$total_time, avg_time=$avg_time, avg_per_file=$avg_per_file, successful=$successful_files, failed=$failed_files"
    echo "$tool_name,$avg_time,$avg_per_file,$successful_files,$failed_files"
}

# Main benchmark function
run_benchmark() {
    log "Starting benchmark comparison..."

    # Prepare file subset for testing
    local test_files=("${svg_files[@]:0:100}") # Use first 100 files max

    # Create results file
    local results_file="$TEMP_DIR/benchmark_results.csv"
    echo "Tool,Total_Time_Avg,Per_File_Avg,Successful_Files,Failed_Files" >"$results_file"

    # Benchmark npx svgo
    local svgo_result
    svgo_result=$(benchmark_tool "svgo" "bunx --bun svgo -i" "${test_files[@]}")
    echo "$svgo_result" >>"$results_file"

    # Benchmark our svgn
    local svgn_result
    svgn_result=$(benchmark_tool "svgn" "./target/release/svgn -i " "${test_files[@]}")
    echo "$svgn_result" >>"$results_file"

    # Display results
    log "Benchmark Results:"
    echo
    printf "%-12s %-15s %-15s %-15s %-15s\n" "Tool" "Total Time (s)" "Per File (s)" "Success" "Failed"
    printf "%-12s %-15s %-15s %-15s %-15s\n" "----" "-------------" "-------------" "-------" "------"

    while IFS=',' read -r tool total_time per_file success failed; do
        if [[ "$tool" != "Tool" ]]; then # Skip header
            # Validate that total_time and per_file are numeric
            if [[ "$total_time" =~ ^[0-9]+\.?[0-9]*$ ]] && [[ "$per_file" =~ ^[0-9]+\.?[0-9]*$ ]]; then
                printf "%-12s %-15.6f %-15.6f %-15s %-15s\n" "$tool" "$total_time" "$per_file" "$success" "$failed"
            else
                printf "%-12s %-15s %-15s %-15s %-15s\n" "$tool" "$total_time" "$per_file" "$success" "$failed"
            fi
        fi
    done <"$results_file"

    # Calculate speedup
    local svgo_time=$(echo "$svgo_result" | cut -d',' -f2)
    local svgn_time=$(echo "$svgn_result" | cut -d',' -f2)
    local speedup=$(echo "scale=2; $svgo_time / $svgn_time" | bc -l)

    echo
    if (($(echo "$speedup > 1" | bc -l))); then
        success "svgn is ${speedup}x faster than npx svgo"
    elif (($(echo "$speedup < 1" | bc -l))); then
        local slowdown=$(echo "scale=2; $svgn_time / $svgo_time" | bc -l)
        warn "svgn is ${slowdown}x slower than npx svgo"
    else
        log "Both tools have similar performance"
    fi

    # Save detailed results
    local final_results="benchmark_results_$(date +%Y%m%d_%H%M%S).csv"
    cp "$results_file" "$final_results"
    log "Detailed results saved to: $final_results"
}

# Print usage
usage() {
    echo "Usage: $0 [SVG_DIR] [ITERATIONS] [MIN_FILES]"
    echo
    echo "Arguments:"
    echo "  SVG_DIR     Directory containing SVG files (default: testdata)"
    echo "  ITERATIONS  Number of benchmark iterations (default: 3)"
    echo "  MIN_FILES   Minimum number of SVG files required (default: 10)"
    echo
    echo "Example:"
    echo "  $0 testdata 5 20"
    echo "  $0 /path/to/svg/files"
}

# Main execution
main() {
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
        usage
        exit 0
    fi

    log "SVG Optimization Benchmark Tool"
    log "Comparing npx svgo vs ./target/release/svgn"
    echo

    check_tools
    find_svg_files
    run_benchmark

    success "Benchmark completed!"
}

main "$@"

```

Relative File Path: scripts/build_linux.sh

```bash
#!/bin/bash
# this_file: scripts/build_linux.sh

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}Building svgn for Linux...${NC}"

# Check if we're on Linux
if [[ "$OSTYPE" != "linux-gnu"* ]]; then
    echo -e "${RED}Error: This script must be run on Linux${NC}"
    exit 1
fi

# Setup paths
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$( cd "$SCRIPT_DIR/.." && pwd )"
DIST_DIR="$PROJECT_ROOT/dist/linux"
CARGO_DIR="$PROJECT_ROOT/svgn"

# Clean and create dist directory
echo -e "${YELLOW}Creating distribution directory...${NC}"
rm -rf "$DIST_DIR"
mkdir -p "$DIST_DIR"

# Install required tools if not present
if ! command -v cargo &> /dev/null; then
    echo -e "${RED}Error: cargo not found. Please install Rust.${NC}"
    exit 1
fi

# Determine architecture
ARCH=$(uname -m)
case $ARCH in
    x86_64)
        TARGET="x86_64-unknown-linux-gnu"
        ARCH_NAME="x86_64"
        ;;
    aarch64)
        TARGET="aarch64-unknown-linux-gnu"
        ARCH_NAME="aarch64"
        ;;
    armv7l)
        TARGET="armv7-unknown-linux-gnueabihf"
        ARCH_NAME="armv7"
        ;;
    *)
        echo -e "${RED}Unsupported architecture: $ARCH${NC}"
        exit 1
        ;;
esac

echo -e "${YELLOW}Building for $ARCH_NAME ($TARGET)...${NC}"

# Add target if not already added
rustup target add "$TARGET" 2>/dev/null || true

# Build release binary
cd "$CARGO_DIR"
cargo build --release --target "$TARGET"

# Copy binary to dist directory
cp "target/$TARGET/release/svgn" "$DIST_DIR/"
chmod +x "$DIST_DIR/svgn"

# Strip the binary to reduce size
echo -e "${YELLOW}Stripping binary...${NC}"
strip "$DIST_DIR/svgn"

# Verify the binary
echo -e "${YELLOW}Verifying binary...${NC}"
file "$DIST_DIR/svgn"
ldd "$DIST_DIR/svgn" 2>/dev/null || echo "Note: Binary might be statically linked"

# Test the binary
echo -e "${YELLOW}Testing binary...${NC}"
"$DIST_DIR/svgn" --version || {
    echo -e "${RED}Error: Binary test failed${NC}"
    exit 1
}

# Check binary size (warn if too large)
BINARY_SIZE=$(stat -c%s "$DIST_DIR/svgn" 2>/dev/null || stat -f%z "$DIST_DIR/svgn")
BINARY_SIZE_MB=$((BINARY_SIZE / 1024 / 1024))
if [ $BINARY_SIZE_MB -gt 50 ]; then
    echo -e "${YELLOW}Warning: Binary size is ${BINARY_SIZE_MB}MB, consider optimization${NC}"
fi

# Get version from Cargo.toml
VERSION=$(grep '^version' "$CARGO_DIR/Cargo.toml" | head -1 | cut -d '"' -f 2)
echo -e "${GREEN}Building version: $VERSION${NC}"

# Create tar.gz archive
echo -e "${YELLOW}Creating tar.gz archive...${NC}"
cd "$DIST_DIR"
tar -czf "svgn-$VERSION-linux-$ARCH_NAME.tar.gz" svgn
cd "$PROJECT_ROOT"

# Create .deb package if dpkg is available
if command -v dpkg &> /dev/null; then
    echo -e "${YELLOW}Creating .deb package...${NC}"
    
    DEB_DIR="$DIST_DIR/deb"
    mkdir -p "$DEB_DIR/DEBIAN"
    mkdir -p "$DEB_DIR/usr/local/bin"
    
    # Copy binary
    cp "$DIST_DIR/svgn" "$DEB_DIR/usr/local/bin/"
    
    # Create control file
    cat > "$DEB_DIR/DEBIAN/control" << EOF
Package: svgn
Version: $VERSION
Section: utils
Priority: optional
Architecture: $ARCH_NAME
Maintainer: svgn developers
Description: SVG Optimizer - A fast, native SVG optimization tool
 svgn is a Rust port of SVGO, providing high-performance SVG optimization
 with a command-line interface.
EOF
    
    # Build the .deb package
    dpkg-deb --build "$DEB_DIR" "$DIST_DIR/svgn-$VERSION-linux-$ARCH_NAME.deb"
    
    # Clean up
    rm -rf "$DEB_DIR"
else
    echo -e "${YELLOW}dpkg not found, skipping .deb package creation${NC}"
fi

# Create RPM package if rpmbuild is available
if command -v rpmbuild &> /dev/null; then
    echo -e "${YELLOW}Creating .rpm package...${NC}"
    
    RPM_DIR="$DIST_DIR/rpm"
    mkdir -p "$RPM_DIR/BUILD"
    mkdir -p "$RPM_DIR/RPMS"
    mkdir -p "$RPM_DIR/SOURCES"
    mkdir -p "$RPM_DIR/SPECS"
    
    # Create spec file
    cat > "$RPM_DIR/SPECS/svgn.spec" << EOF
Name:           svgn
Version:        $VERSION
Release:        1%{?dist}
Summary:        SVG Optimizer - A fast, native SVG optimization tool

License:        MIT
URL:            https://github.com/twardoch/svgn

%description
svgn is a Rust port of SVGO, providing high-performance SVG optimization
with a command-line interface.

%install
mkdir -p %{buildroot}/usr/local/bin
install -m 755 $DIST_DIR/svgn %{buildroot}/usr/local/bin/svgn

%files
/usr/local/bin/svgn

%changelog
* $(date +"%a %b %d %Y") svgn developers - $VERSION-1
- Release version $VERSION
EOF
    
    # Build the RPM
    rpmbuild --define "_topdir $RPM_DIR" \
             --define "_rpmdir $DIST_DIR" \
             -bb "$RPM_DIR/SPECS/svgn.spec" || echo -e "${YELLOW}RPM build failed${NC}"
    
    # Clean up
    rm -rf "$RPM_DIR"
else
    echo -e "${YELLOW}rpmbuild not found, skipping .rpm package creation${NC}"
fi

# Create AppImage if available
if command -v appimagetool &> /dev/null; then
    echo -e "${YELLOW}Creating AppImage...${NC}"
    
    APPIMAGE_DIR="$DIST_DIR/AppDir"
    mkdir -p "$APPIMAGE_DIR/usr/bin"
    
    # Copy binary
    cp "$DIST_DIR/svgn" "$APPIMAGE_DIR/usr/bin/"
    
    # Create desktop file
    cat > "$APPIMAGE_DIR/svgn.desktop" << EOF
[Desktop Entry]
Name=svgn
Exec=svgn
Icon=svgn
Type=Application
Categories=Utility;
Terminal=true
EOF
    
    # Create a simple icon (1x1 PNG)
    printf '\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x02\x00\x00\x00\x90wS\xde\x00\x00\x00\x0cIDATx\x9cc\xf8\x0f\x00\x00\x01\x01\x00\x05T\xbc\xa8\x15\x00\x00\x00\x00IEND\xaeB`\x82' > "$APPIMAGE_DIR/svgn.png"
    
    # Create AppRun
    cat > "$APPIMAGE_DIR/AppRun" << 'EOF'
#!/bin/bash
HERE="$(dirname "$(readlink -f "${0}")")"
exec "$HERE/usr/bin/svgn" "$@"
EOF
    chmod +x "$APPIMAGE_DIR/AppRun"
    
    # Build AppImage
    ARCH=$ARCH_NAME appimagetool "$APPIMAGE_DIR" "$DIST_DIR/svgn-$VERSION-linux-$ARCH_NAME.AppImage" || echo -e "${YELLOW}AppImage creation failed${NC}"
    
    # Clean up
    rm -rf "$APPIMAGE_DIR"
else
    echo -e "${YELLOW}appimagetool not found, skipping AppImage creation${NC}"
fi

# Create install script
cat > "$DIST_DIR/install.sh" << 'EOF'
#!/bin/bash
echo "Installing svgn to /usr/local/bin..."
sudo cp svgn /usr/local/bin/
sudo chmod +x /usr/local/bin/svgn
echo "Installation complete! Run 'svgn --help' to get started."
EOF
chmod +x "$DIST_DIR/install.sh"

# Summary
echo -e "${GREEN}Build complete!${NC}"
echo -e "${GREEN}Distribution files created in: $DIST_DIR${NC}"
echo -e "  - svgn (binary)"
echo -e "  - svgn-$VERSION-linux-$ARCH_NAME.tar.gz"
if [[ -f "$DIST_DIR/svgn-$VERSION-linux-$ARCH_NAME.deb" ]]; then
    echo -e "  - svgn-$VERSION-linux-$ARCH_NAME.deb"
fi
if [[ -f "$DIST_DIR/$ARCH_NAME/svgn-$VERSION-1.$ARCH_NAME.rpm" ]]; then
    echo -e "  - svgn-$VERSION-1.$ARCH_NAME.rpm"
fi
if [[ -f "$DIST_DIR/svgn-$VERSION-linux-$ARCH_NAME.AppImage" ]]; then
    echo -e "  - svgn-$VERSION-linux-$ARCH_NAME.AppImage"
fi
echo -e "  - install.sh"
```

Relative File Path: scripts/build_macos.sh

```bash
#!/bin/bash
# this_file: scripts/build_macos.sh

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}Building svgn for macOS...${NC}"

# Check if we're on macOS
if [[ "$OSTYPE" != "darwin"* ]]; then
    echo -e "${RED}Error: This script must be run on macOS${NC}"
    exit 1
fi

# Setup paths
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$( cd "$SCRIPT_DIR/.." && pwd )"
DIST_DIR="$PROJECT_ROOT/dist/macos"
CARGO_DIR="$PROJECT_ROOT/svgn"

# Clean and create dist directory
echo -e "${YELLOW}Creating distribution directory...${NC}"
rm -rf "$DIST_DIR"
mkdir -p "$DIST_DIR"

# Install required tools if not present
if ! command -v cargo &> /dev/null; then
    echo -e "${RED}Error: cargo not found. Please install Rust.${NC}"
    exit 1
fi

# Add targets if not already added
echo -e "${YELLOW}Adding build targets...${NC}"
rustup target add x86_64-apple-darwin 2>/dev/null || true
rustup target add aarch64-apple-darwin 2>/dev/null || true

# Build for x86_64
echo -e "${YELLOW}Building for x86_64...${NC}"
cd "$CARGO_DIR"
cargo build --release --target x86_64-apple-darwin

# Build for aarch64 (Apple Silicon)
echo -e "${YELLOW}Building for aarch64...${NC}"
cargo build --release --target aarch64-apple-darwin

# Create universal binary
echo -e "${YELLOW}Creating universal binary...${NC}"
lipo -create \
    "$PROJECT_ROOT/target/x86_64-apple-darwin/release/svgn" \
    "$PROJECT_ROOT/target/aarch64-apple-darwin/release/svgn" \
    -output "$DIST_DIR/svgn"

# Make it executable
chmod +x "$DIST_DIR/svgn"

# Verify the universal binary
echo -e "${YELLOW}Verifying universal binary...${NC}"
file "$DIST_DIR/svgn"
lipo -info "$DIST_DIR/svgn"

# Test the binary
echo -e "${YELLOW}Testing binary...${NC}"
"$DIST_DIR/svgn" --version || {
    echo -e "${RED}Error: Binary test failed${NC}"
    exit 1
}

# Verify it's truly universal
ARCHS=$(lipo -archs "$DIST_DIR/svgn")
if [[ "$ARCHS" != *"x86_64"* ]] || [[ "$ARCHS" != *"arm64"* ]]; then
    echo -e "${RED}Error: Binary is not universal (found: $ARCHS)${NC}"
    exit 1
fi

# Get version from git tag or binary
VERSION=$("$DIST_DIR/svgn" --version | cut -d ' ' -f 2)
echo -e "${GREEN}Building version: $VERSION${NC}"

# Create tar.gz archive
echo -e "${YELLOW}Creating tar.gz archive...${NC}"
cd "$DIST_DIR"
tar -czf "svgn-$VERSION-macos-universal.tar.gz" svgn
cd "$PROJECT_ROOT"

# Create pkg installer
echo -e "${YELLOW}Creating .pkg installer...${NC}"
PKG_ROOT="$DIST_DIR/pkg-root"
mkdir -p "$PKG_ROOT/usr/local/bin"
cp "$DIST_DIR/svgn" "$PKG_ROOT/usr/local/bin/"

# Create the package
pkgbuild \
    --root "$PKG_ROOT" \
    --identifier "com.svgn.cli" \
    --version "$VERSION" \
    --install-location "/" \
    "$DIST_DIR/svgn-$VERSION-macos.pkg"

# Clean up pkg root
rm -rf "$PKG_ROOT"

# Create DMG
echo -e "${YELLOW}Creating .dmg...${NC}"
DMG_ROOT="$DIST_DIR/dmg-root"
mkdir -p "$DMG_ROOT"
cp "$DIST_DIR/svgn" "$DMG_ROOT/"

# Create a simple README for the DMG
cat > "$DMG_ROOT/README.txt" << EOF
svgn - SVG Optimizer
Version: $VERSION

To install:
1. Copy 'svgn' to /usr/local/bin/ or another directory in your PATH
2. Make sure it's executable: chmod +x /usr/local/bin/svgn
3. Run: svgn --help

Or use the .pkg installer for automatic installation.
EOF

# Create DMG
hdiutil create -volname "svgn-$VERSION" \
    -srcfolder "$DMG_ROOT" \
    -ov \
    -format UDZO \
    "$DIST_DIR/svgn-$VERSION-macos.dmg"

# Clean up DMG root
rm -rf "$DMG_ROOT"

# Create a simple install script
cat > "$DIST_DIR/install.sh" << 'EOF'
#!/bin/bash
echo "Installing svgn to /usr/local/bin..."
sudo cp svgn /usr/local/bin/
sudo chmod +x /usr/local/bin/svgn
echo "Installation complete! Run 'svgn --help' to get started."
EOF
chmod +x "$DIST_DIR/install.sh"

# Summary
echo -e "${GREEN}Build complete!${NC}"
echo -e "${GREEN}Distribution files created in: $DIST_DIR${NC}"
echo -e "  - svgn (universal binary)"
echo -e "  - svgn-$VERSION-macos-universal.tar.gz"
echo -e "  - svgn-$VERSION-macos.pkg"
echo -e "  - svgn-$VERSION-macos.dmg"
echo -e "  - install.sh"
```

Relative File Path: scripts/build_windows.cmd

```
@echo off
REM this_file: scripts/build_windows.cmd

setlocal enabledelayedexpansion

echo Building svgn for Windows...

REM Setup paths
set SCRIPT_DIR=%~dp0
set PROJECT_ROOT=%SCRIPT_DIR%..
set DIST_DIR=%PROJECT_ROOT%\dist\windows
set CARGO_DIR=%PROJECT_ROOT%\svgn

REM Clean and create dist directory
echo Creating distribution directory...
if exist "%DIST_DIR%" rmdir /s /q "%DIST_DIR%"
mkdir "%DIST_DIR%"

REM Check if cargo is available
where cargo >nul 2>nul
if %ERRORLEVEL% neq 0 (
    echo Error: cargo not found. Please install Rust.
    exit /b 1
)

REM Determine architecture
set ARCH=%PROCESSOR_ARCHITECTURE%
if "%ARCH%"=="AMD64" (
    set TARGET=x86_64-pc-windows-msvc
    set ARCH_NAME=x64
) else if "%ARCH%"=="x86" (
    set TARGET=i686-pc-windows-msvc
    set ARCH_NAME=x86
) else if "%ARCH%"=="ARM64" (
    set TARGET=aarch64-pc-windows-msvc
    set ARCH_NAME=arm64
) else (
    echo Unsupported architecture: %ARCH%
    exit /b 1
)

echo Building for %ARCH_NAME% (%TARGET%)...

REM Add target if not already added
rustup target add %TARGET% 2>nul

REM Build release binary
cd "%CARGO_DIR%"
cargo build --release --target %TARGET%
if %ERRORLEVEL% neq 0 (
    echo Build failed!
    exit /b 1
)

REM Copy executable to dist directory
copy "target\%TARGET%\release\svgn.exe" "%DIST_DIR%\" >nul
if %ERRORLEVEL% neq 0 (
    echo Failed to copy executable!
    exit /b 1
)

REM Test the binary
echo Testing binary...
"%DIST_DIR%\svgn.exe" --version >nul 2>&1
if %ERRORLEVEL% neq 0 (
    echo Error: Binary test failed!
    exit /b 1
)

REM Check binary size
for %%F in ("%DIST_DIR%\svgn.exe") do set SIZE=%%~zF
set /a SIZE_MB=%SIZE% / 1048576
if %SIZE_MB% gtr 50 (
    echo Warning: Binary size is %SIZE_MB%MB, consider optimization
)

REM Get version from Cargo.toml
for /f "tokens=2 delims==" %%i in ('findstr /r "^version" "%CARGO_DIR%\Cargo.toml"') do (
    set VERSION_LINE=%%i
    goto :version_found
)
:version_found
REM Remove quotes and spaces from version
set VERSION=%VERSION_LINE:"=%
set VERSION=%VERSION: =%
echo Building version: %VERSION%

REM Create zip archive
echo Creating zip archive...
cd "%DIST_DIR%"
powershell -Command "Compress-Archive -Path 'svgn.exe' -DestinationPath 'svgn-%VERSION%-windows-%ARCH_NAME%.zip' -Force"
cd "%PROJECT_ROOT%"

REM Create MSI installer if WiX is available
where candle >nul 2>nul
if %ERRORLEVEL% equ 0 (
    echo Creating MSI installer...
    
    REM Create WiX source file
    echo ^<?xml version="1.0" encoding="UTF-8"?^> > "%DIST_DIR%\svgn.wxs"
    echo ^<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi"^> >> "%DIST_DIR%\svgn.wxs"
    echo   ^<Product Id="*" Name="svgn" Language="1033" Version="%VERSION%.0" >> "%DIST_DIR%\svgn.wxs"
    echo            Manufacturer="svgn developers" UpgradeCode="a7c2e4b5-8d6f-4a3b-9c1e-2f5d7b9a4c6e"^> >> "%DIST_DIR%\svgn.wxs"
    echo     ^<Package InstallerVersion="200" Compressed="yes" InstallScope="perMachine" /^> >> "%DIST_DIR%\svgn.wxs"
    echo     ^<MajorUpgrade DowngradeErrorMessage="A newer version is already installed." /^> >> "%DIST_DIR%\svgn.wxs"
    echo     ^<MediaTemplate EmbedCab="yes" /^> >> "%DIST_DIR%\svgn.wxs"
    echo     ^<Feature Id="ProductFeature" Title="svgn" Level="1"^> >> "%DIST_DIR%\svgn.wxs"
    echo       ^<ComponentGroupRef Id="ProductComponents" /^> >> "%DIST_DIR%\svgn.wxs"
    echo     ^</Feature^> >> "%DIST_DIR%\svgn.wxs"
    echo     ^<Directory Id="TARGETDIR" Name="SourceDir"^> >> "%DIST_DIR%\svgn.wxs"
    echo       ^<Directory Id="ProgramFilesFolder"^> >> "%DIST_DIR%\svgn.wxs"
    echo         ^<Directory Id="INSTALLFOLDER" Name="svgn" /^> >> "%DIST_DIR%\svgn.wxs"
    echo       ^</Directory^> >> "%DIST_DIR%\svgn.wxs"
    echo     ^</Directory^> >> "%DIST_DIR%\svgn.wxs"
    echo     ^<ComponentGroup Id="ProductComponents" Directory="INSTALLFOLDER"^> >> "%DIST_DIR%\svgn.wxs"
    echo       ^<Component Id="svgn.exe" Guid="b8c3d5a7-2f6e-4d9c-8a1b-3e5f7c9d2b4a"^> >> "%DIST_DIR%\svgn.wxs"
    echo         ^<File Id="svgn.exe" Source="svgn.exe" KeyPath="yes"/^> >> "%DIST_DIR%\svgn.wxs"
    echo         ^<Environment Id="PATH" Name="PATH" Value="[INSTALLFOLDER]" >> "%DIST_DIR%\svgn.wxs"
    echo                      Permanent="no" Part="last" Action="set" System="yes" /^> >> "%DIST_DIR%\svgn.wxs"
    echo       ^</Component^> >> "%DIST_DIR%\svgn.wxs"
    echo     ^</ComponentGroup^> >> "%DIST_DIR%\svgn.wxs"
    echo   ^</Product^> >> "%DIST_DIR%\svgn.wxs"
    echo ^</Wix^> >> "%DIST_DIR%\svgn.wxs"
    
    REM Compile and link the MSI
    cd "%DIST_DIR%"
    candle svgn.wxs -o svgn.wixobj
    light svgn.wixobj -o "svgn-%VERSION%-windows-%ARCH_NAME%.msi"
    
    REM Clean up WiX files
    del svgn.wxs svgn.wixobj 2>nul
    cd "%PROJECT_ROOT%"
) else (
    echo WiX toolset not found, skipping MSI creation
)

REM Create installer using Inno Setup if available
set INNO_PATH=
for %%p in (
    "%ProgramFiles(x86)%\Inno Setup 6\ISCC.exe"
    "%ProgramFiles%\Inno Setup 6\ISCC.exe"
    "%ProgramFiles(x86)%\Inno Setup 5\ISCC.exe"
    "%ProgramFiles%\Inno Setup 5\ISCC.exe"
) do (
    if exist "%%~p" (
        set INNO_PATH=%%~p
        goto :inno_found
    )
)
:inno_found

if defined INNO_PATH (
    echo Creating Inno Setup installer...
    
    REM Create Inno Setup script
    echo [Setup] > "%DIST_DIR%\svgn.iss"
    echo AppName=svgn >> "%DIST_DIR%\svgn.iss"
    echo AppVersion=%VERSION% >> "%DIST_DIR%\svgn.iss"
    echo DefaultDirName={autopf}\svgn >> "%DIST_DIR%\svgn.iss"
    echo DefaultGroupName=svgn >> "%DIST_DIR%\svgn.iss"
    echo OutputDir=. >> "%DIST_DIR%\svgn.iss"
    echo OutputBaseFilename=svgn-%VERSION%-windows-%ARCH_NAME%-setup >> "%DIST_DIR%\svgn.iss"
    echo Compression=lzma2 >> "%DIST_DIR%\svgn.iss"
    echo SolidCompression=yes >> "%DIST_DIR%\svgn.iss"
    echo ChangesEnvironment=yes >> "%DIST_DIR%\svgn.iss"
    echo. >> "%DIST_DIR%\svgn.iss"
    echo [Files] >> "%DIST_DIR%\svgn.iss"
    echo Source: "svgn.exe"; DestDir: "{app}"; Flags: ignoreversion >> "%DIST_DIR%\svgn.iss"
    echo. >> "%DIST_DIR%\svgn.iss"
    echo [Registry] >> "%DIST_DIR%\svgn.iss"
    echo Root: HKLM; Subkey: "SYSTEM\CurrentControlSet\Control\Session Manager\Environment"; ValueType: expandsz; ValueName: "Path"; ValueData: "{olddata};{app}"; Check: NeedsAddPath('{app}') >> "%DIST_DIR%\svgn.iss"
    echo. >> "%DIST_DIR%\svgn.iss"
    echo [Code] >> "%DIST_DIR%\svgn.iss"
    echo function NeedsAddPath(Param: string): boolean; >> "%DIST_DIR%\svgn.iss"
    echo var >> "%DIST_DIR%\svgn.iss"
    echo   OrigPath: string; >> "%DIST_DIR%\svgn.iss"
    echo begin >> "%DIST_DIR%\svgn.iss"
    echo   if not RegQueryStringValue(HKEY_LOCAL_MACHINE, >> "%DIST_DIR%\svgn.iss"
    echo     'SYSTEM\CurrentControlSet\Control\Session Manager\Environment', >> "%DIST_DIR%\svgn.iss"
    echo     'Path', OrigPath) then >> "%DIST_DIR%\svgn.iss"
    echo   begin >> "%DIST_DIR%\svgn.iss"
    echo     Result := True; >> "%DIST_DIR%\svgn.iss"
    echo     exit; >> "%DIST_DIR%\svgn.iss"
    echo   end; >> "%DIST_DIR%\svgn.iss"
    echo   Result := Pos(';' + Param + ';', ';' + OrigPath + ';') = 0; >> "%DIST_DIR%\svgn.iss"
    echo end; >> "%DIST_DIR%\svgn.iss"
    
    REM Compile the installer
    cd "%DIST_DIR%"
    "%INNO_PATH%" svgn.iss
    
    REM Clean up
    del svgn.iss 2>nul
    cd "%PROJECT_ROOT%"
) else (
    echo Inno Setup not found, skipping installer creation
)

REM Create a batch install script
echo @echo off > "%DIST_DIR%\install.bat"
echo echo Installing svgn... >> "%DIST_DIR%\install.bat"
echo. >> "%DIST_DIR%\install.bat"
echo set INSTALL_DIR=%%ProgramFiles%%\svgn >> "%DIST_DIR%\install.bat"
echo if not exist "%%INSTALL_DIR%%" mkdir "%%INSTALL_DIR%%" >> "%DIST_DIR%\install.bat"
echo copy /Y svgn.exe "%%INSTALL_DIR%%\" >> "%DIST_DIR%\install.bat"
echo. >> "%DIST_DIR%\install.bat"
echo echo Adding to PATH... >> "%DIST_DIR%\install.bat"
echo setx PATH "%%PATH%%;%%INSTALL_DIR%%" /M >> "%DIST_DIR%\install.bat"
echo. >> "%DIST_DIR%\install.bat"
echo echo Installation complete! >> "%DIST_DIR%\install.bat"
echo echo Please restart your command prompt and run 'svgn --help' >> "%DIST_DIR%\install.bat"
echo pause >> "%DIST_DIR%\install.bat"

REM Summary
echo.
echo Build complete!
echo Distribution files created in: %DIST_DIR%
echo   - svgn.exe
echo   - svgn-%VERSION%-windows-%ARCH_NAME%.zip
if exist "%DIST_DIR%\svgn-%VERSION%-windows-%ARCH_NAME%.msi" (
    echo   - svgn-%VERSION%-windows-%ARCH_NAME%.msi
)
if exist "%DIST_DIR%\svgn-%VERSION%-windows-%ARCH_NAME%-setup.exe" (
    echo   - svgn-%VERSION%-windows-%ARCH_NAME%-setup.exe
)
echo   - install.bat

endlocal
```

Relative File Path: scripts/test1.sh

```bash
#!/usr/bin/env bash
cd $(dirname "$0")/..
echo "original"
cat testdata/complex.svg
echo
echo "--------------------------------"
echo "svgn"
cat testdata/complex.svg | ./target/release/svgn -i - -o -
echo
echo "--------------------------------"
echo "svgo"
cat testdata/complex.svg | npx svgo -i - -o -
echo "--------------------------------"

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/src/plugins/convert_one_stop_gradients.rs
# Language: rust

mod tests;

struct ConvertOneStopGradientsPlugin {
}

struct GradientInfo {
}

struct StopInfo {
}

struct ReplaceVisitor {
}

struct RemoveVisitor {
}


Relative File Path: svgn/Cargo.toml

```toml
[package]
name = "svgn"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
repository.workspace = true
homepage.workspace = true
description = "A high-performance Rust port of SVGO (SVG Optimizer)"
readme = "../README.md"
keywords = ["svg", "optimization", "graphics", "xml", "cli"]
categories = ["graphics", "command-line-utilities", "web-programming"]

[[bin]]
name = "svgn"
path = "src/bin/svgn.rs"

[dependencies]
once_cell = { workspace = true }
# XML parsing
quick-xml = { workspace = true }

# CSS parsing  
cssparser = { workspace = true }
selectors = { workspace = true }
lightningcss = { workspace = true }

# CLI
clap = { workspace = true }

# Configuration and serialization
serde = { workspace = true }
serde_json = { workspace = true }
toml = { workspace = true }

# Path processing
lyon = { workspace = true }

# Matrix operations
nalgebra = { workspace = true }

# Optional: SVG utilities
usvg = { version = "0.42", optional = true }

# Error handling
thiserror = { workspace = true }

# Regular expressions
regex = { workspace = true }

# URL encoding
urlencoding = { workspace = true }

# Ordered maps
indexmap = { workspace = true }

# WASM support
[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = { workspace = true }
js-sys = { workspace = true }

[features]
default = []
usvg-utils = ["dep:usvg"]

[dev-dependencies]
criterion = { workspace = true }

[[bench]]
name = "optimization"
harness = false

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/benches/optimization.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/build.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_css_debug.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs
# Language: rust

mod tests;

struct Document {
}

struct DocumentMetadata {
}

struct Element {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs
# Language: rust



Relative File Path: svgn/src/collections.rs

```rust
use once_cell::sync::Lazy;
use std::collections::{HashMap, HashSet};

pub static COLORS_NAMES: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    HashMap::from([
        ("aliceblue", "#f0f8ff"),
        ("antiquewhite", "#faebd7"),
        ("aqua", "#00ffff"),
        ("aquamarine", "#7fffd4"),
        ("azure", "#f0ffff"),
        ("beige", "#f5f5dc"),
        ("bisque", "#ffe4c4"),
        ("black", "#000000"),
        ("blanchedalmond", "#ffebcd"),
        ("blue", "#0000ff"),
        ("blueviolet", "#8a2be2"),
        ("brown", "#a52a2a"),
        ("burlywood", "#deb887"),
        ("cadetblue", "#5f9ea0"),
        ("chartreuse", "#7fff00"),
        ("chocolate", "#d2691e"),
        ("coral", "#ff7f50"),
        ("cornflowerblue", "#6495ed"),
        ("cornsilk", "#fff8dc"),
        ("crimson", "#dc143c"),
        ("cyan", "#00ffff"),
        ("darkblue", "#00008b"),
        ("darkcyan", "#008b8b"),
        ("darkgoldenrod", "#b8860b"),
        ("darkgray", "#a9a9a9"),
        ("darkgreen", "#006400"),
        ("darkgrey", "#a9a9a9"),
        ("darkkhaki", "#bdb76b"),
        ("darkmagenta", "#8b008b"),
        ("darkolivegreen", "#556b2f"),
        ("darkorange", "#ff8c00"),
        ("darkorchid", "#9932cc"),
        ("darkred", "#8b0000"),
        ("darksalmon", "#e9967a"),
        ("darkseagreen", "#8fbc8f"),
        ("darkslateblue", "#483d8b"),
        ("darkslategray", "#2f4f4f"),
        ("darkslategrey", "#2f4f4f"),
        ("darkturquoise", "#00ced1"),
        ("darkviolet", "#9400d3"),
        ("deeppink", "#ff1493"),
        ("deepskyblue", "#00bfff"),
        ("dimgray", "#696969"),
        ("dimgrey", "#696969"),
        ("dodgerblue", "#1e90ff"),
        ("firebrick", "#b22222"),
        ("floralwhite", "#fffaf0"),
        ("forestgreen", "#228b22"),
        ("fuchsia", "#ff00ff"),
        ("gainsboro", "#dcdcdc"),
        ("ghostwhite", "#f8f8ff"),
        ("gold", "#ffd700"),
        ("goldenrod", "#daa520"),
        ("gray", "#808080"),
        ("green", "#008000"),
        ("greenyellow", "#adff2f"),
        ("grey", "#808080"),
        ("honeydew", "#f0fff0"),
        ("hotpink", "#ff69b4"),
        ("indianred", "#cd5c5c"),
        ("indigo", "#4b0082"),
        ("ivory", "#fffff0"),
        ("khaki", "#f0e68c"),
        ("lavender", "#e6e6fa"),
        ("lavenderblush", "#fff0f5"),
        ("lawngreen", "#7cfc00"),
        ("lemonchiffon", "#fffacd"),
        ("lightblue", "#add8e6"),
        ("lightcoral", "#f08080"),
        ("lightcyan", "#e0ffff"),
        ("lightgoldenrodyellow", "#fafad2"),
        ("lightgray", "#d3d3d3"),
        ("lightgreen", "#90ee90"),
        ("lightgrey", "#d3d3d3"),
        ("lightpink", "#ffb6c1"),
        ("lightsalmon", "#ffa07a"),
        ("lightseagreen", "#20b2aa"),
        ("lightskyblue", "#87cefa"),
        ("lightslategray", "#778899"),
        ("lightslategrey", "#778899"),
        ("lightsteelblue", "#b0c4de"),
        ("lightyellow", "#ffffe0"),
        ("lime", "#00ff00"),
        ("limegreen", "#32cd32"),
        ("linen", "#faf0e6"),
        ("magenta", "#ff00ff"),
        ("maroon", "#800000"),
        ("mediumaquamarine", "#66cdaa"),
        ("mediumblue", "#0000cd"),
        ("mediumorchid", "#ba55d3"),
        ("mediumpurple", "#9370db"),
        ("mediumseagreen", "#3cb371"),
        ("mediumslateblue", "#7b68ee"),
        ("mediumspringgreen", "#00fa9a"),
        ("mediumturquoise", "#48d1cc"),
        ("mediumvioletred", "#c71585"),
        ("midnightblue", "#191970"),
        ("mintcream", "#f5fffa"),
        ("mistyrose", "#ffe4e1"),
        ("moccasin", "#ffe4b5"),
        ("navajowhite", "#ffdead"),
        ("navy", "#000080"),
        ("oldlace", "#fdf5e6"),
        ("olive", "#808000"),
        ("olivedrab", "#6b8e23"),
        ("orange", "#ffa500"),
        ("orangered", "#ff4500"),
        ("orchid", "#da70d6"),
        ("palegoldenrod", "#eee8aa"),
        ("palegreen", "#98fb98"),
        ("paleturquoise", "#afeeee"),
        ("palevioletred", "#db7093"),
        ("papayawhip", "#ffefd5"),
        ("peachpuff", "#ffdab9"),
        ("peru", "#cd853f"),
        ("pink", "#ffc0cb"),
        ("plum", "#dda0dd"),
        ("powderblue", "#b0e0e6"),
        ("purple", "#800080"),
        ("rebeccapurple", "#663399"),
        ("red", "#ff0000"),
        ("rosybrown", "#bc8f8f"),
        ("royalblue", "#4169e1"),
        ("saddlebrown", "#8b4513"),
        ("salmon", "#fa8072"),
        ("sandybrown", "#f4a460"),
        ("seagreen", "#2e8b57"),
        ("seashell", "#fff5ee"),
        ("sienna", "#a0522d"),
        ("silver", "#c0c0c0"),
        ("skyblue", "#87ceeb"),
        ("slateblue", "#6a5acd"),
        ("slategray", "#708090"),
        ("slategrey", "#708090"),
        ("snow", "#fffafa"),
        ("springgreen", "#00ff7f"),
        ("steelblue", "#4682b4"),
        ("tan", "#d2b48c"),
        ("teal", "#008080"),
        ("thistle", "#d8bfd8"),
        ("tomato", "#ff6347"),
        ("turquoise", "#40e0d0"),
        ("violet", "#ee82ee"),
        ("wheat", "#f5deb3"),
        ("white", "#ffffff"),
        ("whitesmoke", "#f5f5f5"),
        ("yellow", "#ffff00"),
        ("yellowgreen", "#9acd32"),
    ])
});

pub static COLORS_SHORT_NAMES: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    HashMap::from([
        ("#f0f8ff", "aliceblue"),
        ("#faebd7", "antiquewhite"),
        ("#00ffff", "aqua"),
        ("#7fffd4", "aquamarine"),
        ("#f0ffff", "azure"),
        ("#f5f5dc", "beige"),
        ("#ffe4c4", "bisque"),
        ("#000000", "black"),
        ("#ffebcd", "blanchedalmond"),
        ("#0000ff", "blue"),
        ("#8a2be2", "blueviolet"),
        ("#a52a2a", "brown"),
        ("#deb887", "burlywood"),
        ("#5f9ea0", "cadetblue"),
        ("#7fff00", "chartreuse"),
        ("#d2691e", "chocolate"),
        ("#ff7f50", "coral"),
        ("#6495ed", "cornflowerblue"),
        ("#fff8dc", "cornsilk"),
        ("#dc143c", "crimson"),
        ("#00ffff", "cyan"),
        ("#00008b", "darkblue"),
        ("#008b8b", "darkcyan"),
        ("#b8860b", "darkgoldenrod"),
        ("#a9a9a9", "darkgray"),
        ("#006400", "darkgreen"),
        ("#a9a9a9", "darkgrey"),
        ("#bdb76b", "darkkhaki"),
        ("#8b008b", "darkmagenta"),
        ("#556b2f", "darkolivegreen"),
        ("#ff8c00", "darkorange"),
        ("#9932cc", "darkorchid"),
        ("#8b0000", "darkred"),
        ("#e9967a", "darksalmon"),
        ("#8fbc8f", "darkseagreen"),
        ("#483d8b", "darkslateblue"),
        ("#2f4f4f", "darkslategray"),
        ("#2f4f4f", "darkslategrey"),
        ("#00ced1", "darkturquoise"),
        ("#9400d3", "darkviolet"),
        ("#ff1493", "deeppink"),
        ("#00bfff", "deepskyblue"),
        ("#696969", "dimgray"),
        ("#696969", "dimgrey"),
        ("#1e90ff", "dodgerblue"),
        ("#b22222", "firebrick"),
        ("#fffaf0", "floralwhite"),
        ("#228b22", "forestgreen"),
        ("#ff00ff", "fuchsia"),
        ("#dcdcdc", "gainsboro"),
        ("#f8f8ff", "ghostwhite"),
        ("#ffd700", "gold"),
        ("#daa520", "goldenrod"),
        ("#808080", "gray"),
        ("#008000", "green"),
        ("#adff2f", "greenyellow"),
        ("#808080", "grey"),
        ("#f0fff0", "honeydew"),
        ("#ff69b4", "hotpink"),
        ("#cd5c5c", "indianred"),
        ("#4b0082", "indigo"),
        ("#fffff0", "ivory"),
        ("#f0e68c", "khaki"),
        ("#e6e6fa", "lavender"),
        ("#fff0f5", "lavenderblush"),
        ("#7cfc00", "lawngreen"),
        ("#fffacd", "lemonchiffon"),
        ("#add8e6", "lightblue"),
        ("#f08080", "lightcoral"),
        ("#e0ffff", "lightcyan"),
        ("#fafad2", "lightgoldenrodyellow"),
        ("#d3d3d3", "lightgray"),
        ("#90ee90", "lightgreen"),
        ("#d3d3d3", "lightgrey"),
        ("#ffb6c1", "lightpink"),
        ("#ffa07a", "lightsalmon"),
        ("#20b2aa", "lightseagreen"),
        ("#87cefa", "lightskyblue"),
        ("#778899", "lightslategray"),
        ("#778899", "lightslategrey"),
        ("#b0c4de", "lightsteelblue"),
        ("#ffffe0", "lightyellow"),
        ("#00ff00", "lime"),
        ("#32cd32", "limegreen"),
        ("#faf0e6", "linen"),
        ("#ff00ff", "magenta"),
        ("#800000", "maroon"),
        ("#66cdaa", "mediumaquamarine"),
        ("#0000cd", "mediumblue"),
        ("#ba55d3", "mediumorchid"),
        ("#9370db", "mediumpurple"),
        ("#3cb371", "mediumseagreen"),
        ("#7b68ee", "mediumslateblue"),
        ("#00fa9a", "mediumspringgreen"),
        ("#48d1cc", "mediumturquoise"),
        ("#c71585", "mediumvioletred"),
        ("#191970", "midnightblue"),
        ("f5fffa", "mintcream"),
        ("#ffe4e1", "mistyrose"),
        ("#ffe4b5", "moccasin"),
        ("#ffdead", "navajowhite"),
        ("#000080", "navy"),
        ("#fdf5e6", "oldlace"),
        ("#808000", "olive"),
        ("#6b8e23", "olivedrab"),
        ("#ffa500", "orange"),
        ("#ff4500", "orangered"),
        ("#da70d6", "orchid"),
        ("#eee8aa", "palegoldenrod"),
        ("#98fb98", "palegreen"),
        ("#afeeee", "paleturquoise"),
        ("#db7093", "palevioletred"),
        ("#ffefd5", "papayawhip"),
        ("#ffdab9", "peachpuff"),
        ("#cd853f", "peru"),
        ("#ffc0cb", "pink"),
        ("#dda0dd", "plum"),
        ("#b0e0e6", "powderblue"),
        ("#800080", "purple"),
        ("#663399", "rebeccapurple"),
        ("#ff0000", "red"),
        ("#bc8f8f", "rosybrown"),
        ("#4169e1", "royalblue"),
        ("#8b4513", "saddlebrown"),
        ("#fa8072", "salmon"),
        ("#f4a460", "sandybrown"),
        ("#2e8b57", "seagreen"),
        ("#fff5ee", "seashell"),
        ("#a0522d", "sienna"),
        ("#c0c0c0", "silver"),
        ("#87ceeb", "skyblue"),
        ("#6a5acd", "slateblue"),
        ("#708090", "slategray"),
        ("#708090", "slategrey"),
        ("#fffafa", "snow"),
        ("#00ff7f", "springgreen"),
        ("#4682b4", "steelblue"),
        ("#d2b48c", "tan"),
        ("#008080", "teal"),
        ("#d8bfd8", "thistle"),
        ("#ff6347", "tomato"),
        ("#40e0d0", "turquoise"),
        ("#ee82ee", "violet"),
        ("#f5deb3", "wheat"),
        ("#ffffff", "white"),
        ("#f5f5f5", "whitesmoke"),
        ("#ffff00", "yellow"),
        ("#9acd32", "yellowgreen"),
    ])
});

pub static COLORS_PROPS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "fill",
        "fill-opacity",
        "stroke",
        "stroke-opacity",
        "stop-color",
        "stop-opacity",
        "flood-color",
        "flood-opacity",
        "lighting-color",
        "color",
    ])
});

/// Animation elements in SVG
pub static ANIMATION_ELEMS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "animate",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "set",
    ])
});

/// Inheritable attributes in SVG
pub static INHERITABLE_ATTRS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "clip-rule",
        "color-interpolation-filters",
        "color-interpolation",
        "color-profile",
        "color-rendering",
        "color",
        "cursor",
        "direction",
        "display",
        "dominant-baseline",
        "fill-opacity",
        "fill-rule",
        "fill",
        "font-family",
        "font-size-adjust",
        "font-size",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "font",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "image-rendering",
        "letter-spacing",
        "marker-end",
        "marker-mid",
        "marker-start",
        "marker",
        "paint-order",
        "pointer-events",
        "shape-rendering",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "stroke",
        "text-anchor",
        "text-rendering",
        "transform",
        "visibility",
        "word-spacing",
        "writing-mode",
    ])
});

/// SVG presentation attributes that can be set as attributes
pub static PRESENTATION_ATTRS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "alignment-baseline",
        "baseline-shift",
        "clip-path",
        "clip-rule",
        "clip",
        "color-interpolation-filters",
        "color-interpolation",
        "color-profile",
        "color-rendering",
        "color",
        "cursor",
        "direction",
        "display",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "fill",
        "filter",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size-adjust",
        "font-size",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "mask",
        "opacity",
        "overflow",
        "paint-order",
        "pointer-events",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "stroke",
        "text-anchor",
        "text-decoration",
        "text-overflow",
        "text-rendering",
        "transform-origin",
        "transform",
        "unicode-bidi",
        "vector-effect",
        "visibility",
        "word-spacing",
        "writing-mode",
    ])
});

/// Animation event attributes in SVG
pub static ANIMATION_EVENT_ATTRS: Lazy<HashSet<&'static str>> =
    Lazy::new(|| HashSet::from(["onbegin", "onend", "onrepeat", "onload"]));

/// Document event attributes in SVG
pub static DOCUMENT_EVENT_ATTRS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "onabort", "onerror", "onresize", "onscroll", "onunload", "onzoom",
    ])
});

/// Document element event attributes in SVG
pub static DOCUMENT_ELEMENT_EVENT_ATTRS: Lazy<HashSet<&'static str>> =
    Lazy::new(|| HashSet::from(["oncopy", "oncut", "onpaste"]));

/// Global event attributes in SVG
pub static GLOBAL_EVENT_ATTRS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "oncancel",
        "oncanplay",
        "oncanplaythrough",
        "onchange",
        "onclick",
        "onclose",
        "oncuechange",
        "ondblclick",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onended",
        "onerror",
        "onfocus",
        "oninput",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeyup",
        "onload",
        "onloadeddata",
        "onloadedmetadata",
        "onloadstart",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onmousewheel",
        "onpause",
        "onplay",
        "onplaying",
        "onprogress",
        "onratechange",
        "onreset",
        "onresize",
        "onscroll",
        "onseeked",
        "onseeking",
        "onselect",
        "onshow",
        "onstalled",
        "onsubmit",
        "onsuspend",
        "ontimeupdate",
        "ontoggle",
        "onvolumechange",
        "onwaiting",
    ])
});

/// Graphical event attributes in SVG
pub static GRAPHICAL_EVENT_ATTRS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "onactivate",
        "onclick",
        "onfocusin",
        "onfocusout",
        "onload",
        "onmousedown",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
    ])
});

/// Properties that can contain URL references in SVG
pub static REFERENCES_PROPS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "clip-path",
        "color-profile",
        "fill",
        "filter",
        "marker-end",
        "marker-mid",
        "marker-start",
        "mask",
        "stroke",
        "style",
    ])
});

/// Editor-specific namespaces in SVG
pub static EDITOR_NAMESPACES: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "http://creativecommons.org/ns#",
        "http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd",
        "http://krita.org/namespaces/svg/krita",
        "http://ns.adobe.com/AdobeIllustrator/10.0/",
        "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/",
        "http://ns.adobe.com/Extensibility/1.0/",
        "http://ns.adobe.com/Flows/1.0/",
        "http://ns.adobe.com/GenericCustomNamespace/1.0/",
        "http://ns.adobe.com/Graphs/1.0/",
        "http://ns.adobe.com/ImageReplacement/1.0/",
        "http://ns.adobe.com/SaveForWeb/1.0/",
        "http://ns.adobe.com/Variables/1.0/",
        "http://ns.adobe.com/XPath/1.0/",
        "http://purl.org/dc/elements/1.1/",
        "http://schemas.microsoft.com/visio/2003/SVGExtensions/",
        "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd",
        "http://taptrix.com/vectorillustrator/svg_extensions",
        "http://www.bohemiancoding.com/sketch/ns",
        "http://www.figma.com/figma/ns",
        "http://www.inkscape.org/namespaces/inkscape",
        "http://www.serif.com/",
        "http://www.vector.evaxdesign.sk",
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        "https://boxy-svg.com",
    ])
});

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs
# Language: rust

mod tests;

struct Config {
}

struct Js2SvgOptions {
}

struct ParserOptions {
}

struct PluginsVisitor {
}


Relative File Path: svgn/src/config.rs.bak

```
// this_file: svgn/src/config.rs

//! Configuration handling for SVGN
//!
//! This module provides structures and functions for handling configuration
//! compatible with SVGO's configuration format.

use crate::plugin::PluginConfig;
use serde::{Deserialize, Deserializer, Serialize};
use std::path::Path;
use thiserror::Error;

/// Configuration error types
#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
    #[error("JSON parsing error: {0}")]
    JsonError(#[from] serde_json::Error),
    #[error("TOML parsing error: {0}")]
    TomlError(#[from] toml::de::Error),
    #[error("TOML serialization error: {0}")]
    TomlSerError(String),
    #[error("Invalid configuration: {0}")]
    InvalidConfig(String),
}

/// Configuration result type
pub type ConfigResult<T> = Result<T, ConfigError>;

/// Main configuration structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    /// Path to the file being processed (for context)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    
    /// Plugin configurations
    #[serde(default, deserialize_with = "deserialize_plugins")]
    pub plugins: Vec<PluginConfig>,
    
    /// Multi-pass optimization
    #[serde(default)]
    pub multipass: bool,
    
    /// Output formatting options
    #[serde(default)]
    pub js2svg: Js2SvgOptions,
    
    /// Data URI output format
    #[serde(skip_serializing_if = "Option::is_none")]
    pub datauri: Option<DataUriFormat>,
    
    /// Parser options
    #[serde(default)]
    pub parser: ParserOptions,
}

/// Output formatting options (equivalent to SVGO's js2svg)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Js2SvgOptions {
    /// Pretty-print the output
    #[serde(default)]
    pub pretty: bool,
    
    /// Indentation for pretty-printing (number of spaces)
    #[serde(default = "default_indent")]
    pub indent: usize,
    
    /// Use self-closing tags for empty elements
    #[serde(default = "default_true")]
    pub self_closing: bool,
    
    /// Quote attributes (always, never, auto)
    #[serde(default = "default_quote_attrs")]
    pub quote_attrs: QuoteAttrsStyle,
}

/// Data URI output formats
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum DataUriFormat {
    /// Base64 encoded
    Base64,
    /// URL encoded
    Enc,
    /// Unencoded
    Unenc,
}

/// Attribute quoting styles
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum QuoteAttrsStyle {
    /// Always quote attributes
    Always,
    /// Never quote attributes (when possible)
    Never,
    /// Automatically decide based on content
    Auto,
}

/// Parser configuration options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParserOptions {
    /// Preserve whitespace in text content
    #[serde(default)]
    pub preserve_whitespace: bool,
    
    /// Preserve comments
    #[serde(default)]
    pub preserve_comments: bool,
}

// Default value functions for serde
fn default_indent() -> usize { 2 }
fn default_true() -> bool { true }
fn default_quote_attrs() -> QuoteAttrsStyle { QuoteAttrsStyle::Auto }

impl Default for Config {
    fn default() -> Self {
        Self {
            path: None,
            plugins: Vec::new(),
            multipass: false,
            js2svg: Js2SvgOptions::default(),
            datauri: None,
            parser: ParserOptions::default(),
        }
    }
}

impl Default for Js2SvgOptions {
    fn default() -> Self {
        Self {
            pretty: false,
            indent: 2,
            self_closing: true,
            quote_attrs: QuoteAttrsStyle::Auto,
        }
    }
}

impl Default for ParserOptions {
    fn default() -> Self {
        Self {
            preserve_whitespace: false,
            preserve_comments: true, // Must be true for removeComments plugin to work
        }
    }
}

impl Config {
    /// Create a new empty configuration
    pub fn new() -> Self {
        Self::default()
    }

    /// Load configuration from a file
    pub fn from_file<P: AsRef<Path>>(path: P) -> ConfigResult<Self> {
        let path = path.as_ref();
        let content = std::fs::read_to_string(path)?;
        
        match path.extension().and_then(|s| s.to_str()) {
            Some("json") => Self::from_json(&content),
            Some("toml") => Self::from_toml(&content),
            Some("js") | Some("cjs") | Some("mjs") => {
                // For JavaScript config files, we would need to execute them
                // For now, return an error suggesting JSON or TOML
                Err(ConfigError::InvalidConfig(
                    "JavaScript config files not yet supported. Please use JSON or TOML format.".to_string()
                ))
            }
            _ => {
                // Try JSON first, then TOML
                Self::from_json(&content).or_else(|_| Self::from_toml(&content))
            }
        }
    }

    /// Load configuration from JSON string
    pub fn from_json(json: &str) -> ConfigResult<Self> {
        Ok(serde_json::from_str(json)?)
    }

    /// Load configuration from TOML string
    pub fn from_toml(toml: &str) -> ConfigResult<Self> {
        Ok(toml::from_str(toml)?)
    }

    /// Convert to JSON string
    pub fn to_json(&self) -> ConfigResult<String> {
        Ok(serde_json::to_string_pretty(self)?)
    }

    /// Convert to TOML string
    pub fn to_toml(&self) -> ConfigResult<String> {
        toml::to_string(self).map_err(|e| ConfigError::TomlSerError(e.to_string()))
    }

    /// Add a plugin configuration
    pub fn add_plugin(&mut self, plugin: PluginConfig) {
        self.plugins.push(plugin);
    }

    /// Remove a plugin by name
    pub fn remove_plugin(&mut self, name: &str) {
        self.plugins.retain(|p| p.name != name);
    }

    /// Get a plugin configuration by name
    pub fn get_plugin(&self, name: &str) -> Option<&PluginConfig> {
        self.plugins.iter().find(|p| p.name == name)
    }

    /// Get a mutable plugin configuration by name
    pub fn get_plugin_mut(&mut self, name: &str) -> Option<&mut PluginConfig> {
        self.plugins.iter_mut().find(|p| p.name == name)
    }

    /// Enable or disable a plugin
    pub fn set_plugin_enabled(&mut self, name: &str, enabled: bool) {
        if let Some(plugin) = self.get_plugin_mut(name) {
            plugin.enabled = enabled;
        }
    }

    /// Create a config with the default preset
    pub fn with_default_preset() -> Self {
        let mut config = Self::new();
        
        // Add default plugins (excluding unimplemented complex plugins for now)
        let default_plugins = vec![
            "removeComments",
            "removeMetadata", 
            "removeTitle",
            "removeDesc",
            "removeDoctype",
            "removeXMLProcInst",
            "removeEditorsNSData",
            "cleanupAttrs",
            "removeEmptyAttrs",
            "removeUnknownsAndDefaults",
            "removeUnusedNS",
            "removeUselessDefs",
            "cleanupIds",
            "minifyStyles",
            "convertStyleToAttrs",
            "convertColors",
            // TODO: Implement complex plugins:
            // "convertPathData",    // Requires lyon integration
            // "convertTransform",   // Requires matrix math
            // "mergePaths",         // Requires path analysis
            // "moveElemsAttrsToGroup", // Requires DOM analysis
            // "moveGroupAttrsToElems", // Requires DOM analysis  
            // "inlineStyles",       // Requires CSS parsing
            "removeEmptyText",
            "removeEmptyContainers",
            "collapseGroups",
            "sortAttrs",
        ];

        for plugin_name in default_plugins {
            config.add_plugin(PluginConfig::new(plugin_name.to_string()));
        }

        config
    }
}

/// Load configuration from common file names in the given directory
pub fn load_config_from_directory<P: AsRef<Path>>(dir: P) -> ConfigResult<Option<Config>> {
    let dir = dir.as_ref();
    
    // Common config file names (in order of preference)
    let config_names = [
        "svgn.config.toml",
        "svgn.config.json", 
        "svgo.config.json",
        "svgo.config.js",
        "svgo.config.cjs",
        "svgo.config.mjs",
    ];

    for name in &config_names {
        let path = dir.join(name);
        if path.exists() {
            return Ok(Some(Config::from_file(path)?));
        }
    }

    Ok(None)
}

/// Custom deserializer for plugins that can handle both string and object formats
fn deserialize_plugins<'de, D>(deserializer: D) -> Result<Vec<PluginConfig>, D::Error>
where
    D: Deserializer<'de>,
{
    use serde::de::{self, SeqAccess, Visitor};
    use serde_json::Value;
    
    struct PluginsVisitor;
    
    impl<'de> Visitor<'de> for PluginsVisitor {
        type Value = Vec<PluginConfig>;
        
        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            formatter.write_str("an array of plugin names or plugin config objects")
        }
        
        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
        where
            A: SeqAccess<'de>,
        {
            let mut plugins = Vec::new();
            
            while let Some(value) = seq.next_element::<Value>()? {
                let plugin = match value {
                    Value::String(name) => PluginConfig::new(name),
                    Value::Object(_) => {
                        serde_json::from_value(value)
                            .map_err(de::Error::custom)?
                    }
                    _ => return Err(de::Error::custom("Invalid plugin format")),
                };
                plugins.push(plugin);
            }
            
            Ok(plugins)
        }
    }
    
    deserializer.deserialize_seq(PluginsVisitor)
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_default_config() {
        let config = Config::new();
        assert!(config.plugins.is_empty());
        assert!(!config.multipass);
        assert!(!config.js2svg.pretty);
        assert_eq!(config.js2svg.indent, 2);
    }

    #[test]
    fn test_config_serialization() {
        let mut config = Config::new();
        config.multipass = true;
        config.js2svg.pretty = true;
        config.add_plugin(PluginConfig::new("removeComments".to_string()));

        let json = config.to_json().unwrap();
        let deserialized: Config = Config::from_json(&json).unwrap();

        assert_eq!(config.multipass, deserialized.multipass);
        assert_eq!(config.js2svg.pretty, deserialized.js2svg.pretty);
        assert_eq!(config.plugins.len(), deserialized.plugins.len());
    }

    #[test]
    fn test_plugin_management() {
        let mut config = Config::new();
        
        config.add_plugin(PluginConfig::new("test".to_string()));
        assert_eq!(config.plugins.len(), 1);
        assert!(config.get_plugin("test").is_some());
        
        config.set_plugin_enabled("test", false);
        assert!(!config.get_plugin("test").unwrap().enabled);
        
        config.remove_plugin("test");
        assert_eq!(config.plugins.len(), 0);
    }

    #[test]
    fn test_default_preset() {
        let config = Config::with_default_preset();
        assert!(!config.plugins.is_empty());
        assert!(config.get_plugin("removeComments").is_some());
        assert!(config.get_plugin("removeMetadata").is_some());
    }

    #[test]
    fn test_json_parsing() {
        let json = json!({
            "multipass": true,
            "plugins": [
                "removeComments",
                {
                    "name": "sortAttrs",
                    "params": {
                        "xmlnsOrder": "alphabetical"
                    }
                }
            ],
            "js2svg": {
                "pretty": true,
                "indent": 4
            }
        });

        let config: Config = serde_json::from_value(json).unwrap();
        assert!(config.multipass);
        assert_eq!(config.plugins.len(), 2);
        assert!(config.js2svg.pretty);
        assert_eq!(config.js2svg.indent, 4);
    }
}
```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/lib.rs
# Language: rust

mod ast;

mod collections;

mod config;

mod optimizer;

mod parser;

mod plugin;

mod plugins;

mod stringifier;


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs
# Language: rust

mod tests;

struct OptimizeOptions {
}

struct OptimizationResult {
}

struct OptimizationInfo {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs
# Language: rust

mod tests;

struct Parser {
}


Relative File Path: svgn/src/plugin.rs

```rust
// this_file: svgn/src/plugin.rs

//! Plugin system for SVG optimization
//!
//! This module defines the plugin trait and infrastructure for applying
//! optimization transformations to SVG documents.

use crate::ast::Document;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::error::Error;
use std::fmt;

/// Result type for plugin operations
pub type PluginResult<T> = Result<T, PluginError>;

/// Error type for plugin operations
#[derive(Debug)]
pub enum PluginError {
    /// Invalid configuration parameter
    InvalidConfig(String),
    /// Processing error
    ProcessingError(String),
    /// I/O error
    IoError(std::io::Error),
}

impl fmt::Display for PluginError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PluginError::InvalidConfig(msg) => write!(f, "Invalid configuration: {}", msg),
            PluginError::ProcessingError(msg) => write!(f, "Processing error: {}", msg),
            PluginError::IoError(err) => write!(f, "I/O error: {}", err),
        }
    }
}

impl Error for PluginError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            PluginError::IoError(err) => Some(err),
            _ => None,
        }
    }
}

impl From<std::io::Error> for PluginError {
    fn from(err: std::io::Error) -> Self {
        PluginError::IoError(err)
    }
}

/// Information passed to plugins during optimization
#[derive(Default)]
pub struct PluginInfo {
    /// Path to the current SVG file (if available)
    pub path: Option<String>,
    /// Current multipass count (0-indexed)
    pub multipass_count: usize,
}

/// Plugin trait that all optimization plugins must implement
pub trait Plugin: Send + Sync {
    /// Plugin name (must be unique)
    fn name(&self) -> &'static str;

    /// Plugin description
    fn description(&self) -> &'static str;

    /// Apply the plugin transformation to the document
    fn apply(
        &mut self,
        document: &mut Document,
        plugin_info: &PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()>;

    /// Check if the plugin should be applied based on the document
    /// Default implementation always returns true
    fn should_apply(
        &self,
        _document: &Document,
        _plugin_info: &PluginInfo,
        _params: Option<&Value>,
    ) -> bool {
        true
    }

    /// Validate plugin parameters
    /// Default implementation accepts any parameters
    fn validate_params(&self, _params: Option<&Value>) -> PluginResult<()> {
        Ok(())
    }
}

/// Plugin configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginConfig {
    /// Plugin name
    pub name: String,
    /// Plugin parameters
    #[serde(skip_serializing_if = "Option::is_none")]
    pub params: Option<Value>,
    /// Whether the plugin is enabled
    #[serde(default = "default_true")]
    pub enabled: bool,
}

fn default_true() -> bool {
    true
}

impl PluginConfig {
    /// Create a new plugin configuration
    pub fn new(name: String) -> Self {
        Self {
            name,
            params: None,
            enabled: true,
        }
    }

    /// Create a new plugin configuration with parameters
    pub fn with_params(name: String, params: Value) -> Self {
        Self {
            name,
            params: Some(params),
            enabled: true,
        }
    }

    /// Disable this plugin
    pub fn disabled(mut self) -> Self {
        self.enabled = false;
        self
    }
}

/// Plugin registry for managing available plugins
pub struct PluginRegistry {
    plugins: Vec<Box<dyn Plugin>>,
}

impl PluginRegistry {
    /// Create a new empty plugin registry
    pub fn new() -> Self {
        Self {
            plugins: Vec::new(),
        }
    }

    /// Register a plugin
    pub fn register<P: Plugin + 'static>(&mut self, plugin: P) {
        self.plugins.push(Box::new(plugin));
    }

    /// Get a plugin by name
    pub fn get(&self, name: &str) -> Option<&dyn Plugin> {
        self.plugins
            .iter()
            .find(|p| p.name() == name)
            .map(|p| p.as_ref())
    }

    /// Get a plugin by name (mutable)
    pub fn get_mut(&mut self, name: &str) -> Option<&mut dyn Plugin> {
        for plugin in &mut self.plugins {
            if plugin.name() == name {
                return Some(plugin.as_mut());
            }
        }
        None
    }

    /// Get all registered plugin names
    pub fn plugin_names(&self) -> Vec<&'static str> {
        self.plugins.iter().map(|p| p.name()).collect()
    }

    /// Apply a list of plugin configurations to a document
    pub fn apply_plugins(
        &mut self,
        document: &mut Document,
        configs: &[PluginConfig],
        plugin_info: &PluginInfo,
    ) -> PluginResult<()> {
        for config in configs {
            if !config.enabled {
                continue;
            }

            let plugin = self.get_mut(&config.name).ok_or_else(|| {
                PluginError::InvalidConfig(format!("Unknown plugin: {}", config.name))
            })?;

            // Validate parameters
            plugin.validate_params(config.params.as_ref())?;

            // Check if plugin should be applied
            if !plugin.should_apply(document, plugin_info, config.params.as_ref()) {
                continue;
            }

            // Apply the plugin
            plugin.apply(document, plugin_info, config.params.as_ref())?;
        }

        Ok(())
    }
}

impl Default for PluginRegistry {
    fn default() -> Self {
        Self::new()
    }
}

/// Create the default plugin registry with all built-in plugins
pub fn create_default_registry() -> PluginRegistry {
    let mut registry = PluginRegistry::new();

    // Register built-in plugins
    registry.register(crate::plugins::CleanupAttrsPlugin);
    registry.register(crate::plugins::CleanupEnableBackgroundPlugin);
    registry.register(crate::plugins::CleanupIdsPlugin);
    registry.register(crate::plugins::CleanupListOfValuesPlugin);
    registry.register(crate::plugins::CleanupNumericValuesPlugin);
    registry.register(crate::plugins::RemoveCommentsPlugin);
    registry.register(crate::plugins::RemoveDescPlugin);
    registry.register(crate::plugins::RemoveDoctypePlugin);
    registry.register(crate::plugins::RemoveEmptyAttrsPlugin);
    registry.register(crate::plugins::RemoveEmptyContainersPlugin);
    registry.register(crate::plugins::RemoveEmptyTextPlugin);
    registry.register(crate::plugins::RemoveAttrsPlugin);
    registry.register(crate::plugins::RemoveMetadataPlugin);
    registry.register(crate::plugins::RemoveTitlePlugin);
    registry.register(crate::plugins::RemoveUnknownsAndDefaultsPlugin);
    registry.register(crate::plugins::RemoveXMLProcInstPlugin);
    registry.register(crate::plugins::SortAttrsPlugin);
    registry.register(crate::plugins::RemoveStyleElement);
    registry.register(crate::plugins::MergeStylesPlugin);
    registry.register(crate::plugins::ConvertStyleToAttrsPlugin);
    registry.register(crate::plugins::ConvertColorsPlugin);
    registry.register(crate::plugins::AddAttributesToSVGElementPlugin);
    registry.register(crate::plugins::AddClassesToSVGElementPlugin);
    registry.register(crate::plugins::RemoveAttributesBySelectorPlugin);
    registry.register(crate::plugins::RemoveDeprecatedAttrsPlugin);
    registry.register(crate::plugins::ConvertEllipseToCirclePlugin);
    registry.register(crate::plugins::CollapseGroupsPlugin);
    registry.register(crate::plugins::ConvertOneStopGradientsPlugin);
    registry.register(crate::plugins::PrefixIdsPlugin);
    registry.register(crate::plugins::RemoveEditorsNSDataPlugin);
    registry.register(crate::plugins::RemoveElementsByAttrPlugin);
    registry.register(crate::plugins::RemoveDimensionsPlugin);
    registry.register(crate::plugins::RemoveScriptsPlugin);
    registry.register(crate::plugins::RemoveUselessDefsPlugin);
    registry.register(crate::plugins::RemoveUnusedNSPlugin);
    registry.register(crate::plugins::RemoveViewBoxPlugin);
    registry.register(crate::plugins::RemoveXlinkPlugin);
    registry.register(crate::plugins::RemoveXMLNSPlugin);
    registry.register(crate::plugins::RemoveRasterImagesPlugin);
    registry.register(crate::plugins::SortDefsChildrenPlugin);
    registry.register(crate::plugins::RemoveHiddenElemsPlugin);
    registry.register(crate::plugins::RemoveNonInheritableGroupAttrsPlugin);
    registry.register(crate::plugins::RemoveOffCanvasPathsPlugin);
    registry.register(crate::plugins::ConvertShapeToPathPlugin);
    registry.register(crate::plugins::ConvertTransformPlugin);
    registry.register(crate::plugins::InlineStylesPlugin);
    registry.register(crate::plugins::MinifyStylesPlugin);
    registry.register(crate::plugins::ConvertPathDataPlugin);
    registry.register(crate::plugins::RemoveUselessTransformsPlugin);
    registry.register(crate::plugins::RemoveUselessStrokeAndFillPlugin);

    registry
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    // Test plugin for unit tests
    struct TestPlugin {
        name: &'static str,
    }

    impl Plugin for TestPlugin {
        fn name(&self) -> &'static str {
            self.name
        }

        fn description(&self) -> &'static str {
            "Test plugin"
        }

        fn apply(
            &mut self,
            _document: &mut Document,
            _plugin_info: &PluginInfo,
            _params: Option<&Value>,
        ) -> PluginResult<()> {
            Ok(())
        }
    }

    #[test]
    fn test_plugin_registry() {
        let mut registry = PluginRegistry::new();
        registry.register(TestPlugin { name: "test" });

        assert!(registry.get("test").is_some());
        assert!(registry.get("nonexistent").is_none());
        assert_eq!(registry.plugin_names(), vec!["test"]);
    }

    #[test]
    fn test_plugin_config() {
        let config = PluginConfig::new("test".to_string());
        assert_eq!(config.name, "test");
        assert!(config.enabled);
        assert!(config.params.is_none());

        let config_with_params =
            PluginConfig::with_params("test".to_string(), json!({"option": "value"}));
        assert!(config_with_params.params.is_some());

        let disabled_config = PluginConfig::new("test".to_string()).disabled();
        assert!(!disabled_config.enabled);
    }

    #[test]
    fn test_apply_plugins() {
        let mut registry = PluginRegistry::new();
        registry.register(TestPlugin { name: "test" });

        let mut document = Document::new();
        let configs = vec![PluginConfig::new("test".to_string())];

        let plugin_info = PluginInfo {
            path: None,
            multipass_count: 0,
        };
        let result = registry.apply_plugins(&mut document, &configs, &plugin_info);
        assert!(result.is_ok());
    }

    #[test]
    fn test_apply_unknown_plugin() {
        let mut registry = PluginRegistry::new();
        let mut document = Document::new();
        let configs = vec![PluginConfig::new("unknown".to_string())];

        let plugin_info = PluginInfo {
            path: None,
            multipass_count: 0,
        };
        let result = registry.apply_plugins(&mut document, &configs, &plugin_info);
        assert!(result.is_err());
    }
}

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs
# Language: rust

mod tests;

struct AddAttributesToSVGElementPlugin {
}

struct AddAttributesConfig {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs
# Language: rust

mod tests;

struct AddClassesToSVGElementPlugin {
}

struct AddClassesConfig {
}


Relative File Path: svgn/src/plugins/cleanup_attrs.rs

```rust
// this_file: svgn/src/plugins/cleanup_attrs.rs

//! Cleanup attributes plugin
//!
//! This plugin cleans up attributes from newlines, trailing and repeating spaces.
//! Ported from ref/svgo/plugins/cleanupAttrs.js

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginResult};
use regex::Regex;
use serde_json::Value;
use std::sync::LazyLock;

/// Plugin that cleans up attribute values from newlines, trailing and repeating spaces
pub struct CleanupAttrsPlugin;

// Compile regex patterns once at startup
static REG_NEWLINES_NEED_SPACE: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r"(\S)\r?\n(\S)").unwrap());
static REG_NEWLINES: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"\r?\n").unwrap());
static REG_SPACES: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"\s{2,}").unwrap());

impl Plugin for CleanupAttrsPlugin {
    fn name(&self) -> &'static str {
        "cleanupAttrs"
    }

    fn description(&self) -> &'static str {
        "Cleanup attributes from newlines, trailing and repeating spaces"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &crate::plugin::PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()> {
        // Parse parameters with defaults
        let newlines = params
            .and_then(|v| v.get("newlines"))
            .and_then(|v| v.as_bool())
            .unwrap_or(true);

        let trim = params
            .and_then(|v| v.get("trim"))
            .and_then(|v| v.as_bool())
            .unwrap_or(true);

        let spaces = params
            .and_then(|v| v.get("spaces"))
            .and_then(|v| v.as_bool())
            .unwrap_or(true);

        // Process the root element and all its descendants
        cleanup_element_attrs(&mut document.root, newlines, trim, spaces);

        Ok(())
    }
}

/// Recursively clean up attributes for an element and all its descendants
fn cleanup_element_attrs(element: &mut Element, newlines: bool, trim: bool, spaces: bool) {
    // Clean up attributes of the current element
    for (_name, value) in element.attributes.iter_mut() {
        if newlines {
            // Replace newlines that need a space (between non-whitespace chars)
            *value = REG_NEWLINES_NEED_SPACE
                .replace_all(value, "$1 $2")
                .to_string();
            // Remove simple newlines
            *value = REG_NEWLINES.replace_all(value, "").to_string();
        }

        if trim {
            *value = value.trim().to_string();
        }

        if spaces {
            // Replace multiple spaces with a single space
            *value = REG_SPACES.replace_all(value, " ").to_string();
        }
    }

    // Recursively process child elements
    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            cleanup_element_attrs(child_element, newlines, trim, spaces);
        }
    }
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::parser::Parser;
    use serde_json::json;

    #[test]
    fn test_cleanup_newlines() {
        let svg = r#"<svg viewBox="0
10
20 30">
            <rect x="1
2" y="3
4"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupAttrsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Check that newlines are replaced with spaces where needed
        assert_eq!(
            document.root.attr("viewBox"),
            Some(&"0 10 20 30".to_string())
        );

        let rect = document.root.child_elements().next().unwrap();
        assert_eq!(rect.attr("x"), Some(&"1 2".to_string()));
        assert_eq!(rect.attr("y"), Some(&"3 4".to_string()));
    }

    #[test]
    fn test_cleanup_spaces() {
        let svg = r#"<svg class="  foo    bar  ">
            <rect fill="  red  "/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupAttrsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Check that multiple spaces are reduced to single spaces and trimmed
        assert_eq!(document.root.attr("class"), Some(&"foo bar".to_string()));

        let rect = document.root.child_elements().next().unwrap();
        assert_eq!(rect.attr("fill"), Some(&"red".to_string()));
    }

    #[test]
    fn test_with_params() {
        let svg = r#"<svg class="  foo    bar  ">
            <rect x="1
2"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupAttrsPlugin;
        let params = json!({
            "newlines": false,
            "spaces": false,
            "trim": true
        });

        plugin
            .apply(
                &mut document,
                &crate::plugin::PluginInfo::default(),
                Some(&params),
            )
            .unwrap();

        // Only trim should be applied
        assert_eq!(document.root.attr("class"), Some(&"foo    bar".to_string()));

        let rect = document.root.child_elements().next().unwrap();
        // Newline should remain but be trimmed
        assert_eq!(rect.attr("x"), Some(&"1\n2".to_string()));
    }
}

```

Relative File Path: svgn/src/plugins/cleanup_enable_background.rs

```rust
// this_file: svgn/src/plugins/cleanup_enable_background.rs

//! Cleanup enable-background plugin
//!
//! This plugin removes or cleans up the enable-background attribute when possible.
//! The enable-background attribute is used with filters, but when it matches the
//! SVG dimensions, it can often be simplified or removed.
//! Ported from ref/svgo/plugins/cleanupEnableBackground.js

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginResult};
use regex::Regex;
use serde_json::Value;
use std::sync::LazyLock;

/// Plugin that cleans up or removes the enable-background attribute
pub struct CleanupEnableBackgroundPlugin;

// Regex to match the enable-background format: "new 0 0 <width> <height>"
static REG_ENABLE_BACKGROUND: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(r"^new\s0\s0\s([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)\s([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)$")
        .unwrap()
});

impl Plugin for CleanupEnableBackgroundPlugin {
    fn name(&self) -> &'static str {
        "cleanupEnableBackground"
    }

    fn description(&self) -> &'static str {
        "Remove or cleanup enable-background attribute when possible"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &crate::plugin::PluginInfo,
        _params: Option<&Value>,
    ) -> PluginResult<()> {
        // First check if there are any filter elements in the document
        let has_filter = has_filter_element(&document.root);

        // Process the document
        cleanup_enable_background(&mut document.root, has_filter);

        Ok(())
    }
}

/// Check if the document contains any filter elements
fn has_filter_element(element: &Element) -> bool {
    if element.name == "filter" {
        return true;
    }

    for child in &element.children {
        if let Node::Element(child_element) = child {
            if has_filter_element(child_element) {
                return true;
            }
        }
    }

    false
}

/// Recursively process elements to clean up enable-background attributes
fn cleanup_enable_background(element: &mut Element, has_filter: bool) {
    // If there are no filters in the document, we can remove all enable-background attributes
    if !has_filter {
        element.remove_attr("enable-background");
        // TODO: Also handle style attribute with enable-background property
    } else {
        // Check if this is an element that can have enable-background
        let is_valid_element = matches!(element.name.as_str(), "svg" | "mask" | "pattern");
        let has_dimensions = element.has_attr("width") && element.has_attr("height");

        if is_valid_element && has_dimensions {
            if let Some(enable_bg) = element.attr("enable-background") {
                if let (Some(width), Some(height)) = (element.attr("width"), element.attr("height"))
                {
                    // Clean up the value
                    if let Some(cleaned) = cleanup_value(enable_bg, &element.name, width, height) {
                        element.set_attr("enable-background".to_string(), cleaned);
                    } else {
                        element.remove_attr("enable-background");
                    }
                }
            }
        }
    }

    // Process child elements
    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            cleanup_enable_background(child_element, has_filter);
        }
    }
}

/// Clean up the enable-background value
/// Returns None if the attribute should be removed, Some(value) if it should be kept
fn cleanup_value(value: &str, node_name: &str, width: &str, height: &str) -> Option<String> {
    if let Some(captures) = REG_ENABLE_BACKGROUND.captures(value) {
        if let (Some(bg_width), Some(bg_height)) = (captures.get(1), captures.get(2)) {
            // If the enable-background dimensions match the element dimensions
            if bg_width.as_str() == width && bg_height.as_str() == height {
                // For svg elements, we can remove it entirely
                if node_name == "svg" {
                    return None;
                } else {
                    // For mask and pattern, simplify to just "new"
                    return Some("new".to_string());
                }
            }
        }
    }

    // Keep the original value if it doesn't match our pattern or dimensions
    Some(value.to_string())
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::parser::Parser;

    #[test]
    fn test_remove_without_filter() {
        let svg = r#"<svg width="100" height="50" enable-background="new 0 0 100 50">
            <rect x="10" y="10" width="80" height="30"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupEnableBackgroundPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Should remove enable-background when no filter is present
        assert!(!document.root.has_attr("enable-background"));
    }

    #[test]
    fn test_cleanup_with_filter() {
        let svg = r#"<svg width="100" height="50" enable-background="new 0 0 100 50">
            <filter id="blur">
                <feGaussianBlur stdDeviation="2"/>
            </filter>
            <rect x="10" y="10" width="80" height="30" filter="url(#blur)"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupEnableBackgroundPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Should remove enable-background even with filter when dimensions match
        assert!(!document.root.has_attr("enable-background"));
    }

    #[test]
    fn test_keep_non_matching() {
        let svg = r#"<svg width="100" height="50" enable-background="new 0 0 200 100">
            <filter id="blur">
                <feGaussianBlur stdDeviation="2"/>
            </filter>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupEnableBackgroundPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Should keep enable-background when dimensions don't match
        assert_eq!(
            document.root.attr("enable-background"),
            Some(&"new 0 0 200 100".to_string())
        );
    }

    #[test]
    fn test_simplify_mask_pattern() {
        let svg = r#"<svg>
            <filter id="f"/>
            <mask width="100" height="50" enable-background="new 0 0 100 50"/>
            <pattern width="200" height="100" enable-background="new 0 0 200 100"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupEnableBackgroundPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Check mask - should be simplified to "new"
        let mask = document
            .root
            .child_elements()
            .find(|e| e.name == "mask")
            .unwrap();
        assert_eq!(mask.attr("enable-background"), Some(&"new".to_string()));

        // Check pattern - should be simplified to "new"
        let pattern = document
            .root
            .child_elements()
            .find(|e| e.name == "pattern")
            .unwrap();
        assert_eq!(pattern.attr("enable-background"), Some(&"new".to_string()));
    }
}

```

Relative File Path: svgn/src/plugins/cleanup_ids.rs

```rust
// this_file: svgn/src/plugins/cleanup_ids.rs

//! Cleanup IDs plugin
//!
//! This plugin removes unused IDs and minifies used IDs to save space.
//! It's careful not to break references and respects various preservation options.
//! Ported from ref/svgo/plugins/cleanupIds.js

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginResult};
use regex::Regex;
use serde_json::Value;
use std::collections::{HashMap, HashSet};
use std::sync::LazyLock;

/// Plugin that removes unused IDs and minifies used IDs
pub struct CleanupIdsPlugin;

// Regex patterns for finding ID references
static REG_REFERENCES_URL: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r#"\burl\(#([^)]+)\)"#).unwrap());
static REG_REFERENCES_URL_QUOTED: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r#"\burl\(["']#([^"']+)["']\)"#).unwrap());
static REG_REFERENCES_HREF: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"^#(.+?)$").unwrap());
static REG_REFERENCES_BEGIN: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r"(\w+)\.[a-zA-Z]").unwrap());

// Characters used for generating minified IDs
const GENERATE_ID_CHARS: &[char] = &[
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
    't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
    'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
];

// Properties that can contain URL references
const REFERENCES_PROPS: &[&str] = &[
    "clip-path",
    "color-profile",
    "fill",
    "filter",
    "marker-end",
    "marker-mid",
    "marker-start",
    "mask",
    "stroke",
    "style",
];

impl Plugin for CleanupIdsPlugin {
    fn name(&self) -> &'static str {
        "cleanupIds"
    }

    fn description(&self) -> &'static str {
        "Remove unused IDs and minify used IDs"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &crate::plugin::PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()> {
        // Parse parameters
        let remove = params
            .and_then(|v| v.get("remove"))
            .and_then(|v| v.as_bool())
            .unwrap_or(true);

        let minify = params
            .and_then(|v| v.get("minify"))
            .and_then(|v| v.as_bool())
            .unwrap_or(true);

        let preserve: HashSet<String> = params
            .and_then(|v| v.get("preserve"))
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|v| v.as_str())
                    .map(|s| s.to_string())
                    .collect()
            })
            .unwrap_or_default();

        let preserve_prefixes: Vec<String> = params
            .and_then(|v| v.get("preservePrefixes"))
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|v| v.as_str())
                    .map(|s| s.to_string())
                    .collect()
            })
            .unwrap_or_default();

        let force = params
            .and_then(|v| v.get("force"))
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        // Check if we should deoptimize (skip processing)
        if !force && (has_scripts(&document.root) || has_styles(&document.root)) {
            return Ok(());
        }

        // Collect all IDs and their references
        let mut node_by_id: HashMap<String, *mut Element> = HashMap::new();
        let mut references_by_id: HashMap<String, Vec<(String, String)>> = HashMap::new();

        // First pass: collect IDs and references
        collect_ids_and_refs(&mut document.root, &mut node_by_id, &mut references_by_id);

        // Helper to check if an ID should be preserved
        let is_id_preserved = |id: &str| -> bool {
            preserve.contains(id)
                || preserve_prefixes
                    .iter()
                    .any(|prefix| id.starts_with(prefix))
        };

        // Second pass: process IDs
        let mut current_id = None;
        let mut id_mappings: HashMap<String, String> = HashMap::new();

        // Process referenced IDs first
        for id in references_by_id.keys() {
            if let Some(&node_ptr) = node_by_id.get(id) {
                unsafe {
                    let node = &mut *node_ptr;
                    if minify && !is_id_preserved(id) {
                        // Generate new minified ID
                        let mut new_id;
                        loop {
                            current_id = generate_id(current_id);
                            new_id = get_id_string(current_id.as_ref().unwrap());

                            // Make sure the new ID is unique and not preserved
                            if !is_id_preserved(&new_id)
                                && !node_by_id.contains_key(&new_id)
                                && !id_mappings.values().any(|v| v == &new_id)
                            {
                                break;
                            }
                        }

                        // Update the ID
                        node.set_attr("id".to_string(), new_id.clone());
                        id_mappings.insert(id.clone(), new_id);
                    }
                }

                // Mark this ID as processed (referenced)
                node_by_id.remove(id);
            }
        }

        // Update all references with new IDs
        if !id_mappings.is_empty() {
            update_references(&mut document.root, &id_mappings);
        }

        // Remove unreferenced IDs if requested
        if remove {
            for (id, node_ptr) in node_by_id {
                if !is_id_preserved(&id) {
                    unsafe {
                        let node = &mut *node_ptr;
                        node.remove_attr("id");
                    }
                }
            }
        }

        Ok(())
    }
}

/// Check if the document contains scripts
fn has_scripts(element: &Element) -> bool {
    if element.name == "script" && !element.is_empty() {
        return true;
    }

    // Check for javascript: links
    if element.name == "a" {
        if let Some(href) = element.attr("href") {
            if href.trim_start().starts_with("javascript:") {
                return true;
            }
        }
    }

    // Check for event attributes (onclick, onload, etc.)
    for (attr_name, _) in &element.attributes {
        if attr_name.starts_with("on") {
            return true;
        }
    }

    // Check children
    for child in &element.children {
        if let Node::Element(child_element) = child {
            if has_scripts(child_element) {
                return true;
            }
        }
    }

    false
}

/// Check if the document contains style elements with content
fn has_styles(element: &Element) -> bool {
    if element.name == "style" && !element.is_empty() {
        return true;
    }

    // Check children
    for child in &element.children {
        if let Node::Element(child_element) = child {
            if has_styles(child_element) {
                return true;
            }
        }
    }

    false
}

/// Collect all IDs and references to them
fn collect_ids_and_refs(
    element: &mut Element,
    node_by_id: &mut HashMap<String, *mut Element>,
    references_by_id: &mut HashMap<String, Vec<(String, String)>>,
) {
    // Check for ID attribute
    if let Some(id) = element.attr("id").cloned() {
        let element_ptr: *mut Element = element;
        // Only keep the first occurrence of each ID
        node_by_id.entry(id).or_insert(element_ptr);
    }

    // Check for references in attributes
    for (attr_name, attr_value) in &element.attributes {
        let ids = find_references(attr_name, attr_value);
        for id in ids {
            references_by_id
                .entry(id)
                .or_default()
                .push((attr_name.clone(), attr_value.clone()));
        }
    }

    // Process children
    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            collect_ids_and_refs(child_element, node_by_id, references_by_id);
        }
    }
}

/// Find ID references in attribute values
fn find_references(attribute: &str, value: &str) -> Vec<String> {
    let mut results = Vec::new();

    // Check for URL references: url(#id) and url('#id')
    if REFERENCES_PROPS.contains(&attribute) {
        // Try unquoted URL references
        for cap in REG_REFERENCES_URL.captures_iter(value) {
            if let Some(id_match) = cap.get(1) {
                results.push(id_match.as_str().to_string());
            }
        }
        // Try quoted URL references
        for cap in REG_REFERENCES_URL_QUOTED.captures_iter(value) {
            if let Some(id_match) = cap.get(1) {
                results.push(id_match.as_str().to_string());
            }
        }
    }

    // Check for href references: #id
    if attribute == "href" || attribute.ends_with(":href") {
        if let Some(cap) = REG_REFERENCES_HREF.captures(value) {
            if let Some(id_match) = cap.get(1) {
                results.push(id_match.as_str().to_string());
            }
        }
    }

    // Check for begin attribute references: elementId.event
    if attribute == "begin" {
        if let Some(cap) = REG_REFERENCES_BEGIN.captures(value) {
            if let Some(id_match) = cap.get(1) {
                results.push(id_match.as_str().to_string());
            }
        }
    }

    results
}

/// Generate the next ID in sequence
fn generate_id(current_id: Option<Vec<usize>>) -> Option<Vec<usize>> {
    let mut id = current_id.unwrap_or_else(|| vec![usize::MAX]); // Start before 'a'
    let max_index = GENERATE_ID_CHARS.len() - 1;

    // Increment the ID
    let last_idx = id.len() - 1;
    if id[last_idx] == usize::MAX {
        id[last_idx] = 0; // First call: go from MAX to 0 ('a')
    } else {
        id[last_idx] += 1;
    }

    // Handle carry-over
    for i in (1..id.len()).rev() {
        if id[i] > max_index {
            id[i] = 0;
            id[i - 1] += 1;
        }
    }

    // Add new position if needed
    if id[0] > max_index {
        id[0] = 0;
        id.insert(0, 0);
    }

    Some(id)
}

/// Convert ID array to string
fn get_id_string(id: &[usize]) -> String {
    id.iter().map(|&i| GENERATE_ID_CHARS[i]).collect()
}

/// Update all references with new IDs
fn update_references(element: &mut Element, id_mappings: &HashMap<String, String>) {
    // Update attributes
    for (attr_name, attr_value) in element.attributes.iter_mut() {
        let mut new_value = attr_value.clone();

        // Update URL references
        if REFERENCES_PROPS.contains(&attr_name.as_str()) {
            for (old_id, new_id) in id_mappings {
                // Handle both encoded and non-encoded IDs
                new_value = new_value
                    .replace(
                        &format!("#{}\"", urlencoding::encode(old_id)),
                        &format!("#{}\"", new_id),
                    )
                    .replace(
                        &format!("#{}'", urlencoding::encode(old_id)),
                        &format!("#{}'", new_id),
                    )
                    .replace(
                        &format!("#{})", urlencoding::encode(old_id)),
                        &format!("#{})", new_id),
                    )
                    .replace(&format!("#{}\"", old_id), &format!("#{}\"", new_id))
                    .replace(&format!("#{}'", old_id), &format!("#{}'", new_id))
                    .replace(&format!("#{})", old_id), &format!("#{})", new_id));
            }
        }

        // Update href references
        if attr_name == "href" || attr_name.ends_with(":href") {
            for (old_id, new_id) in id_mappings {
                if new_value == format!("#{}", old_id) {
                    new_value = format!("#{}", new_id);
                }
            }
        }

        // Update begin attribute references
        if attr_name == "begin" {
            for (old_id, new_id) in id_mappings {
                new_value = new_value.replace(&format!("{}.", old_id), &format!("{}.", new_id));
            }
        }

        *attr_value = new_value;
    }

    // Process children
    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            update_references(child_element, id_mappings);
        }
    }
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::parser::Parser;
    use serde_json::json;

    #[test]
    fn test_remove_unused_ids() {
        let svg = r#"<svg>
            <defs>
                <linearGradient id="unused-gradient">
                    <stop offset="0%" stop-color="red"/>
                </linearGradient>
                <linearGradient id="used-gradient">
                    <stop offset="0%" stop-color="blue"/>
                </linearGradient>
            </defs>
            <rect id="unused-rect" width="100" height="100"/>
            <rect fill="url(#used-gradient)" width="100" height="100"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupIdsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Check that unused IDs are removed
        let defs = document.root.child_elements().next().unwrap();
        let unused_gradient = defs.child_elements().next().unwrap();
        assert!(!unused_gradient.has_attr("id"));

        let unused_rect = document.root.child_elements().nth(1).unwrap();
        assert!(!unused_rect.has_attr("id"));

        // Check that used ID is kept (and minified)
        let used_gradient = defs.child_elements().nth(1).unwrap();
        assert!(used_gradient.has_attr("id"));
    }

    #[test]
    fn test_minify_ids() {
        let svg = r#"<svg>
            <defs>
                <linearGradient id="myVeryLongGradientId">
                    <stop offset="0%" stop-color="red"/>
                </linearGradient>
            </defs>
            <rect fill="url(#myVeryLongGradientId)" width="100" height="100"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupIdsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Check that ID is minified
        let defs = document.root.child_elements().next().unwrap();
        let gradient = defs.child_elements().next().unwrap();
        let new_id = gradient.attr("id").unwrap();
        assert!(new_id.len() < "myVeryLongGradientId".len());

        // Check that reference is updated
        let rect = document.root.child_elements().nth(1).unwrap();
        let fill = rect.attr("fill").unwrap();
        assert!(fill.contains(&format!("#{}", new_id)));
    }

    #[test]
    fn test_preserve_ids() {
        let svg = r#"<svg>
            <rect id="preserve-me" width="100" height="100"/>
            <rect id="icon-rect" width="50" height="50"/>
            <rect id="normal-rect" width="25" height="25"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupIdsPlugin;
        let params = json!({
            "preserve": ["preserve-me"],
            "preservePrefixes": ["icon-"]
        });

        plugin
            .apply(
                &mut document,
                &crate::plugin::PluginInfo::default(),
                Some(&params),
            )
            .unwrap();

        // Check that preserved IDs are kept
        let rect1 = document.root.child_elements().next().unwrap();
        assert_eq!(rect1.attr("id"), Some(&"preserve-me".to_string()));

        let rect2 = document.root.child_elements().nth(1).unwrap();
        assert_eq!(rect2.attr("id"), Some(&"icon-rect".to_string()));

        // Check that non-preserved ID is removed (no references to it)
        let rect3 = document.root.child_elements().nth(2).unwrap();
        assert!(!rect3.has_attr("id"));
    }

    #[test]
    fn test_skip_with_scripts() {
        let svg = r#"<svg>
            <script>console.log('test');</script>
            <rect id="unused-rect" width="100" height="100"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = CleanupIdsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Should not remove ID when scripts are present
        let rect = document.root.child_elements().nth(1).unwrap();
        assert!(rect.has_attr("id"));
    }
}

```

Relative File Path: svgn/src/plugins/cleanup_list_of_values.rs

```rust
// this_file: svgn/src/plugins/cleanup_list_of_values.rs

//! Plugin to round list of values to fixed precision
//!
//! Rounds lists of numeric values (like viewBox, points, stroke-dasharray)
//! to the specified precision and optimizes units.

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use regex::Regex;
use serde_json::Value;
use std::collections::HashMap;
use std::sync::LazyLock;

/// Regular expression to match numeric values with optional units
static NUMERIC_VALUE_REGEX: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(r"^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$").unwrap()
});

/// Regular expression to split lists of values (space and/or comma separated)
static SEPARATOR_REGEX: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"\s+,?\s*|,\s*").unwrap());

/// Regular expression to match the "new" keyword (for enable-background)
static NEW_KEYWORD_REGEX: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"^new$").unwrap());

/// Conversion factors from absolute units to pixels
static ABSOLUTE_LENGTHS: LazyLock<HashMap<&'static str, f64>> = LazyLock::new(|| {
    [
        ("cm", 96.0 / 2.54), // 96 DPI / 2.54 cm per inch
        ("mm", 96.0 / 25.4), // 96 DPI / 25.4 mm per inch
        ("in", 96.0),        // 96 pixels per inch
        ("pt", 4.0 / 3.0),   // 4/3 pixels per point
        ("pc", 16.0),        // 16 pixels per pica
        ("px", 1.0),         // 1 pixel per pixel
    ]
    .into_iter()
    .collect()
});

/// Attributes that contain lists of values
static LIST_ATTRIBUTES: LazyLock<[&'static str; 8]> = LazyLock::new(|| {
    [
        "points",
        "enable-background",
        "viewBox",
        "stroke-dasharray",
        "dx",
        "dy",
        "x",
        "y",
    ]
});

/// Plugin to clean up lists of numeric values
pub struct CleanupListOfValuesPlugin;

/// Configuration parameters for the plugin
#[derive(Debug)]
pub struct CleanupListOfValuesParams {
    /// Number of decimal places to round to (default: 3)
    pub float_precision: usize,
    /// Remove leading zeros from decimals (default: true)
    pub leading_zero: bool,
    /// Remove default "px" units (default: true)  
    pub default_px: bool,
    /// Convert absolute units to px when beneficial (default: true)
    pub convert_to_px: bool,
}

impl Default for CleanupListOfValuesParams {
    fn default() -> Self {
        Self {
            float_precision: 3,
            leading_zero: true,
            default_px: true,
            convert_to_px: true,
        }
    }
}

impl CleanupListOfValuesParams {
    /// Parse parameters from JSON value
    pub fn from_value(value: Option<&Value>) -> Self {
        let mut params = Self::default();

        if let Some(Value::Object(map)) = value {
            if let Some(Value::Number(precision)) = map.get("floatPrecision") {
                if let Some(precision) = precision.as_u64() {
                    params.float_precision = precision as usize;
                }
            }
            if let Some(Value::Bool(leading_zero)) = map.get("leadingZero") {
                params.leading_zero = *leading_zero;
            }
            if let Some(Value::Bool(default_px)) = map.get("defaultPx") {
                params.default_px = *default_px;
            }
            if let Some(Value::Bool(convert_to_px)) = map.get("convertToPx") {
                params.convert_to_px = *convert_to_px;
            }
        }

        params
    }
}

impl Plugin for CleanupListOfValuesPlugin {
    fn name(&self) -> &'static str {
        "cleanupListOfValues"
    }

    fn description(&self) -> &'static str {
        "rounds list of values to the fixed precision"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()> {
        let config = CleanupListOfValuesParams::from_value(params);
        visit_elements(&mut document.root, &config);
        Ok(())
    }
}

/// Visit all elements in the AST and apply list value cleanup
fn visit_elements(element: &mut Element, config: &CleanupListOfValuesParams) {
    cleanup_list_values_in_element(element, config);

    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            visit_elements(child_element, config);
        }
    }
}

/// Clean up list values in a single element
fn cleanup_list_values_in_element(element: &mut Element, config: &CleanupListOfValuesParams) {
    for attr_name in LIST_ATTRIBUTES.iter() {
        if let Some(value) = element.attributes.get_mut(*attr_name) {
            *value = round_values(value, config);
        }
    }
}

/// Round all values in a space/comma-separated list
fn round_values(lists: &str, config: &CleanupListOfValuesParams) -> String {
    let mut rounded_list = Vec::new();

    for elem in SEPARATOR_REGEX.split(lists) {
        if elem.is_empty() {
            continue;
        }

        // Check for "new" keyword (enable-background)
        if NEW_KEYWORD_REGEX.is_match(elem) {
            rounded_list.push("new".to_string());
            continue;
        }

        // Check for numeric value
        if let Some(captures) = NUMERIC_VALUE_REGEX.captures(elem) {
            if let Some(rounded) = process_numeric_value(&captures, elem, config) {
                rounded_list.push(rounded);
            }
        } else {
            // Non-numeric value, keep as is
            rounded_list.push(elem.to_string());
        }
    }

    rounded_list.join(" ")
}

/// Process a single numeric value from the regex captures
fn process_numeric_value(
    captures: &regex::Captures,
    original: &str,
    config: &CleanupListOfValuesParams,
) -> Option<String> {
    let number_str = captures.get(1)?.as_str();
    let mut number: f64 = number_str.parse().ok()?;
    let unit = captures.get(3).map(|m| m.as_str()).unwrap_or("");
    let mut final_unit = unit;

    // Convert absolute units to pixels if beneficial
    if config.convert_to_px && !unit.is_empty() && ABSOLUTE_LENGTHS.contains_key(unit) {
        let conversion_factor = ABSOLUTE_LENGTHS[unit];
        let original_number: f64 = number_str.parse().unwrap();
        let px_value = original_number * conversion_factor;
        let px_rounded = round_to_precision(px_value, config.float_precision);

        // Format the px value and see if it's shorter
        let px_formatted = format_number(px_rounded, config);
        let px_str = if config.default_px {
            px_formatted.clone() // Remove px unit
        } else {
            px_formatted.clone() + "px"
        };

        // Use px conversion if it results in a shorter string
        if px_str.len() < original.len() {
            number = px_rounded;
            final_unit = "px";
        } else {
            number = round_to_precision(original_number, config.float_precision);
        }
    } else {
        number = round_to_precision(number, config.float_precision);
    }

    // Format the number
    let mut result = format_number(number, config);

    // Remove default 'px' units if enabled
    if config.default_px && final_unit == "px" {
        final_unit = "";
    }

    result.push_str(final_unit);
    Some(result)
}

/// Round a number to the specified precision
fn round_to_precision(num: f64, precision: usize) -> f64 {
    let multiplier = 10_f64.powi(precision as i32);
    (num * multiplier).round() / multiplier
}

/// Format a number according to the configuration
fn format_number(num: f64, config: &CleanupListOfValuesParams) -> String {
    let formatted = if num.fract() == 0.0 {
        // Integer - no decimal places needed
        (num as i64).to_string()
    } else {
        // Format with precision and remove trailing zeros
        format!("{:.precision$}", num, precision = config.float_precision)
            .trim_end_matches('0')
            .trim_end_matches('.')
            .to_string()
    };

    if config.leading_zero {
        remove_leading_zero(&formatted)
    } else {
        formatted
    }
}

/// Remove leading zero from decimal numbers (0.5 → .5, -0.5 → -.5)
fn remove_leading_zero(value: &str) -> String {
    if value.len() > 1 && value.starts_with("0.") {
        return value[1..].to_string();
    }

    if value.len() > 2 && value.starts_with("-0.") {
        return format!("-{}", &value[2..]);
    }

    value.to_string()
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::ast::{Document, Element};
    use serde_json::json;

    #[test]
    fn test_rounds_points_list() {
        let mut document = Document::new();
        let mut element = Element::new("polygon");
        element.attributes.insert(
            "points".to_string(),
            "208.250977 77.1308594 223.069336 92.456789".to_string(),
        );
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("points"),
            Some(&"208.251 77.131 223.069 92.457".to_string())
        );
    }

    #[test]
    fn test_rounds_viewbox() {
        let mut document = Document::new();
        let mut element = Element::new("svg");
        element.attributes.insert(
            "viewBox".to_string(),
            "0.12345 1.6789 200.28423 200.28423".to_string(),
        );
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("viewBox"),
            Some(&".123 1.679 200.284 200.284".to_string())
        );
    }

    #[test]
    fn test_rounds_stroke_dasharray() {
        let mut document = Document::new();
        let mut element = Element::new("path");
        element.attributes.insert(
            "stroke-dasharray".to_string(),
            "5.555 10.9999 15.123456".to_string(),
        );
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("stroke-dasharray"),
            Some(&"5.555 11 15.123".to_string())
        );
    }

    #[test]
    fn test_handles_enable_background_with_new() {
        let mut document = Document::new();
        let mut element = Element::new("svg");
        element.attributes.insert(
            "enable-background".to_string(),
            "new 0.12345 1.6789 200.28423 200.28423".to_string(),
        );
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("enable-background"),
            Some(&"new .123 1.679 200.284 200.284".to_string())
        );
    }

    #[test]
    fn test_rounds_text_positioning() {
        let mut document = Document::new();
        let mut element = Element::new("text");
        element
            .attributes
            .insert("dx".to_string(), "1.234567 2.567890 3.999999".to_string());
        element
            .attributes
            .insert("dy".to_string(), "0.555 -0.333 0.125".to_string());
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("dx"),
            Some(&"1.235 2.568 4".to_string())
        );
        assert_eq!(
            document.root.attributes.get("dy"),
            Some(&".555 -.333 .125".to_string())
        );
    }

    #[test]
    fn test_handles_comma_separated_values() {
        let mut document = Document::new();
        let mut element = Element::new("polygon");
        element.attributes.insert(
            "points".to_string(),
            "1.234567,2.567890,3.999999,4.12345".to_string(),
        );
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("points"),
            Some(&"1.235 2.568 4 4.123".to_string())
        );
    }

    #[test]
    fn test_handles_mixed_separators() {
        let mut document = Document::new();
        let mut element = Element::new("polygon");
        element.attributes.insert(
            "points".to_string(),
            "1.234567, 2.567890 , 3.999999  4.12345".to_string(),
        );
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("points"),
            Some(&"1.235 2.568 4 4.123".to_string())
        );
    }

    #[test]
    fn test_converts_units_in_lists() {
        let mut document = Document::new();
        let mut element = Element::new("polygon");
        element
            .attributes
            .insert("points".to_string(), "1in 96pt 3cm 4px".to_string());
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // 1in = 96px (shorter: "96" vs "1in"),
        // 96pt = 128px (shorter: "128" vs "96pt", do convert)
        // 3cm ≈ 113.386px (longer: "113.386" vs "3cm", don't convert)
        // 4px = 4 (remove px)
        assert_eq!(
            document.root.attributes.get("points"),
            Some(&"96 128 3cm 4".to_string())
        );
    }

    #[test]
    fn test_configurable_precision() {
        let mut document = Document::new();
        let mut element = Element::new("polygon");
        element
            .attributes
            .insert("points".to_string(), "1.23456 2.78901".to_string());
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        let params = json!({"floatPrecision": 2});
        plugin
            .apply(
                &mut document,
                &crate::plugin::PluginInfo::default(),
                Some(&params),
            )
            .unwrap();

        assert_eq!(
            document.root.attributes.get("points"),
            Some(&"1.23 2.79".to_string())
        );
    }

    #[test]
    fn test_configurable_leading_zero() {
        let mut document = Document::new();
        let mut element = Element::new("polygon");
        element
            .attributes
            .insert("points".to_string(), "0.5 -0.25".to_string());
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        let params = json!({"leadingZero": false});
        plugin
            .apply(
                &mut document,
                &crate::plugin::PluginInfo::default(),
                Some(&params),
            )
            .unwrap();

        assert_eq!(
            document.root.attributes.get("points"),
            Some(&"0.5 -0.25".to_string())
        );
    }

    #[test]
    fn test_preserves_non_list_attributes() {
        let mut document = Document::new();
        let mut element = Element::new("rect");
        element
            .attributes
            .insert("fill".to_string(), "red".to_string());
        element
            .attributes
            .insert("width".to_string(), "100.555".to_string());
        document.root = element;

        let mut plugin = CleanupListOfValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // These shouldn't be affected by this plugin
        assert_eq!(
            document.root.attributes.get("fill"),
            Some(&"red".to_string())
        );
        assert_eq!(
            document.root.attributes.get("width"),
            Some(&"100.555".to_string())
        );
    }

    #[test]
    fn test_plugin_name_and_description() {
        let mut plugin = CleanupListOfValuesPlugin;
        assert_eq!(plugin.name(), "cleanupListOfValues");
        assert_eq!(
            plugin.description(),
            "rounds list of values to the fixed precision"
        );
    }
}

```

Relative File Path: svgn/src/plugins/cleanup_numeric_values.rs

```rust
// this_file: svgn/src/plugins/cleanup_numeric_values.rs

//! Plugin to round numeric values to fixed precision and clean up units
//!
//! Rounds numeric values to the specified precision, removes default "px" units,
//! and optionally converts absolute units to pixels for optimization.

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use regex::Regex;
use serde_json::Value;
use std::collections::HashMap;
use std::sync::LazyLock;

/// Regular expression to match numeric values with optional units
static NUMERIC_VALUE_REGEX: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(r"^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$").unwrap()
});

/// Conversion factors from absolute units to pixels
static ABSOLUTE_LENGTHS: LazyLock<HashMap<&'static str, f64>> = LazyLock::new(|| {
    [
        ("cm", 96.0 / 2.54), // 96 DPI / 2.54 cm per inch
        ("mm", 96.0 / 25.4), // 96 DPI / 25.4 mm per inch
        ("in", 96.0),        // 96 pixels per inch
        ("pt", 4.0 / 3.0),   // 4/3 pixels per point
        ("pc", 16.0),        // 16 pixels per pica
        ("px", 1.0),         // 1 pixel per pixel
    ]
    .into_iter()
    .collect()
});

/// Plugin to clean up numeric values
pub struct CleanupNumericValuesPlugin;

/// Configuration parameters for the plugin
#[derive(Debug)]
pub struct CleanupNumericValuesParams {
    /// Number of decimal places to round to (default: 3)
    pub float_precision: usize,
    /// Remove leading zeros from decimals (default: true)
    pub leading_zero: bool,
    /// Remove default "px" units (default: true)  
    pub default_px: bool,
    /// Convert absolute units to px when beneficial (default: true)
    pub convert_to_px: bool,
}

impl Default for CleanupNumericValuesParams {
    fn default() -> Self {
        Self {
            float_precision: 3,
            leading_zero: true,
            default_px: true,
            convert_to_px: true,
        }
    }
}

impl CleanupNumericValuesParams {
    /// Parse parameters from JSON value
    pub fn from_value(value: Option<&Value>) -> Self {
        let mut params = Self::default();

        if let Some(Value::Object(map)) = value {
            if let Some(Value::Number(precision)) = map.get("floatPrecision") {
                if let Some(precision) = precision.as_u64() {
                    params.float_precision = precision as usize;
                }
            }
            if let Some(Value::Bool(leading_zero)) = map.get("leadingZero") {
                params.leading_zero = *leading_zero;
            }
            if let Some(Value::Bool(default_px)) = map.get("defaultPx") {
                params.default_px = *default_px;
            }
            if let Some(Value::Bool(convert_to_px)) = map.get("convertToPx") {
                params.convert_to_px = *convert_to_px;
            }
        }

        params
    }
}

impl Plugin for CleanupNumericValuesPlugin {
    fn name(&self) -> &'static str {
        "cleanupNumericValues"
    }

    fn description(&self) -> &'static str {
        "rounds numeric values to the fixed precision, removes default \"px\" units"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()> {
        let config = CleanupNumericValuesParams::from_value(params);
        visit_elements(&mut document.root, &config);
        Ok(())
    }
}

/// Visit all elements in the AST and apply numeric value cleanup
fn visit_elements(element: &mut Element, config: &CleanupNumericValuesParams) {
    cleanup_numeric_values_in_element(element, config);

    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            visit_elements(child_element, config);
        }
    }
}

/// Clean up numeric values in a single element
fn cleanup_numeric_values_in_element(element: &mut Element, config: &CleanupNumericValuesParams) {
    // Handle viewBox specially - it contains space/comma-separated numbers
    if let Some(viewbox) = element.attributes.get_mut("viewBox") {
        cleanup_viewbox_value(viewbox, config);
    }

    // Process all other attributes
    for (name, value) in &mut element.attributes {
        // Skip version attribute - it's a text string
        if name == "version" {
            continue;
        }

        // Skip viewBox as we handled it above
        if name == "viewBox" {
            continue;
        }

        if let Some(cleaned) = cleanup_numeric_value(value, config) {
            *value = cleaned;
        }
    }
}

/// Clean up viewBox value which contains multiple space/comma-separated numbers
fn cleanup_viewbox_value(viewbox: &mut String, config: &CleanupNumericValuesParams) {
    let nums: Vec<String> = viewbox
        .trim()
        .split(|c: char| c.is_whitespace() || c == ',')
        .filter(|s| !s.is_empty())
        .map(|value| {
            if let Ok(num) = value.parse::<f64>() {
                let rounded = round_to_precision(num, config.float_precision);
                format_number(rounded, config)
            } else {
                value.to_string()
            }
        })
        .collect();

    *viewbox = nums.join(" ");
}

/// Clean up a single numeric value with optional units
fn cleanup_numeric_value(value: &str, config: &CleanupNumericValuesParams) -> Option<String> {
    let captures = NUMERIC_VALUE_REGEX.captures(value)?;

    let number_str = captures.get(1)?.as_str();
    let mut number: f64 = number_str.parse().ok()?;
    let unit = captures.get(3).map(|m| m.as_str()).unwrap_or("");
    let mut final_unit = unit;

    // Convert absolute units to pixels if beneficial
    if config.convert_to_px && !unit.is_empty() && ABSOLUTE_LENGTHS.contains_key(unit) {
        let conversion_factor = ABSOLUTE_LENGTHS[unit];
        let original_number: f64 = number_str.parse().unwrap();
        let px_value = original_number * conversion_factor;
        let px_rounded = round_to_precision(px_value, config.float_precision);

        // Format the px value and see if it's shorter
        let px_formatted = format_number(px_rounded, config);
        let px_str = if config.default_px {
            px_formatted.clone() // Remove px unit
        } else {
            px_formatted.clone() + "px"
        };

        // Use px conversion if it results in a shorter or equal string
        if px_str.len() <= value.len() {
            number = px_rounded;
            final_unit = "px";
        } else {
            number = round_to_precision(original_number, config.float_precision);
        }
    } else {
        number = round_to_precision(number, config.float_precision);
    }

    // Format the number
    let mut result = format_number(number, config);

    // Remove default 'px' units if enabled
    if config.default_px && final_unit == "px" {
        final_unit = "";
    }

    result.push_str(final_unit);
    Some(result)
}

/// Round a number to the specified precision
fn round_to_precision(num: f64, precision: usize) -> f64 {
    let multiplier = 10_f64.powi(precision as i32);
    (num * multiplier).round() / multiplier
}

/// Format a number according to the configuration
fn format_number(num: f64, config: &CleanupNumericValuesParams) -> String {
    let formatted = if num.fract() == 0.0 {
        // Integer - no decimal places needed
        (num as i64).to_string()
    } else {
        // Format with precision and remove trailing zeros
        format!("{:.precision$}", num, precision = config.float_precision)
            .trim_end_matches('0')
            .trim_end_matches('.')
            .to_string()
    };

    if config.leading_zero {
        remove_leading_zero(&formatted)
    } else {
        formatted
    }
}

/// Remove leading zero from decimal numbers (0.5 → .5, -0.5 → -.5)
fn remove_leading_zero(value: &str) -> String {
    if value.len() > 1 && value.starts_with("0.") {
        return value[1..].to_string();
    }

    if value.len() > 2 && value.starts_with("-0.") {
        return format!("-{}", &value[2..]);
    }

    value.to_string()
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::ast::{Document, Element};
    use serde_json::json;

    #[test]
    fn test_rounds_decimal_values() {
        let mut document = Document::new();
        let mut element = Element::new("rect");
        element
            .attributes
            .insert("x".to_string(), "1.23456".to_string());
        element
            .attributes
            .insert("y".to_string(), "2.7891011".to_string());
        document.root = element;

        let mut plugin = CleanupNumericValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("x"),
            Some(&"1.235".to_string())
        );
        assert_eq!(
            document.root.attributes.get("y"),
            Some(&"2.789".to_string())
        );
    }

    #[test]
    fn test_removes_leading_zeros() {
        let mut document = Document::new();
        let mut element = Element::new("rect");
        element
            .attributes
            .insert("opacity".to_string(), "0.5".to_string());
        element
            .attributes
            .insert("fill-opacity".to_string(), "-0.25".to_string());
        document.root = element;

        let mut plugin = CleanupNumericValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("opacity"),
            Some(&".5".to_string())
        );
        assert_eq!(
            document.root.attributes.get("fill-opacity"),
            Some(&"-.25".to_string())
        );
    }

    #[test]
    fn test_removes_default_px_units() {
        let mut document = Document::new();
        let mut element = Element::new("rect");
        element
            .attributes
            .insert("width".to_string(), "100px".to_string());
        element
            .attributes
            .insert("height".to_string(), "50.5px".to_string());
        document.root = element;

        let mut plugin = CleanupNumericValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("width"),
            Some(&"100".to_string())
        );
        assert_eq!(
            document.root.attributes.get("height"),
            Some(&"50.5".to_string())
        );
    }

    #[test]
    fn test_converts_units_to_px() {
        let mut document = Document::new();
        let mut element = Element::new("rect");
        element
            .attributes
            .insert("width".to_string(), "1in".to_string()); // 96px -> "96" (shorter)
        element
            .attributes
            .insert("height".to_string(), "1pt".to_string()); // 4/3 px -> "1.333" (longer, don't convert)
        element
            .attributes
            .insert("x".to_string(), "2in".to_string()); // 192px -> "192" (shorter)
        document.root = element;

        let mut plugin = CleanupNumericValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("width"),
            Some(&"96".to_string())
        );
        assert_eq!(
            document.root.attributes.get("height"),
            Some(&"1pt".to_string())
        ); // Not converted due to length
        assert_eq!(document.root.attributes.get("x"), Some(&"192".to_string()));
    }

    #[test]
    fn test_preserves_version_attribute() {
        let mut document = Document::new();
        let mut element = Element::new("svg");
        element
            .attributes
            .insert("version".to_string(), "1.1".to_string());
        element
            .attributes
            .insert("width".to_string(), "1.1".to_string());
        document.root = element;

        let mut plugin = CleanupNumericValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Version should be unchanged, width should be rounded
        assert_eq!(
            document.root.attributes.get("version"),
            Some(&"1.1".to_string())
        );
        assert_eq!(
            document.root.attributes.get("width"),
            Some(&"1.1".to_string())
        );
    }

    #[test]
    fn test_cleans_viewbox() {
        let mut document = Document::new();
        let mut element = Element::new("svg");
        element.attributes.insert(
            "viewBox".to_string(),
            "0.12345 1.6789 100.555 50.9999".to_string(),
        );
        document.root = element;

        let mut plugin = CleanupNumericValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("viewBox"),
            Some(&".123 1.679 100.555 51".to_string())
        );
    }

    #[test]
    fn test_configurable_precision() {
        let mut document = Document::new();
        let mut element = Element::new("rect");
        element
            .attributes
            .insert("x".to_string(), "1.23456".to_string());
        document.root = element;

        let mut plugin = CleanupNumericValuesPlugin;
        let params = json!({"floatPrecision": 2});
        plugin
            .apply(
                &mut document,
                &crate::plugin::PluginInfo::default(),
                Some(&params),
            )
            .unwrap();

        assert_eq!(document.root.attributes.get("x"), Some(&"1.23".to_string()));
    }

    #[test]
    fn test_configurable_leading_zero() {
        let mut document = Document::new();
        let mut element = Element::new("rect");
        element
            .attributes
            .insert("opacity".to_string(), "0.5".to_string());
        document.root = element;

        let mut plugin = CleanupNumericValuesPlugin;
        let params = json!({"leadingZero": false});
        plugin
            .apply(
                &mut document,
                &crate::plugin::PluginInfo::default(),
                Some(&params),
            )
            .unwrap();

        assert_eq!(
            document.root.attributes.get("opacity"),
            Some(&"0.5".to_string())
        );
    }

    #[test]
    fn test_configurable_default_px() {
        let mut document = Document::new();
        let mut element = Element::new("rect");
        element
            .attributes
            .insert("width".to_string(), "100px".to_string());
        document.root = element;

        let mut plugin = CleanupNumericValuesPlugin;
        let params = json!({"defaultPx": false});
        plugin
            .apply(
                &mut document,
                &crate::plugin::PluginInfo::default(),
                Some(&params),
            )
            .unwrap();

        assert_eq!(
            document.root.attributes.get("width"),
            Some(&"100px".to_string())
        );
    }

    #[test]
    fn test_preserves_non_numeric_values() {
        let mut document = Document::new();
        let mut element = Element::new("rect");
        element
            .attributes
            .insert("fill".to_string(), "red".to_string());
        element
            .attributes
            .insert("id".to_string(), "test123".to_string());
        document.root = element;

        let mut plugin = CleanupNumericValuesPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(
            document.root.attributes.get("fill"),
            Some(&"red".to_string())
        );
        assert_eq!(
            document.root.attributes.get("id"),
            Some(&"test123".to_string())
        );
    }

    #[test]
    fn test_plugin_name_and_description() {
        let mut plugin = CleanupNumericValuesPlugin;
        assert_eq!(plugin.name(), "cleanupNumericValues");
        assert_eq!(
            plugin.description(),
            "rounds numeric values to the fixed precision, removes default \"px\" units"
        );
    }
}

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs
# Language: rust

mod tests;

struct CollapseGroupsConfig {
}

struct CollapseGroupsPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs
# Language: rust

mod tests;

struct ConvertColorsPlugin {
}

struct ConvertColorsConfig {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs
# Language: rust

mod tests;

struct ConvertEllipseToCirclePlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs
# Language: rust

mod tests;

struct ConvertOneStopGradientsPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_path_data.rs
# Language: rust

mod tests;

struct PathOptimizationConfig {
}

struct ConvertPathDataPlugin {
}

struct PathCommand {
}


Relative File Path: svgn/src/plugins/convert_shape_to_path.rs

```rust
// this_file: svgn/src/plugins/convert_shape_to_path.rs

//! Convert basic shapes to path elements
//!
//! This plugin converts rect, line, polyline, polygon, circle and ellipse elements
//! to path elements for better optimization potential.

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use regex::Regex;
use serde_json::Value;
use std::sync::LazyLock;

static NUMBER_REGEX: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r"[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?").unwrap());

/// Plugin that converts basic shapes to path elements
pub struct ConvertShapeToPathPlugin;

impl Plugin for ConvertShapeToPathPlugin {
    fn name(&self) -> &'static str {
        "convertShapeToPath"
    }

    fn description(&self) -> &'static str {
        "Converts basic shapes to more compact path form"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()> {
        // Parse parameters
        let convert_arcs = params
            .and_then(|v| v.get("convertArcs"))
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        let float_precision = params
            .and_then(|v| v.get("floatPrecision"))
            .and_then(|v| v.as_u64())
            .map(|p| p as u8);

        // Process root element
        convert_shapes_in_element(&mut document.root, convert_arcs, float_precision);

        Ok(())
    }
}

/// Recursively convert shapes in an element and its children
fn convert_shapes_in_element(
    element: &mut Element,
    convert_arcs: bool,
    float_precision: Option<u8>,
) {
    // Process child elements
    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            convert_shapes_in_element(child_element, convert_arcs, float_precision);
        }
    }

    // Convert current element if it's a shape
    convert_shape_element(element, convert_arcs, float_precision);
}

/// Convert a shape element to a path if applicable
fn convert_shape_element(element: &mut Element, convert_arcs: bool, float_precision: Option<u8>) {
    match element.name.as_str() {
        "rect" => convert_rect(element, float_precision),
        "line" => convert_line(element, float_precision),
        "polyline" => convert_polyline(element, float_precision),
        "polygon" => convert_polygon(element, float_precision),
        "circle" if convert_arcs => convert_circle(element, float_precision),
        "ellipse" if convert_arcs => convert_ellipse(element, float_precision),
        _ => {}
    }
}

/// Parse a coordinate value, returning None if it's not a valid number
fn parse_coord(value: &str) -> Option<f64> {
    // Skip if contains non-numeric characters that indicate units or percentages
    if value.contains('%') || value.contains("px") || value.contains("pt") {
        return None;
    }
    value.parse().ok()
}

/// Convert a rectangle to a path
fn convert_rect(element: &mut Element, float_precision: Option<u8>) {
    // Don't convert rectangles with rounded corners
    if element.has_attr("rx") || element.has_attr("ry") {
        return;
    }

    // Extract required attributes
    let width_str = match element.attr("width") {
        Some(w) => w,
        None => return,
    };
    let height_str = match element.attr("height") {
        Some(h) => h,
        None => return,
    };

    let x = match parse_coord(element.attr("x").map_or("0", |v| v)) {
        Some(x) => x,
        None => return,
    };
    let y = match parse_coord(element.attr("y").map_or("0", |v| v)) {
        Some(y) => y,
        None => return,
    };
    let width = match parse_coord(width_str) {
        Some(w) => w,
        None => return,
    };
    let height = match parse_coord(height_str) {
        Some(h) => h,
        None => return,
    };

    // Build path data: M x y H x+width V y+height H x z
    let path_data = format!(
        "M{} {}H{}V{}H{}z",
        format_number(x, float_precision),
        format_number(y, float_precision),
        format_number(x + width, float_precision),
        format_number(y + height, float_precision),
        format_number(x, float_precision)
    );

    // Update element
    element.name = "path".to_string();
    element.set_attr("d".to_string(), path_data);
    element.remove_attr("x");
    element.remove_attr("y");
    element.remove_attr("width");
    element.remove_attr("height");
}

/// Convert a line to a path
fn convert_line(element: &mut Element, float_precision: Option<u8>) {
    let x1 = match parse_coord(element.attr("x1").map_or("0", |v| v)) {
        Some(x) => x,
        None => return,
    };
    let y1 = match parse_coord(element.attr("y1").map_or("0", |v| v)) {
        Some(y) => y,
        None => return,
    };
    let x2 = match parse_coord(element.attr("x2").map_or("0", |v| v)) {
        Some(x) => x,
        None => return,
    };
    let y2 = match parse_coord(element.attr("y2").map_or("0", |v| v)) {
        Some(y) => y,
        None => return,
    };

    // Build path data: M x1 y1 L x2 y2
    let path_data = format!(
        "M{} {} {} {}",
        format_number(x1, float_precision),
        format_number(y1, float_precision),
        format_number(x2, float_precision),
        format_number(y2, float_precision)
    );

    // Update element
    element.name = "path".to_string();
    element.set_attr("d".to_string(), path_data);
    element.remove_attr("x1");
    element.remove_attr("y1");
    element.remove_attr("x2");
    element.remove_attr("y2");
}

/// Convert polyline to a path
fn convert_polyline(element: &mut Element, float_precision: Option<u8>) {
    convert_poly(element, false, float_precision);
}

/// Convert polygon to a path
fn convert_polygon(element: &mut Element, float_precision: Option<u8>) {
    convert_poly(element, true, float_precision);
}

/// Convert polyline or polygon to a path
fn convert_poly(element: &mut Element, is_polygon: bool, float_precision: Option<u8>) {
    let points_str = match element.attr("points") {
        Some(p) => p,
        None => return,
    };

    // Extract all numbers from the points string
    let coords: Vec<f64> = NUMBER_REGEX
        .find_iter(points_str)
        .filter_map(|m| m.as_str().parse().ok())
        .collect();

    // Need at least 2 coordinate pairs (4 numbers)
    if coords.len() < 4 {
        // Remove the element by removing all its children and marking name as empty
        element.clear_children();
        element.name = "g".to_string(); // Convert to empty group that will be removed by other plugins
        element.attributes.clear();
        return;
    }

    // Build path data
    let mut path_data = String::new();

    for (i, chunk) in coords.chunks(2).enumerate() {
        if chunk.len() == 2 {
            if i == 0 {
                path_data.push_str(&format!(
                    "M{} {}",
                    format_number(chunk[0], float_precision),
                    format_number(chunk[1], float_precision)
                ));
            } else {
                path_data.push_str(&format!(
                    " {} {}",
                    format_number(chunk[0], float_precision),
                    format_number(chunk[1], float_precision)
                ));
            }
        }
    }

    // Add closing command for polygons
    if is_polygon {
        path_data.push('z');
    }

    // Update element
    element.name = "path".to_string();
    element.set_attr("d".to_string(), path_data);
    element.remove_attr("points");
}

/// Convert circle to a path using arc commands
fn convert_circle(element: &mut Element, float_precision: Option<u8>) {
    let cx = match parse_coord(element.attr("cx").map_or("0", |v| v)) {
        Some(x) => x,
        None => return,
    };
    let cy = match parse_coord(element.attr("cy").map_or("0", |v| v)) {
        Some(y) => y,
        None => return,
    };
    let r = match parse_coord(element.attr("r").map_or("0", |v| v)) {
        Some(r) => r,
        None => return,
    };

    // Build path data using two arc commands
    let path_data = format!(
        "M{} {}A{} {} 0 1 0 {} {}A{} {} 0 1 0 {} {}z",
        format_number(cx, float_precision),
        format_number(cy - r, float_precision),
        format_number(r, float_precision),
        format_number(r, float_precision),
        format_number(cx, float_precision),
        format_number(cy + r, float_precision),
        format_number(r, float_precision),
        format_number(r, float_precision),
        format_number(cx, float_precision),
        format_number(cy - r, float_precision)
    );

    // Update element
    element.name = "path".to_string();
    element.set_attr("d".to_string(), path_data);
    element.remove_attr("cx");
    element.remove_attr("cy");
    element.remove_attr("r");
}

/// Convert ellipse to a path using arc commands
fn convert_ellipse(element: &mut Element, float_precision: Option<u8>) {
    let cx = match parse_coord(element.attr("cx").map_or("0", |v| v)) {
        Some(x) => x,
        None => return,
    };
    let cy = match parse_coord(element.attr("cy").map_or("0", |v| v)) {
        Some(y) => y,
        None => return,
    };
    let rx = match parse_coord(element.attr("rx").map_or("0", |v| v)) {
        Some(r) => r,
        None => return,
    };
    let ry = match parse_coord(element.attr("ry").map_or("0", |v| v)) {
        Some(r) => r,
        None => return,
    };

    // Build path data using two arc commands
    let path_data = format!(
        "M{} {}A{} {} 0 1 0 {} {}A{} {} 0 1 0 {} {}z",
        format_number(cx, float_precision),
        format_number(cy - ry, float_precision),
        format_number(rx, float_precision),
        format_number(ry, float_precision),
        format_number(cx, float_precision),
        format_number(cy + ry, float_precision),
        format_number(rx, float_precision),
        format_number(ry, float_precision),
        format_number(cx, float_precision),
        format_number(cy - ry, float_precision)
    );

    // Update element
    element.name = "path".to_string();
    element.set_attr("d".to_string(), path_data);
    element.remove_attr("cx");
    element.remove_attr("cy");
    element.remove_attr("rx");
    element.remove_attr("ry");
}

/// Format a number with optional precision
fn format_number(value: f64, precision: Option<u8>) -> String {
    match precision {
        Some(p) => {
            let formatted = format!("{:.1$}", value, p as usize);
            // Remove trailing zeros and decimal point if integer
            let trimmed = formatted.trim_end_matches('0').trim_end_matches('.');
            if trimmed.is_empty() || trimmed == "-" {
                "0".to_string()
            } else {
                trimmed.to_string()
            }
        }
        None => {
            // Default formatting - remove .0 from integers
            if value.fract() == 0.0 {
                format!("{}", value as i64)
            } else {
                value.to_string()
            }
        }
    }
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::ast::Element;
    use indexmap::IndexMap;

    fn create_element(name: &str, attrs: Vec<(&str, &str)>) -> Element {
        let mut attributes = IndexMap::new();
        for (key, value) in attrs {
            attributes.insert(key.to_string(), value.to_string());
        }

        Element {
            name: name.to_string(),
            attributes,
            children: vec![],
            namespaces: Default::default(),
        }
    }

    #[test]
    fn test_convert_rect_basic() {
        let mut element = create_element("rect", vec![("width", "32"), ("height", "32")]);

        convert_rect(&mut element, None);

        assert_eq!(element.name, "path");
        assert_eq!(element.attr("d").unwrap(), "M0 0H32V32H0z");
        assert!(!element.has_attr("width"));
        assert!(!element.has_attr("height"));
    }

    #[test]
    fn test_convert_rect_with_position() {
        let mut element = create_element(
            "rect",
            vec![("x", "20"), ("y", "10"), ("width", "50"), ("height", "40")],
        );

        convert_rect(&mut element, None);

        assert_eq!(element.name, "path");
        assert_eq!(element.attr("d").unwrap(), "M20 10H70V50H20z");
    }

    #[test]
    fn test_rect_with_rounded_corners_not_converted() {
        let mut element = create_element(
            "rect",
            vec![
                ("x", "10"),
                ("y", "10"),
                ("width", "50"),
                ("height", "50"),
                ("rx", "4"),
            ],
        );

        convert_rect(&mut element, None);

        // Should not be converted
        assert_eq!(element.name, "rect");
        assert!(element.has_attr("rx"));
    }

    #[test]
    fn test_convert_line() {
        let mut element = create_element(
            "line",
            vec![("x1", "10"), ("y1", "10"), ("x2", "50"), ("y2", "20")],
        );

        convert_line(&mut element, None);

        assert_eq!(element.name, "path");
        assert_eq!(element.attr("d").unwrap(), "M10 10 50 20");
        assert!(!element.has_attr("x1"));
        assert!(!element.has_attr("y1"));
        assert!(!element.has_attr("x2"));
        assert!(!element.has_attr("y2"));
    }

    #[test]
    fn test_convert_polyline() {
        let mut element = create_element("polyline", vec![("points", "10,80 20,50 50,20 80,10")]);

        convert_polyline(&mut element, None);

        assert_eq!(element.name, "path");
        assert_eq!(element.attr("d").unwrap(), "M10 80 20 50 50 20 80 10");
        assert!(!element.has_attr("points"));
    }

    #[test]
    fn test_convert_polygon() {
        let mut element = create_element("polygon", vec![("points", "20 10 50 40 30 20")]);

        convert_polygon(&mut element, None);

        assert_eq!(element.name, "path");
        assert_eq!(element.attr("d").unwrap(), "M20 10 50 40 30 20z");
        assert!(!element.has_attr("points"));
    }

    #[test]
    fn test_convert_circle() {
        let mut element = create_element("circle", vec![("cx", "50"), ("cy", "50"), ("r", "25")]);

        convert_circle(&mut element, None);

        assert_eq!(element.name, "path");
        assert_eq!(
            element.attr("d").unwrap(),
            "M50 25A25 25 0 1 0 50 75A25 25 0 1 0 50 25z"
        );
        assert!(!element.has_attr("cx"));
        assert!(!element.has_attr("cy"));
        assert!(!element.has_attr("r"));
    }

    #[test]
    fn test_precision_formatting() {
        assert_eq!(format_number(10.123456, Some(3)), "10.123");
        assert_eq!(format_number(20.987654, Some(3)), "20.988");
        assert_eq!(format_number(30.0, Some(3)), "30");
        assert_eq!(format_number(40.5, None), "40.5");
        assert_eq!(format_number(50.0, None), "50");
    }
}

```

Relative File Path: svgn/src/plugins/convert_style_to_attrs.rs

```rust
// this_file: svgn/src/plugins/convert_style_to_attrs.rs

//! Convert style to attributes plugin
//!
//! This plugin converts inline styles to SVG presentation attributes
//! where possible. It parses the style attribute and extracts any
//! properties that are valid presentation attributes.
//! Ported from ref/svgo/plugins/convertStyleToAttrs.js

use crate::ast::{Document, Element, Node};
use crate::collections::PRESENTATION_ATTRS;
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use regex::Regex;
use serde_json::Value;
use std::sync::LazyLock;

/// Plugin that converts inline styles to SVG presentation attributes
pub struct ConvertStyleToAttrsPlugin;

// Regex for parsing CSS declarations
// This handles CSS comments, strings, escape sequences, and declarations
static CSS_DECLARATION_RE: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(
        r#"(?x)
        (?:
            /\*[\s\S]*?\*/  # CSS comments
            |
            (?:
                ([-\w]+)  # property name
                \s*:\s*
                (
                    (?:
                        /\*[\s\S]*?\*/  # inline comments
                        |
                        '(?:[^'\\]|\\.)*'  # single-quoted strings
                        |
                        "(?:[^"\\]|\\.)*"  # double-quoted strings
                        |
                        [^;'"/]  # any other character
                    )+
                )
            )
            \s*(?:;|$)  # declaration end
        )
        "#,
    )
    .unwrap()
});

impl Plugin for ConvertStyleToAttrsPlugin {
    fn name(&self) -> &'static str {
        "convertStyleToAttrs"
    }

    fn description(&self) -> &'static str {
        "Convert inline styles to SVG presentation attributes"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        _params: Option<&Value>,
    ) -> PluginResult<()> {
        // Process the root element and all its descendants
        convert_styles(&mut document.root);

        Ok(())
    }
}

/// Recursively convert styles to attributes for an element and its descendants
fn convert_styles(element: &mut Element) {
    // Check if element has a style attribute
    if let Some(style_value) = element.attributes.get("style").cloned() {
        let mut remaining_styles = Vec::new();
        let mut new_attributes = Vec::new();

        // Parse CSS declarations
        for cap in CSS_DECLARATION_RE.captures_iter(&style_value) {
            if let (Some(prop_match), Some(value_match)) = (cap.get(1), cap.get(2)) {
                let property = prop_match.as_str().trim();
                let value = strip_css_comments(value_match.as_str()).trim().to_string();

                // Check if this is a presentation attribute
                if PRESENTATION_ATTRS.contains(property) {
                    // Don't override existing attributes
                    if !element.attributes.contains_key(property) {
                        new_attributes.push((property.to_string(), value));
                    } else {
                        // Keep in style if attribute already exists
                        remaining_styles.push(format!("{}: {}", property, value));
                    }
                } else {
                    // Not a presentation attribute, keep in style
                    remaining_styles.push(format!("{}: {}", property, value));
                }
            }
        }

        // Add new attributes
        for (name, value) in new_attributes {
            element.attributes.insert(name, value);
        }

        // Update or remove style attribute
        if remaining_styles.is_empty() {
            element.attributes.shift_remove("style");
        } else {
            element
                .attributes
                .insert("style".to_string(), remaining_styles.join("; "));
        }
    }

    // Recursively process child elements
    for child in &mut element.children {
        if let Node::Element(ref mut child_elem) = child {
            convert_styles(child_elem);
        }
    }
}

/// Strip CSS comments from a value string
fn strip_css_comments(value: &str) -> String {
    // Simple regex to remove CSS comments
    let comment_re = Regex::new(r"/\*[\s\S]*?\*/").unwrap();
    comment_re.replace_all(value, "").to_string()
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::parser::Parser;

    #[test]
    fn test_convert_style_to_attrs() {
        let svg = r#"<svg>
            <rect style="fill: red; stroke: blue; opacity: 0.5" width="100" height="100"/>
            <circle style="fill: green; custom-prop: value" r="50"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = ConvertStyleToAttrsPlugin;
        let plugin_info = PluginInfo {
            path: None,
            multipass_count: 0,
        };
        plugin.apply(&mut document, &plugin_info, None).unwrap();

        // Find rect element
        let rect = document
            .root
            .child_elements()
            .find(|e| e.name == "rect")
            .unwrap();
        assert_eq!(rect.attributes.get("fill"), Some(&"red".to_string()));
        assert_eq!(rect.attributes.get("stroke"), Some(&"blue".to_string()));
        assert_eq!(rect.attributes.get("opacity"), Some(&"0.5".to_string()));
        assert!(!rect.attributes.contains_key("style"));

        // Find circle element - custom-prop should remain in style
        let circle = document
            .root
            .child_elements()
            .find(|e| e.name == "circle")
            .unwrap();
        assert_eq!(circle.attributes.get("fill"), Some(&"green".to_string()));
        assert_eq!(
            circle.attributes.get("style"),
            Some(&"custom-prop: value".to_string())
        );
    }

    #[test]
    fn test_preserve_existing_attributes() {
        let svg = r#"<svg>
            <rect style="fill: red; stroke: blue" fill="green" width="100"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = ConvertStyleToAttrsPlugin;
        let plugin_info = PluginInfo {
            path: None,
            multipass_count: 0,
        };
        plugin.apply(&mut document, &plugin_info, None).unwrap();

        // Check that existing fill attribute is preserved
        let rect = document
            .root
            .child_elements()
            .find(|e| e.name == "rect")
            .unwrap();
        assert_eq!(rect.attributes.get("fill"), Some(&"green".to_string()));
        assert_eq!(rect.attributes.get("stroke"), Some(&"blue".to_string()));
        assert_eq!(rect.attributes.get("style"), Some(&"fill: red".to_string()));
    }

    #[test]
    fn test_complex_css_parsing() {
        let svg = r#"<svg>
            <rect style="/* comment */ fill: url(#grad); stroke: /* inline */ blue; font-family: 'Arial', sans-serif"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = ConvertStyleToAttrsPlugin;
        let plugin_info = PluginInfo {
            path: None,
            multipass_count: 0,
        };
        plugin.apply(&mut document, &plugin_info, None).unwrap();

        // Check parsing of complex CSS
        let rect = document
            .root
            .child_elements()
            .find(|e| e.name == "rect")
            .unwrap();
        assert_eq!(rect.attributes.get("fill"), Some(&"url(#grad)".to_string()));
        assert_eq!(rect.attributes.get("stroke"), Some(&"blue".to_string()));
        assert_eq!(
            rect.attributes.get("font-family"),
            Some(&"'Arial', sans-serif".to_string())
        );
        assert!(!rect.attributes.contains_key("style"));
    }
}

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_transform.rs
# Language: rust

mod tests;

struct ConvertTransformPlugin {
}

struct ConvertTransformParams {
}

struct Transform {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/inline_styles/inline_styles_converter.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/inline_styles/inline_styles_selector.rs
# Language: rust

struct SvgElementWrapper {
}

struct SvgSelectorImpl {
}

struct SvgString {
}

struct LocalName {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/inline_styles.rs
# Language: rust

mod inline_styles_selector;

mod inline_styles_converter;

mod tests;

struct InlineStylesParams {
}

struct InlineStylesPlugin {
}

struct CssRuleData {
}

struct Parser {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/inline_styles_complex.rs
# Language: rust

struct InlineStylesParams {
}

struct InlineStylesPlugin {
}

struct CssRuleData {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/inline_styles_converter.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/inline_styles_selector.rs
# Language: rust

struct SvgSelectorImpl {
}

struct SvgElementWrapper {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs
# Language: rust

mod tests;

struct MergeStylesPlugin {
}


Relative File Path: svgn/src/plugins/minify_styles.rs

```rust
// this_file: svgn/src/plugins/minify_styles.rs

//! Minify CSS in style elements and style attributes
//!
//! This plugin performs basic CSS minification by removing whitespace,
//! comments, and unnecessary semicolons from CSS content.

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use regex::Regex;
use serde_json::Value;
use std::sync::LazyLock;

// Regular expressions for CSS minification
static CSS_COMMENT_REGEX: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/").unwrap());

static CSS_WHITESPACE_REGEX: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"\s+").unwrap());

static CSS_SEMICOLON_REGEX: LazyLock<Regex> = LazyLock::new(|| Regex::new(r";\s*}").unwrap());

static CSS_TRAILING_SEMICOLON_REGEX: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r";\s*$").unwrap());

static CSS_COLON_SPACE_REGEX: LazyLock<Regex> = LazyLock::new(|| Regex::new(r":\s+").unwrap());

static CSS_BRACKET_SPACE_REGEX: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r"\s*([{}:;,>+~])\s*").unwrap());

/// Plugin that minifies CSS in style elements and style attributes
pub struct MinifyStylesPlugin;

impl Plugin for MinifyStylesPlugin {
    fn name(&self) -> &'static str {
        "minifyStyles"
    }

    fn description(&self) -> &'static str {
        "Minifies CSS in style elements and style attributes"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()> {
        // Parse parameters
        let remove_comments = params
            .and_then(|v| v.get("comments"))
            .and_then(|v| v.as_bool())
            .unwrap_or(true);

        // Process root element
        minify_styles_in_element(&mut document.root, remove_comments);

        Ok(())
    }
}

/// Recursively minify styles in an element and its children
fn minify_styles_in_element(element: &mut Element, remove_comments: bool) {
    // Process child elements first
    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            minify_styles_in_element(child_element, remove_comments);
        }
    }

    // Minify style elements
    if element.name == "style" {
        minify_style_element_content(element, remove_comments);
    }

    // Minify style attributes
    if element.has_attr("style") {
        if let Some(style_value) = element.attr("style") {
            let minified = minify_css_block(style_value, remove_comments);
            element.set_attr("style".to_string(), minified);
        }
    }
}

/// Minify CSS content in a style element
fn minify_style_element_content(element: &mut Element, remove_comments: bool) {
    let mut modified = false;

    for child in &mut element.children {
        match child {
            Node::Text(text) => {
                let minified = minify_css(text, remove_comments);
                if minified != *text {
                    *text = minified;
                    modified = true;
                }
            }
            Node::CData(cdata) => {
                let minified = minify_css(cdata, remove_comments);
                if minified != *cdata {
                    *cdata = minified;
                    modified = true;
                }
            }
            _ => {}
        }
    }

    // If all CSS content is empty after minification, mark for removal
    if modified {
        let all_empty = element.children.iter().all(|child| match child {
            Node::Text(text) => text.trim().is_empty(),
            Node::CData(cdata) => cdata.trim().is_empty(),
            _ => true,
        });

        if all_empty {
            // Clear the element by removing all children
            element.clear_children();
        }
    }
}

/// Perform basic CSS minification
fn minify_css(css: &str, remove_comments: bool) -> String {
    let mut result = css.to_string();

    // Remove comments if requested
    if remove_comments {
        result = CSS_COMMENT_REGEX.replace_all(&result, "").to_string();
    }

    // Normalize whitespace
    result = CSS_WHITESPACE_REGEX.replace_all(&result, " ").to_string();

    // Remove space around special characters
    result = CSS_BRACKET_SPACE_REGEX
        .replace_all(&result, "$1")
        .to_string();

    // Remove space after colons
    result = CSS_COLON_SPACE_REGEX.replace_all(&result, ":").to_string();

    // Remove unnecessary semicolons before closing braces
    result = CSS_SEMICOLON_REGEX.replace_all(&result, "}").to_string();

    // Remove trailing semicolons
    result = CSS_TRAILING_SEMICOLON_REGEX
        .replace_all(&result, "")
        .to_string();

    // Trim leading and trailing whitespace
    result.trim().to_string()
}

/// Minify a CSS block (for style attributes)
fn minify_css_block(css: &str, remove_comments: bool) -> String {
    let mut result = minify_css(css, remove_comments);

    // For style attributes, ensure there's no trailing semicolon
    if result.ends_with(';') {
        result.pop();
    }

    result
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::ast::Element;
    use indexmap::IndexMap;

    fn create_element(name: &str, attrs: Vec<(&str, &str)>) -> Element {
        let mut attributes = IndexMap::new();
        for (key, value) in attrs {
            attributes.insert(key.to_string(), value.to_string());
        }

        Element {
            name: name.to_string(),
            attributes,
            children: vec![],
            namespaces: Default::default(),
        }
    }

    fn create_style_element(css: &str) -> Element {
        let mut element = create_element("style", vec![]);
        element.add_child(Node::Text(css.to_string()));
        element
    }

    #[test]
    fn test_minify_css_basic() {
        let css = "  body  {  margin : 0 ;  padding : 10px  ;  }  ";
        let expected = "body{margin:0;padding:10px}";
        assert_eq!(minify_css(css, true), expected);
    }

    #[test]
    fn test_minify_css_with_comments() {
        let css = "/* comment */ body { margin: 0; /* another comment */ }";
        let expected = "body{margin:0}";
        assert_eq!(minify_css(css, true), expected);
    }

    #[test]
    fn test_minify_css_preserve_comments() {
        let css = "/* comment */ body { margin: 0; }";
        let result = minify_css(css, false);
        assert!(result.contains("/* comment */"));
        assert!(result.contains("body{margin:0}"));
    }

    #[test]
    fn test_minify_css_block() {
        let css = "margin: 10px; padding: 5px;";
        let expected = "margin:10px;padding:5px";
        assert_eq!(minify_css_block(css, true), expected);
    }

    #[test]
    fn test_minify_css_block_trailing_semicolon() {
        let css = "margin: 10px;";
        let expected = "margin:10px";
        assert_eq!(minify_css_block(css, true), expected);
    }

    #[test]
    fn test_minify_style_element() {
        let mut element = create_style_element("  body  {  margin : 0 ;  }  ");
        minify_style_element_content(&mut element, true);

        if let Some(Node::Text(text)) = element.children.first() {
            assert_eq!(text, "body{margin:0}");
        } else {
            panic!("Expected text content");
        }
    }

    #[test]
    fn test_empty_style_element_removal() {
        let mut element = create_style_element("/* only comments */");
        minify_style_element_content(&mut element, true);

        // Should be empty after removing comments
        assert!(element.children.is_empty());
    }

    #[test]
    fn test_style_attribute_minification() {
        let mut element = create_element("rect", vec![("style", "margin: 10px; padding: 5px;")]);

        minify_styles_in_element(&mut element, true);

        assert_eq!(element.attr("style").unwrap(), "margin:10px;padding:5px");
    }

    #[test]
    fn test_complex_css_minification() {
        let css = r#"
            .class1 { 
                color: red; 
                font-size: 12px; 
            }
            .class2 { 
                background: blue; 
            }
        "#;
        let expected = ".class1{color:red;font-size:12px}.class2{background:blue}";
        assert_eq!(minify_css(css, true), expected);
    }

    #[test]
    fn test_preserve_important() {
        let css = "color: red !important; margin: 0;";
        let result = minify_css(css, true);
        assert!(result.contains("!important"));
        // Note: spaces around !important are preserved (this is correct behavior)
        // The trailing semicolon is removed because it's the end of the declaration
        assert_eq!(result, "color:red !important;margin:0");
    }
}

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/mod.rs
# Language: rust

mod remove_useless_transforms;

mod remove_useless_stroke_and_fill;

mod add_attributes_to_svg_element;

mod add_classes_to_svg_element;

mod cleanup_attrs;

mod cleanup_enable_background;

mod cleanup_ids;

mod cleanup_list_of_values;

mod cleanup_numeric_values;

mod convert_colors;

mod convert_style_to_attrs;

mod merge_styles;

mod remove_attrs;

mod remove_comments;

mod remove_desc;

mod remove_doctype;

mod remove_empty_attrs;

mod remove_empty_containers;

mod remove_empty_text;

mod remove_metadata;

mod remove_style_element;

mod remove_title;

mod remove_unknowns_and_defaults;

mod remove_xml_proc_inst;

mod sort_attrs;

mod remove_attributes_by_selector;

mod collapse_groups;

mod convert_ellipse_to_circle;

mod convert_one_stop_gradients;

mod convert_path_data;

mod convert_shape_to_path;

mod convert_transform;

mod inline_styles;

mod minify_styles;

mod prefix_ids;

mod remove_deprecated_attrs;

mod remove_dimensions;

mod remove_editors_ns_data;

mod remove_elements_by_attr;

mod remove_hidden_elems;

mod remove_non_inheritable_group_attrs;

mod remove_off_canvas_paths;

mod remove_raster_images;

mod remove_scripts;

mod remove_unused_ns;

mod remove_useless_defs;

mod remove_view_box;

mod remove_xlink;

mod remove_xmlns;

mod sort_defs_children;


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs
# Language: rust

mod tests;

struct PrefixIdsConfig {
}

struct PrefixIdsPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attributes_by_selector.rs
# Language: rust

mod tests;

struct RemoveAttributesBySelectorPlugin {
}

struct SelectorConfig {
}

struct RemoveAttributesBySelectorParams {
}

struct ElementWrapper {
}

struct SelectorImpl {
}

struct AttrValue {
}

struct Identifier {
}

struct LocalName {
}

struct NamespaceUrl {
}

struct NamespacePrefix {
}

struct DummyParser {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs
# Language: rust

mod tests;

struct RemoveAttrsPlugin {
}

struct RemoveAttrsParams {
}

struct CompiledPattern {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_comments.rs
# Language: rust

mod tests;

struct RemoveCommentsPlugin {
}


Relative File Path: svgn/src/plugins/remove_deprecated_attrs.rs

```rust
// this_file: svgn/src/plugins/remove_deprecated_attrs.rs

//! Plugin to remove deprecated attributes
//!
//! This plugin removes deprecated SVG attributes from elements. It has a safe mode
//! that removes attributes known to be safe to remove, and an unsafe mode that
//! removes additional deprecated attributes that might affect rendering.

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginError, PluginInfo, PluginResult};
use once_cell::sync::Lazy;
use serde_json::Value;
use std::collections::{HashMap, HashSet};

/// Plugin to remove deprecated attributes
pub struct RemoveDeprecatedAttrsPlugin;

/// Configuration parameters for the plugin
#[derive(Debug, Clone, Default)]
pub struct RemoveDeprecatedAttrsParams {
    /// Whether to remove unsafe deprecated attributes
    pub remove_unsafe: bool,
}

impl RemoveDeprecatedAttrsParams {
    /// Parse parameters from JSON value
    pub fn from_value(value: Option<&Value>) -> PluginResult<Self> {
        let mut params = Self::default();

        if let Some(Value::Object(map)) = value {
            if let Some(remove_unsafe) = map.get("removeUnsafe") {
                params.remove_unsafe = remove_unsafe.as_bool().ok_or_else(|| {
                    PluginError::InvalidConfig("removeUnsafe must be a boolean".to_string())
                })?;
            }
        }

        Ok(params)
    }
}

/// Deprecated attributes grouped by attribute group
static ATTRS_GROUPS_DEPRECATED: Lazy<HashMap<&'static str, DeprecatedAttrs>> = Lazy::new(|| {
    let mut map = HashMap::new();

    map.insert(
        "animationAttributeTarget",
        DeprecatedAttrs {
            safe: HashSet::new(),
            unsafe_attrs: vec!["attributeType"]
                .into_iter()
                .map(String::from)
                .collect(),
        },
    );

    map.insert(
        "conditionalProcessing",
        DeprecatedAttrs {
            safe: HashSet::new(),
            unsafe_attrs: vec!["requiredFeatures"]
                .into_iter()
                .map(String::from)
                .collect(),
        },
    );

    map.insert(
        "core",
        DeprecatedAttrs {
            safe: HashSet::new(),
            unsafe_attrs: vec!["xml:base", "xml:lang", "xml:space"]
                .into_iter()
                .map(String::from)
                .collect(),
        },
    );

    map.insert(
        "presentation",
        DeprecatedAttrs {
            safe: HashSet::new(),
            unsafe_attrs: vec![
                "clip",
                "color-profile",
                "enable-background",
                "glyph-orientation-horizontal",
                "glyph-orientation-vertical",
                "kerning",
            ]
            .into_iter()
            .map(String::from)
            .collect(),
        },
    );

    map
});

/// Element configurations with their attribute groups
static ELEMENT_CONFIGS: Lazy<HashMap<&'static str, ElementConfig>> = Lazy::new(|| {
    let mut map = HashMap::new();

    // Common attribute groups
    let common_groups = vec![
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
    ];

    // Define configurations for various elements
    map.insert(
        "a",
        ElementConfig {
            attrs_groups: common_groups.iter().copied().chain(vec!["xlink"]).collect(),
            deprecated: None,
        },
    );

    map.insert(
        "circle",
        ElementConfig {
            attrs_groups: common_groups.clone().into_iter().collect(),
            deprecated: None,
        },
    );

    map.insert(
        "ellipse",
        ElementConfig {
            attrs_groups: common_groups.clone().into_iter().collect(),
            deprecated: None,
        },
    );

    map.insert(
        "g",
        ElementConfig {
            attrs_groups: common_groups.clone().into_iter().collect(),
            deprecated: None,
        },
    );

    map.insert(
        "image",
        ElementConfig {
            attrs_groups: common_groups.iter().copied().chain(vec!["xlink"]).collect(),
            deprecated: None,
        },
    );

    map.insert(
        "line",
        ElementConfig {
            attrs_groups: common_groups.clone().into_iter().collect(),
            deprecated: None,
        },
    );

    map.insert(
        "path",
        ElementConfig {
            attrs_groups: common_groups.clone().into_iter().collect(),
            deprecated: None,
        },
    );

    map.insert(
        "polygon",
        ElementConfig {
            attrs_groups: common_groups.clone().into_iter().collect(),
            deprecated: None,
        },
    );

    map.insert(
        "polyline",
        ElementConfig {
            attrs_groups: common_groups.clone().into_iter().collect(),
            deprecated: None,
        },
    );

    map.insert(
        "rect",
        ElementConfig {
            attrs_groups: common_groups.clone().into_iter().collect(),
            deprecated: None,
        },
    );

    map.insert(
        "svg",
        ElementConfig {
            attrs_groups: vec![
                "conditionalProcessing",
                "core",
                "documentEvent",
                "graphicalEvent",
                "presentation",
            ]
            .into_iter()
            .collect(),
            deprecated: None,
        },
    );

    map.insert(
        "text",
        ElementConfig {
            attrs_groups: common_groups.clone().into_iter().collect(),
            deprecated: None,
        },
    );

    map.insert(
        "use",
        ElementConfig {
            attrs_groups: common_groups.iter().copied().chain(vec!["xlink"]).collect(),
            deprecated: None,
        },
    );

    // Animation elements
    map.insert(
        "animate",
        ElementConfig {
            attrs_groups: vec![
                "conditionalProcessing",
                "core",
                "animationEvent",
                "xlink",
                "animationAttributeTarget",
                "animationTiming",
                "animationValue",
                "animationAddition",
                "presentation",
            ]
            .into_iter()
            .collect(),
            deprecated: None,
        },
    );

    map.insert(
        "animateTransform",
        ElementConfig {
            attrs_groups: vec![
                "conditionalProcessing",
                "core",
                "animationEvent",
                "xlink",
                "animationAttributeTarget",
                "animationTiming",
                "animationValue",
                "animationAddition",
            ]
            .into_iter()
            .collect(),
            deprecated: None,
        },
    );

    // Add more elements as needed
    map
});

/// Deprecated attributes structure
#[derive(Debug, Clone)]
struct DeprecatedAttrs {
    safe: HashSet<String>,
    unsafe_attrs: HashSet<String>,
}

/// Element configuration
#[derive(Debug, Clone)]
struct ElementConfig {
    attrs_groups: HashSet<&'static str>,
    deprecated: Option<DeprecatedAttrs>,
}

/// Process deprecated attributes on an element
fn process_attributes(
    element: &mut Element,
    deprecated_attrs: &DeprecatedAttrs,
    params: &RemoveDeprecatedAttrsParams,
) {
    // Remove safe deprecated attributes
    for attr_name in &deprecated_attrs.safe {
        element.attributes.shift_remove(attr_name);
    }

    // Remove unsafe deprecated attributes if requested
    if params.remove_unsafe {
        for attr_name in &deprecated_attrs.unsafe_attrs {
            element.attributes.shift_remove(attr_name);
        }
    }
}

/// Process a single element
fn process_element(element: &mut Element, params: &RemoveDeprecatedAttrsParams) {
    // Get element configuration
    if let Some(elem_config) = ELEMENT_CONFIGS.get(element.name.as_str()) {
        // Special case: Remove xml:lang if lang attribute exists
        if elem_config.attrs_groups.contains("core")
            && element.attributes.contains_key("xml:lang")
            && element.attributes.contains_key("lang")
        {
            element.attributes.shift_remove("xml:lang");
        }

        // Process deprecated attributes from attribute groups
        for attrs_group in &elem_config.attrs_groups {
            if let Some(deprecated_attrs) = ATTRS_GROUPS_DEPRECATED.get(attrs_group) {
                process_attributes(element, deprecated_attrs, params);
            }
        }

        // Process element-specific deprecated attributes
        if let Some(ref deprecated) = elem_config.deprecated {
            process_attributes(element, deprecated, params);
        }
    }
}

/// Recursively process nodes
fn process_node(node: &mut Node, params: &RemoveDeprecatedAttrsParams) {
    if let Node::Element(ref mut element) = node {
        process_element(element, params);

        // Process children
        for child in &mut element.children {
            process_node(child, params);
        }
    }
}

impl Plugin for RemoveDeprecatedAttrsPlugin {
    fn name(&self) -> &'static str {
        "removeDeprecatedAttrs"
    }

    fn description(&self) -> &'static str {
        "removes deprecated attributes"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()> {
        let params = RemoveDeprecatedAttrsParams::from_value(params)?;

        // Process root element
        process_element(&mut document.root, &params);

        // Process children
        for child in &mut document.root.children {
            process_node(child, &params);
        }

        Ok(())
    }

    fn validate_params(&self, params: Option<&Value>) -> PluginResult<()> {
        RemoveDeprecatedAttrsParams::from_value(params)?;
        Ok(())
    }
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::ast::{Document, Element, Node};
    use crate::plugin::{Plugin, PluginInfo};
    use indexmap::IndexMap;
    use serde_json::json;

    fn create_test_document() -> Document {
        let mut doc = Document::default();

        let mut svg = Element {
            name: "svg".to_string(),
            namespaces: HashMap::new(),
            attributes: IndexMap::new(),
            children: vec![],
        };
        svg.attributes
            .insert("xml:lang".to_string(), "en".to_string());
        svg.attributes.insert("lang".to_string(), "en".to_string());
        svg.attributes
            .insert("xml:space".to_string(), "preserve".to_string());

        let mut rect = Element {
            name: "rect".to_string(),
            namespaces: HashMap::new(),
            attributes: IndexMap::new(),
            children: vec![],
        };
        rect.attributes.insert("x".to_string(), "0".to_string());
        rect.attributes.insert("y".to_string(), "0".to_string());
        rect.attributes
            .insert("width".to_string(), "100".to_string());
        rect.attributes
            .insert("height".to_string(), "100".to_string());
        rect.attributes
            .insert("enable-background".to_string(), "new".to_string());
        rect.attributes
            .insert("clip".to_string(), "rect(0 0 100 100)".to_string());

        svg.children.push(Node::Element(rect));
        doc.root = svg;
        doc
    }

    #[test]
    fn test_remove_xml_lang_when_lang_exists() {
        let mut doc = create_test_document();
        let mut plugin = RemoveDeprecatedAttrsPlugin;
        let plugin_info = PluginInfo::default();

        plugin.apply(&mut doc, &plugin_info, None).unwrap();

        // xml:lang should be removed because lang exists
        assert_eq!(doc.root.attributes.get("xml:lang"), None);
        assert_eq!(doc.root.attributes.get("lang"), Some(&"en".to_string()));
        // xml:space should still exist (unsafe attribute)
        assert_eq!(
            doc.root.attributes.get("xml:space"),
            Some(&"preserve".to_string())
        );
    }

    #[test]
    fn test_remove_unsafe_attributes() {
        let mut doc = create_test_document();
        let mut plugin = RemoveDeprecatedAttrsPlugin;
        let plugin_info = PluginInfo::default();

        let params = json!({
            "removeUnsafe": true
        });

        plugin.apply(&mut doc, &plugin_info, Some(&params)).unwrap();

        // xml:space should be removed with removeUnsafe
        assert_eq!(doc.root.attributes.get("xml:space"), None);

        // Check rect element - unsafe presentation attributes should be removed
        if let Some(Node::Element(ref rect)) = doc.root.children.first() {
            assert_eq!(rect.attributes.get("enable-background"), None);
            assert_eq!(rect.attributes.get("clip"), None);
            // Regular attributes should remain
            assert_eq!(rect.attributes.get("width"), Some(&"100".to_string()));
        }
    }

    #[test]
    fn test_keep_xml_lang_without_lang() {
        let mut doc = Document::default();

        let mut svg = Element {
            name: "svg".to_string(),
            namespaces: HashMap::new(),
            attributes: IndexMap::new(),
            children: vec![],
        };
        svg.attributes
            .insert("xml:lang".to_string(), "en".to_string());
        // No lang attribute

        doc.root = svg;

        let mut plugin = RemoveDeprecatedAttrsPlugin;
        let plugin_info = PluginInfo::default();

        plugin.apply(&mut doc, &plugin_info, None).unwrap();

        // xml:lang should be kept because lang doesn't exist
        assert_eq!(doc.root.attributes.get("xml:lang"), Some(&"en".to_string()));
    }

    #[test]
    fn test_animation_attribute_target() {
        let mut doc = Document::default();

        let mut svg = Element {
            name: "svg".to_string(),
            namespaces: HashMap::new(),
            attributes: IndexMap::new(),
            children: vec![],
        };

        let mut animate = Element {
            name: "animate".to_string(),
            namespaces: HashMap::new(),
            attributes: IndexMap::new(),
            children: vec![],
        };
        animate
            .attributes
            .insert("attributeType".to_string(), "XML".to_string());
        animate
            .attributes
            .insert("attributeName".to_string(), "x".to_string());

        svg.children.push(Node::Element(animate));
        doc.root = svg;

        let mut plugin = RemoveDeprecatedAttrsPlugin;
        let plugin_info = PluginInfo::default();

        let params = json!({
            "removeUnsafe": true
        });

        plugin.apply(&mut doc, &plugin_info, Some(&params)).unwrap();

        // attributeType is an unsafe deprecated attribute
        if let Some(Node::Element(ref animate)) = doc.root.children.first() {
            assert_eq!(animate.attributes.get("attributeType"), None);
            assert_eq!(
                animate.attributes.get("attributeName"),
                Some(&"x".to_string())
            );
        }
    }
}

```

Relative File Path: svgn/src/plugins/remove_desc.rs

```rust
// this_file: svgn/src/plugins/remove_desc.rs

//! Remove desc plugin
//!
//! This plugin removes <desc> elements from SVG documents.
//! By default, it only removes empty descriptions or those containing standard
//! editor content (e.g., "Created with..."). Can be configured to remove all
//! descriptions.
//! Ported from ref/svgo/plugins/removeDesc.js

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use regex::Regex;
use serde_json::Value;
use std::sync::LazyLock;

/// Plugin that removes <desc> elements
pub struct RemoveDescPlugin;

// Regex pattern for standard editor descriptions
static STANDARD_DESCS: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r"^(Created with|Created using)").unwrap());

impl Plugin for RemoveDescPlugin {
    fn name(&self) -> &'static str {
        "removeDesc"
    }

    fn description(&self) -> &'static str {
        "Remove <desc> elements"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()> {
        // Parse parameters
        let remove_any = params
            .and_then(|v| v.get("removeAny"))
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        // Process the document
        remove_desc_from_element(&mut document.root, remove_any);

        Ok(())
    }
}

/// Recursively remove <desc> elements from an element and its descendants
fn remove_desc_from_element(element: &mut Element, remove_any: bool) {
    // Filter out desc elements based on criteria
    element.children.retain(|child| {
        match child {
            Node::Element(child_element) if child_element.name == "desc" => {
                // Keep the desc element if we should not remove it
                !should_remove_desc(child_element, remove_any)
            }
            _ => true,
        }
    });

    // Process remaining child elements
    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            remove_desc_from_element(child_element, remove_any);
        }
    }
}

/// Check if a desc element should be removed
fn should_remove_desc(desc_element: &Element, remove_any: bool) -> bool {
    if remove_any {
        return true;
    }

    // Remove if empty
    if desc_element.children.is_empty() {
        return true;
    }

    // Check if it contains only standard editor text
    if desc_element.children.len() == 1 {
        if let Some(Node::Text(text)) = desc_element.children.first() {
            if STANDARD_DESCS.is_match(text) {
                return true;
            }
        }
    }

    false
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::parser::Parser;
    use serde_json::json;

    #[test]
    fn test_remove_empty_desc() {
        let svg = r#"<svg xmlns="http://www.w3.org/2000/svg">
            <desc></desc>
            <rect width="100" height="100"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = RemoveDescPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Check that empty desc is removed
        assert!(!has_desc_element(&document.root));
    }

    #[test]
    fn test_remove_standard_desc() {
        let svg = r#"<svg xmlns="http://www.w3.org/2000/svg">
            <desc>Created with Sketch.</desc>
            <rect width="100" height="100"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = RemoveDescPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Check that standard desc is removed
        assert!(!has_desc_element(&document.root));
    }

    #[test]
    fn test_preserve_custom_desc() {
        let svg = r#"<svg xmlns="http://www.w3.org/2000/svg">
            <desc>This is a custom description for accessibility</desc>
            <rect width="100" height="100"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = RemoveDescPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Check that custom desc is preserved
        assert!(has_desc_element(&document.root));
    }

    #[test]
    fn test_remove_any() {
        let svg = r#"<svg xmlns="http://www.w3.org/2000/svg">
            <desc>This is a custom description for accessibility</desc>
            <rect width="100" height="100"/>
        </svg>"#;

        let parser = Parser::new();
        let mut document = parser.parse(svg).unwrap();

        let mut plugin = RemoveDescPlugin;
        let params = json!({"removeAny": true});
        plugin
            .apply(
                &mut document,
                &crate::plugin::PluginInfo::default(),
                Some(&params),
            )
            .unwrap();

        // Check that all desc elements are removed
        assert!(!has_desc_element(&document.root));
    }

    fn has_desc_element(element: &Element) -> bool {
        for child in &element.children {
            if let Node::Element(child_element) = child {
                if child_element.name == "desc" {
                    return true;
                }
                if has_desc_element(child_element) {
                    return true;
                }
            }
        }
        false
    }
}

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs
# Language: rust

mod tests;

struct RemoveDimensionsPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_doctype.rs
# Language: rust

mod tests;

struct RemoveDoctypePlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs
# Language: rust

mod tests;

struct RemoveEditorsNSDataConfig {
}

struct RemoveEditorsNSDataPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs
# Language: rust

mod tests;

struct RemoveElementsByAttrConfig {
}

struct RemoveElementsByAttrPlugin {
}


Relative File Path: svgn/src/plugins/remove_empty_attrs.rs

```rust
// this_file: svgn/src/plugins/remove_empty_attrs.rs

//! Plugin to remove attributes with empty values
//!
//! Removes attributes that have empty string values, which are generally
//! unnecessary. However, preserves conditional processing attributes where
//! empty values have semantic meaning (prevent element rendering).

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use serde_json::Value;
use std::collections::HashSet;
use std::sync::LazyLock;

/// Set of conditional processing attributes that should be preserved even when empty
/// as they have semantic meaning for element rendering
static CONDITIONAL_PROCESSING_ATTRS: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {
    ["requiredExtensions", "requiredFeatures", "systemLanguage"]
        .into_iter()
        .collect()
});

/// Plugin to remove attributes with empty values
pub struct RemoveEmptyAttrsPlugin;

impl Plugin for RemoveEmptyAttrsPlugin {
    fn name(&self) -> &'static str {
        "removeEmptyAttrs"
    }

    fn description(&self) -> &'static str {
        "removes empty attributes"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        _params: Option<&Value>,
    ) -> PluginResult<()> {
        visit_elements(&mut document.root, remove_empty_attrs);
        Ok(())
    }
}

/// Visit all elements in the AST and apply the transformation function
fn visit_elements(element: &mut Element, transform: fn(&mut Element)) {
    transform(element);

    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            visit_elements(child_element, transform);
        }
    }
}

/// Remove empty attributes from an element, preserving conditional processing attributes
fn remove_empty_attrs(element: &mut Element) {
    element.attributes.retain(|name, value| {
        // Preserve conditional processing attributes even if empty
        if CONDITIONAL_PROCESSING_ATTRS.contains(name.as_str()) {
            return true;
        }

        // Remove attributes with empty values
        !value.is_empty()
    });
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::ast::{Document, Element, Node};

    #[test]
    fn test_removes_empty_attributes() {
        let mut document = Document::new();
        let mut element = Element::new("rect");

        // Add some attributes, including empty ones
        element
            .attributes
            .insert("width".to_string(), "100".to_string());
        element
            .attributes
            .insert("height".to_string(), "".to_string()); // empty
        element
            .attributes
            .insert("fill".to_string(), "red".to_string());
        element
            .attributes
            .insert("stroke".to_string(), "".to_string()); // empty

        document.root = element;

        let mut plugin = RemoveEmptyAttrsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Should keep non-empty attributes
        assert!(document.root.attributes.contains_key("width"));
        assert!(document.root.attributes.contains_key("fill"));

        // Should remove empty attributes
        assert!(!document.root.attributes.contains_key("height"));
        assert!(!document.root.attributes.contains_key("stroke"));
    }

    #[test]
    fn test_preserves_conditional_processing_attrs() {
        let mut document = Document::new();
        let mut element = Element::new("rect");

        // Add conditional processing attributes with empty values
        element
            .attributes
            .insert("requiredExtensions".to_string(), "".to_string());
        element
            .attributes
            .insert("requiredFeatures".to_string(), "".to_string());
        element
            .attributes
            .insert("systemLanguage".to_string(), "".to_string());
        element
            .attributes
            .insert("width".to_string(), "".to_string()); // regular empty attr

        document.root = element;

        let mut plugin = RemoveEmptyAttrsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Should preserve conditional processing attributes even when empty
        assert!(document.root.attributes.contains_key("requiredExtensions"));
        assert!(document.root.attributes.contains_key("requiredFeatures"));
        assert!(document.root.attributes.contains_key("systemLanguage"));

        // Should remove regular empty attributes
        assert!(!document.root.attributes.contains_key("width"));
    }

    #[test]
    fn test_nested_elements() {
        let mut document = Document::new();
        let mut root = Element::new("svg");
        let mut child = Element::new("g");

        // Add empty attributes to both elements
        root.attributes
            .insert("width".to_string(), "100".to_string());
        root.attributes.insert("height".to_string(), "".to_string()); // empty

        child
            .attributes
            .insert("fill".to_string(), "red".to_string());
        child
            .attributes
            .insert("stroke".to_string(), "".to_string()); // empty

        root.children.push(Node::Element(child));
        document.root = root;

        let mut plugin = RemoveEmptyAttrsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Check root element
        assert!(document.root.attributes.contains_key("width"));
        assert!(!document.root.attributes.contains_key("height"));

        // Check child element
        if let Node::Element(child_element) = &document.root.children[0] {
            assert!(child_element.attributes.contains_key("fill"));
            assert!(!child_element.attributes.contains_key("stroke"));
        } else {
            panic!("Expected child element");
        }
    }

    #[test]
    fn test_no_attributes() {
        let mut document = Document::new();
        let element = Element::new("rect");
        document.root = element;

        let mut plugin = RemoveEmptyAttrsPlugin;
        let result = plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None);

        assert!(result.is_ok());
        assert!(document.root.attributes.is_empty());
    }

    #[test]
    fn test_plugin_name_and_description() {
        let mut plugin = RemoveEmptyAttrsPlugin;
        assert_eq!(plugin.name(), "removeEmptyAttrs");
        assert_eq!(plugin.description(), "removes empty attributes");
    }
}

```

Relative File Path: svgn/src/plugins/remove_empty_containers.rs

```rust
// this_file: svgn/src/plugins/remove_empty_containers.rs

//! Plugin to remove empty container elements
//!
//! Removes container elements that have no children, with special handling
//! for certain cases where empty containers have semantic meaning.

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use serde_json::Value;
use std::collections::HashSet;
use std::sync::LazyLock;

/// Set of SVG container elements that can be removed when empty
/// Based on https://www.w3.org/TR/SVG11/intro.html#TermContainerElement
static CONTAINER_ELEMENTS: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {
    [
        "a",
        "defs",
        "foreignObject",
        "g",
        "marker",
        "mask",
        "missing-glyph",
        "pattern",
        "svg",
        "switch",
        "symbol",
    ]
    .into_iter()
    .collect()
});

/// Plugin to remove empty container elements
pub struct RemoveEmptyContainersPlugin;

impl Plugin for RemoveEmptyContainersPlugin {
    fn name(&self) -> &'static str {
        "removeEmptyContainers"
    }

    fn description(&self) -> &'static str {
        "removes empty container elements"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        _params: Option<&Value>,
    ) -> PluginResult<()> {
        // Process the tree bottom-up to handle nested containers correctly
        remove_empty_containers(&mut document.root, None);
        Ok(())
    }
}

/// Remove empty containers from the tree, processing children first
fn remove_empty_containers(element: &mut Element, _parent_name: Option<&str>) {
    // First, recursively process all child elements
    for child in &mut element.children {
        if let Node::Element(child_element) = child {
            remove_empty_containers(child_element, Some(&element.name));
        }
    }

    // Then remove empty container children from this element
    element.children.retain(|child| {
        if let Node::Element(child_element) = child {
            !should_remove_empty_container(child_element, Some(&element.name))
        } else {
            true // Keep non-element nodes (text, comments)
        }
    });
}

/// Determine if an empty container element should be removed
fn should_remove_empty_container(element: &Element, parent_name: Option<&str>) -> bool {
    // Only consider container elements
    if !CONTAINER_ELEMENTS.contains(element.name.as_str()) {
        return false;
    }

    // Must be empty (no children)
    if !element.children.is_empty() {
        return false;
    }

    // Don't remove root SVG elements
    if element.name == "svg" {
        return false;
    }

    // Empty patterns may contain reusable configuration
    if element.name == "pattern" && !element.attributes.is_empty() {
        return false;
    }

    // Empty <mask> with ID hides masked element
    if element.name == "mask" && element.attributes.contains_key("id") {
        return false;
    }

    // Don't remove elements that are direct children of <switch>
    if parent_name == Some("switch") {
        return false;
    }

    // The <g> may not have content, but the filter may cause a rectangle
    // to be created and filled with pattern
    if element.name == "g" && element.attributes.contains_key("filter") {
        return false;
    }

    // If we get here, it's safe to remove this empty container
    true
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::ast::{Document, Element, Node};

    #[test]
    fn test_removes_empty_defs() {
        let mut document = Document::new();
        let mut root = Element::new("svg");
        let empty_defs = Element::new("defs");

        root.children.push(Node::Element(empty_defs));
        document.root = root;

        let mut plugin = RemoveEmptyContainersPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Empty defs should be removed
        assert!(document.root.children.is_empty());
    }

    #[test]
    fn test_removes_empty_g() {
        let mut document = Document::new();
        let mut root = Element::new("svg");
        let empty_g = Element::new("g");

        root.children.push(Node::Element(empty_g));
        document.root = root;

        let mut plugin = RemoveEmptyContainersPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Empty g should be removed
        assert!(document.root.children.is_empty());
    }

    #[test]
    fn test_preserves_svg_root() {
        let mut document = Document::new();
        let root = Element::new("svg");
        document.root = root;

        let mut plugin = RemoveEmptyContainersPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // SVG root should never be removed even if empty
        assert_eq!(document.root.name, "svg");
    }

    #[test]
    fn test_preserves_pattern_with_attributes() {
        let mut document = Document::new();
        let mut root = Element::new("svg");
        let mut pattern = Element::new("pattern");
        pattern
            .attributes
            .insert("id".to_string(), "mypattern".to_string());

        root.children.push(Node::Element(pattern));
        document.root = root;

        let mut plugin = RemoveEmptyContainersPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Pattern with attributes should be preserved
        assert_eq!(document.root.children.len(), 1);
        if let Node::Element(child) = &document.root.children[0] {
            assert_eq!(child.name, "pattern");
        }
    }

    #[test]
    fn test_preserves_mask_with_id() {
        let mut document = Document::new();
        let mut root = Element::new("svg");
        let mut mask = Element::new("mask");
        mask.attributes
            .insert("id".to_string(), "mymask".to_string());

        root.children.push(Node::Element(mask));
        document.root = root;

        let mut plugin = RemoveEmptyContainersPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Mask with ID should be preserved
        assert_eq!(document.root.children.len(), 1);
        if let Node::Element(child) = &document.root.children[0] {
            assert_eq!(child.name, "mask");
        }
    }

    #[test]
    fn test_preserves_g_with_filter() {
        let mut document = Document::new();
        let mut root = Element::new("svg");
        let mut g = Element::new("g");
        g.attributes
            .insert("filter".to_string(), "url(#myfilter)".to_string());

        root.children.push(Node::Element(g));
        document.root = root;

        let mut plugin = RemoveEmptyContainersPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Group with filter should be preserved
        assert_eq!(document.root.children.len(), 1);
        if let Node::Element(child) = &document.root.children[0] {
            assert_eq!(child.name, "g");
        }
    }

    #[test]
    fn test_preserves_elements_in_switch() {
        let mut document = Document::new();
        let mut root = Element::new("svg");
        let mut switch = Element::new("switch");
        let empty_g = Element::new("g");

        switch.children.push(Node::Element(empty_g));
        root.children.push(Node::Element(switch));
        document.root = root;

        let mut plugin = RemoveEmptyContainersPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Elements in switch should be preserved
        assert_eq!(document.root.children.len(), 1);
        if let Node::Element(switch_elem) = &document.root.children[0] {
            assert_eq!(switch_elem.name, "switch");
            assert_eq!(switch_elem.children.len(), 1);
        }
    }

    #[test]
    fn test_removes_nested_empty_containers() {
        let mut document = Document::new();
        let mut root = Element::new("svg");
        let mut outer_g = Element::new("g");
        let inner_g = Element::new("g");

        outer_g.children.push(Node::Element(inner_g));
        root.children.push(Node::Element(outer_g));
        document.root = root;

        let mut plugin = RemoveEmptyContainersPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Both nested empty containers should be removed
        assert!(document.root.children.is_empty());
    }

    #[test]
    fn test_keeps_non_container_elements() {
        let mut document = Document::new();
        let mut root = Element::new("svg");
        let rect = Element::new("rect");
        let empty_g = Element::new("g");

        root.children.push(Node::Element(rect));
        root.children.push(Node::Element(empty_g));
        document.root = root;

        let mut plugin = RemoveEmptyContainersPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        // Should keep rect and remove empty g
        assert_eq!(document.root.children.len(), 1);
        if let Node::Element(child) = &document.root.children[0] {
            assert_eq!(child.name, "rect");
        }
    }

    #[test]
    fn test_plugin_name_and_description() {
        let mut plugin = RemoveEmptyContainersPlugin;
        assert_eq!(plugin.name(), "removeEmptyContainers");
        assert_eq!(plugin.description(), "removes empty container elements");
    }
}

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs
# Language: rust

mod tests;

struct RemoveEmptyTextPlugin {
}

struct RemoveEmptyTextParams {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs
# Language: rust

mod tests;

struct RemoveHiddenElemsConfig {
}

struct RemoveHiddenElemsPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_metadata.rs
# Language: rust

mod tests;

struct RemoveMetadataPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs
# Language: rust

mod tests;

struct RemoveNonInheritableGroupAttrsPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs
# Language: rust

mod tests;

struct ViewBox {
}

struct RemoveOffCanvasPathsPlugin {
}


Relative File Path: svgn/src/plugins/remove_raster_images.rs

```rust
// this_file: svgn/src/plugins/remove_raster_images.rs

//! Plugin to remove raster image references
//!
//! This plugin removes `<image>` elements that reference raster images (JPEG, PNG, GIF).
//! This is useful when you want a pure vector SVG without embedded or linked bitmaps.

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use once_cell::sync::Lazy;
use regex::Regex;
use serde_json::Value;

/// Regex to detect raster image references
static RASTER_IMAGE_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"(\.|image/)(jpe?g|png|gif)").unwrap());

/// Plugin to remove raster image references (disabled by default)
pub struct RemoveRasterImagesPlugin;

impl Plugin for RemoveRasterImagesPlugin {
    fn name(&self) -> &'static str {
        "removeRasterImages"
    }

    fn description(&self) -> &'static str {
        "removes raster images (disabled by default)"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _info: &PluginInfo,
        _params: Option<&Value>,
    ) -> PluginResult<()> {
        self.process_element(&mut document.root);
        Ok(())
    }
}

impl RemoveRasterImagesPlugin {
    fn process_element(&self, element: &mut Element) {
        // Filter out raster image elements
        element.children.retain(|child| {
            if let Node::Element(ref elem) = child {
                !self.is_raster_image(elem)
            } else {
                true
            }
        });

        // Process remaining children recursively
        for child in &mut element.children {
            if let Node::Element(ref mut elem) = child {
                self.process_element(elem);
            }
        }
    }

    fn is_raster_image(&self, element: &Element) -> bool {
        if element.name != "image" {
            return false;
        }

        // Check both xlink:href and href attributes
        for attr_name in ["xlink:href", "href"] {
            if let Some(href_value) = element.attributes.get(attr_name) {
                if RASTER_IMAGE_REGEX.is_match(href_value) {
                    return true;
                }
            }
        }

        false
    }
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::ast::{Document, Element, Node};
    use indexmap::IndexMap;
    use std::collections::HashMap;

    fn create_test_document() -> Document {
        Document {
            root: Element {
                name: "svg".to_string(),
                attributes: IndexMap::new(),
                namespaces: HashMap::new(),
                children: vec![],
            },
            ..Default::default()
        }
    }

    fn create_image_element(href_attr: &str, href_value: &str) -> Element {
        let mut attributes = IndexMap::new();
        attributes.insert(href_attr.to_string(), href_value.to_string());
        attributes.insert("width".to_string(), "100".to_string());
        attributes.insert("height".to_string(), "100".to_string());

        Element {
            name: "image".to_string(),
            attributes,
            namespaces: HashMap::new(),
            children: vec![],
        }
    }

    #[test]
    fn test_plugin_name_and_description() {
        let plugin = RemoveRasterImagesPlugin;
        assert_eq!(plugin.name(), "removeRasterImages");
        assert_eq!(
            plugin.description(),
            "removes raster images (disabled by default)"
        );
    }

    #[test]
    fn test_remove_jpeg_image() {
        let mut document = create_test_document();

        document.root.children = vec![
            Node::Element(create_image_element("xlink:href", "photo.jpg")),
            Node::Element(create_image_element("xlink:href", "image.jpeg")),
        ];

        let mut plugin = RemoveRasterImagesPlugin;
        let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
        assert!(result.is_ok());

        // Both JPEG images should be removed
        assert_eq!(document.root.children.len(), 0);
    }

    #[test]
    fn test_remove_png_image() {
        let mut document = create_test_document();

        document.root.children = vec![
            Node::Element(create_image_element("xlink:href", "icon.png")),
            Node::Element(create_image_element("href", "logo.png")),
        ];

        let mut plugin = RemoveRasterImagesPlugin;
        let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
        assert!(result.is_ok());

        // Both PNG images should be removed
        assert_eq!(document.root.children.len(), 0);
    }

    #[test]
    fn test_remove_gif_image() {
        let mut document = create_test_document();

        document.root.children = vec![Node::Element(create_image_element(
            "xlink:href",
            "animation.gif",
        ))];

        let mut plugin = RemoveRasterImagesPlugin;
        let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
        assert!(result.is_ok());

        // GIF image should be removed
        assert_eq!(document.root.children.len(), 0);
    }

    #[test]
    fn test_remove_data_uri_images() {
        let mut document = create_test_document();

        document.root.children = vec![
            Node::Element(create_image_element(
                "xlink:href",
                "data:image/jpeg;base64,/9j/4AAQ...",
            )),
            Node::Element(create_image_element(
                "href",
                "data:image/png;base64,iVBORw0KGgo...",
            )),
        ];

        let mut plugin = RemoveRasterImagesPlugin;
        let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
        assert!(result.is_ok());

        // Data URI raster images should be removed
        assert_eq!(document.root.children.len(), 0);
    }

    #[test]
    fn test_preserve_svg_images() {
        let mut document = create_test_document();

        document.root.children = vec![
            Node::Element(create_image_element("xlink:href", "icon.svg")),
            Node::Element(create_image_element("href", "#symbol1")),
            Node::Element(create_image_element("xlink:href", "drawing.svgz")),
        ];

        let mut plugin = RemoveRasterImagesPlugin;
        let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
        assert!(result.is_ok());

        // SVG images should be preserved
        assert_eq!(document.root.children.len(), 3);
    }

    #[test]
    fn test_preserve_non_image_elements() {
        let mut document = create_test_document();

        let mut rect_attrs = IndexMap::new();
        rect_attrs.insert("xlink:href".to_string(), "photo.jpg".to_string());

        let rect_element = Element {
            name: "rect".to_string(),
            attributes: rect_attrs,
            namespaces: HashMap::new(),
            children: vec![],
        };

        document.root.children = vec![
            Node::Element(rect_element),
            Node::Element(create_image_element("xlink:href", "icon.svg")),
        ];

        let mut plugin = RemoveRasterImagesPlugin;
        let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
        assert!(result.is_ok());

        // Non-image elements should be preserved even with raster hrefs
        assert_eq!(document.root.children.len(), 2);
    }

    #[test]
    fn test_case_sensitivity() {
        let mut document = create_test_document();

        document.root.children = vec![
            Node::Element(create_image_element("xlink:href", "photo.JPG")),
            Node::Element(create_image_element("xlink:href", "image.JPEG")),
            Node::Element(create_image_element("xlink:href", "icon.PNG")),
            Node::Element(create_image_element("xlink:href", "anim.GIF")),
        ];

        let mut plugin = RemoveRasterImagesPlugin;
        let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
        assert!(result.is_ok());

        // The regex is case-sensitive, so uppercase extensions are preserved
        assert_eq!(document.root.children.len(), 4);
    }

    #[test]
    fn test_nested_images() {
        let mut document = create_test_document();

        let g_element = Element {
            name: "g".to_string(),
            attributes: IndexMap::new(),
            namespaces: HashMap::new(),
            children: vec![
                Node::Element(create_image_element("xlink:href", "photo1.jpg")),
                Node::Element(create_image_element("href", "icon.svg")),
                Node::Element(create_image_element("xlink:href", "photo2.png")),
            ],
        };

        document.root.children = vec![Node::Element(g_element)];

        let mut plugin = RemoveRasterImagesPlugin;
        let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
        assert!(result.is_ok());

        // Only SVG image should remain in the group
        if let Node::Element(ref g) = document.root.children[0] {
            assert_eq!(g.children.len(), 1);
            if let Node::Element(ref img) = g.children[0] {
                assert_eq!(img.attributes.get("href"), Some(&"icon.svg".to_string()));
            } else {
                panic!("Expected image element");
            }
        } else {
            panic!("Expected g element");
        }
    }

    #[test]
    fn test_url_with_path() {
        let mut document = create_test_document();

        document.root.children = vec![
            Node::Element(create_image_element("xlink:href", "/images/photo.jpg")),
            Node::Element(create_image_element(
                "href",
                "https://example.com/image.png",
            )),
            Node::Element(create_image_element("xlink:href", "../assets/banner.gif")),
        ];

        let mut plugin = RemoveRasterImagesPlugin;
        let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
        assert!(result.is_ok());

        // All raster images with paths should be removed
        assert_eq!(document.root.children.len(), 0);
    }
}

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs
# Language: rust

mod tests;

struct RemoveScriptsPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs
# Language: rust

mod tests;

struct RemoveStyleElement {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_title.rs
# Language: rust

mod tests;

struct RemoveTitlePlugin {
}


Relative File Path: svgn/src/plugins/remove_unknowns_and_defaults.rs

```rust
// this_file: svgn/src/plugins/remove_unknowns_and_defaults.rs

//! Plugin to remove unknown elements and attributes, and attributes with default values
//!
//! This is a simplified implementation that handles common cases without full SVG spec data.
//! Future versions will include complete SVG specification compliance.

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use serde_json::Value;
use std::collections::{HashMap, HashSet};
use std::sync::LazyLock;

/// Plugin to remove unknown elements and attributes, and default values
pub struct RemoveUnknownsAndDefaultsPlugin;

/// Configuration parameters for removing unknowns and defaults
#[derive(Debug, Clone)]
pub struct RemoveUnknownsAndDefaultsParams {
    /// Remove unknown element content
    pub unknown_content: bool,
    /// Remove unknown attributes
    pub unknown_attrs: bool,
    /// Remove attributes with default values
    pub default_attrs: bool,
    /// Remove default markup declarations
    pub default_markup_declarations: bool,
    /// Remove useless attribute overrides
    pub useless_overrides: bool,
    /// Keep data-* attributes
    pub keep_data_attrs: bool,
    /// Keep aria-* attributes
    pub keep_aria_attrs: bool,
    /// Keep role attribute
    pub keep_role_attr: bool,
}

impl Default for RemoveUnknownsAndDefaultsParams {
    fn default() -> Self {
        Self {
            unknown_content: true,
            unknown_attrs: true,
            default_attrs: true,
            default_markup_declarations: true,
            useless_overrides: true,
            keep_data_attrs: true,
            keep_aria_attrs: true,
            keep_role_attr: false,
        }
    }
}

impl RemoveUnknownsAndDefaultsParams {
    /// Parse parameters from JSON value
    pub fn from_value(value: Option<&Value>) -> Self {
        let mut params = Self::default();

        if let Some(Value::Object(map)) = value {
            if let Some(Value::Bool(val)) = map.get("unknownContent") {
                params.unknown_content = *val;
            }
            if let Some(Value::Bool(val)) = map.get("unknownAttrs") {
                params.unknown_attrs = *val;
            }
            if let Some(Value::Bool(val)) = map.get("defaultAttrs") {
                params.default_attrs = *val;
            }
            if let Some(Value::Bool(val)) = map.get("defaultMarkupDeclarations") {
                params.default_markup_declarations = *val;
            }
            if let Some(Value::Bool(val)) = map.get("uselessOverrides") {
                params.useless_overrides = *val;
            }
            if let Some(Value::Bool(val)) = map.get("keepDataAttrs") {
                params.keep_data_attrs = *val;
            }
            if let Some(Value::Bool(val)) = map.get("keepAriaAttrs") {
                params.keep_aria_attrs = *val;
            }
            if let Some(Value::Bool(val)) = map.get("keepRoleAttr") {
                params.keep_role_attr = *val;
            }
        }

        params
    }
}

// Common SVG elements (simplified list)
static KNOWN_ELEMENTS: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {
    [
        // Root
        "svg",
        // Structural
        "defs",
        "g",
        "symbol",
        "use",
        // Shape elements
        "circle",
        "ellipse",
        "line",
        "path",
        "polygon",
        "polyline",
        "rect",
        // Text elements
        "text",
        "tspan",
        "tref",
        "textPath",
        // Paint server elements
        "linearGradient",
        "radialGradient",
        "pattern",
        // Container elements
        "a",
        "marker",
        "mask",
        "clipPath",
        "foreignObject",
        "switch",
        // Filter elements
        "filter",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feFlood",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "feSpecularLighting",
        "feTile",
        "feTurbulence",
        // Animation elements
        "animate",
        "animateTransform",
        "animateMotion",
        "set",
        // Descriptive elements
        "desc",
        "title",
        "metadata",
        // Other elements
        "image",
        "stop",
        "script",
        "style",
    ]
    .into_iter()
    .collect()
});

// Common SVG attributes (simplified list)
static KNOWN_ATTRIBUTES: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {
    [
        // Core attributes
        "id",
        "class",
        "style",
        "lang",
        "tabindex",
        // Geometry attributes
        "x",
        "y",
        "x1",
        "y1",
        "x2",
        "y2",
        "cx",
        "cy",
        "r",
        "rx",
        "ry",
        "width",
        "height",
        "viewBox",
        "d",
        "points",
        "pathLength",
        // Presentation attributes
        "fill",
        "stroke",
        "stroke-width",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-opacity",
        "fill-opacity",
        "opacity",
        "color",
        "font-family",
        "font-size",
        "font-weight",
        "text-anchor",
        "visibility",
        "display",
        "overflow",
        "clip",
        "clip-path",
        "clip-rule",
        "mask",
        "filter",
        "transform",
        "transform-origin",
        // Animation attributes
        "begin",
        "dur",
        "end",
        "repeatCount",
        "repeatDur",
        "from",
        "to",
        "by",
        "values",
        "attributeName",
        "attributeType",
        "calcMode",
        "keyTimes",
        "keySplines",
        // Link attributes
        "href",
        "target",
        // Gradient attributes
        "gradientUnits",
        "gradientTransform",
        "x1",
        "y1",
        "x2",
        "y2",
        "fx",
        "fy",
        "spreadMethod",
        "stop-color",
        "stop-opacity",
        "offset",
        // Pattern attributes
        "patternUnits",
        "patternContentUnits",
        "patternTransform",
        // Filter attributes
        "filterUnits",
        "primitiveUnits",
        "result",
        "in",
        "in2",
        // Text attributes
        "text-rendering",
        "font-style",
        "font-variant",
        "text-decoration",
        "writing-mode",
        "glyph-orientation-vertical",
        "glyph-orientation-horizontal",
        // Other common attributes
        "preserveAspectRatio",
        "version",
        "xmlns",
        "xmlns:xlink",
        "xml:space",
    ]
    .into_iter()
    .collect()
});

// Default attribute values (simplified list)
static DEFAULT_ATTRIBUTE_VALUES: LazyLock<HashMap<&'static str, &'static str>> =
    LazyLock::new(|| {
        [
            ("x", "0"),
            ("y", "0"),
            ("fill", "#000000"),
            ("fill", "black"),
            ("stroke", "none"),
            ("stroke-width", "1"),
            ("stroke-linecap", "butt"),
            ("stroke-linejoin", "miter"),
            ("stroke-dasharray", "none"),
            ("stroke-dashoffset", "0"),
            ("stroke-opacity", "1"),
            ("fill-opacity", "1"),
            ("opacity", "1"),
            ("visibility", "visible"),
            ("display", "inline"),
            ("overflow", "visible"),
            ("clip-rule", "nonzero"),
            ("font-size", "medium"),
            ("font-weight", "normal"),
            ("font-style", "normal"),
            ("text-anchor", "start"),
            ("text-decoration", "none"),
            ("preserveAspectRatio", "xMidYMid meet"),
            ("gradientUnits", "objectBoundingBox"),
            ("spreadMethod", "pad"),
            ("patternUnits", "objectBoundingBox"),
            ("patternContentUnits", "userSpaceOnUse"),
            ("filterUnits", "objectBoundingBox"),
            ("primitiveUnits", "userSpaceOnUse"),
        ]
        .into_iter()
        .collect()
    });

impl Plugin for RemoveUnknownsAndDefaultsPlugin {
    fn name(&self) -> &'static str {
        "removeUnknownsAndDefaults"
    }

    fn description(&self) -> &'static str {
        "removes unknown elements content and attributes, removes attrs with default values"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()> {
        let config = RemoveUnknownsAndDefaultsParams::from_value(params);

        // Process XML declaration if needed
        if config.default_markup_declarations {
            process_xml_declaration(&mut document.metadata);
        }

        visit_elements(&mut document.root, &config, None);
        Ok(())
    }
}

/// Process XML declaration to remove default values
fn process_xml_declaration(metadata: &mut crate::ast::DocumentMetadata) {
    // Remove standalone="no" from version string if present
    if let Some(version) = &metadata.version {
        let cleaned = version
            .replace(" standalone=\"no\"", "")
            .replace(" standalone='no'", "");
        if cleaned != *version {
            metadata.version = Some(cleaned);
        }
    }
}

/// Visit all elements in the AST and remove unknowns and defaults
fn visit_elements(
    element: &mut Element,
    config: &RemoveUnknownsAndDefaultsParams,
    parent_element: Option<&Element>,
) {
    remove_unknown_and_default_attributes(element, config, parent_element);

    // First, collect indices of children to remove and process remaining children
    let mut children_to_remove = Vec::new();
    let mut child_elements_to_process = Vec::new();

    for (index, child) in element.children.iter().enumerate() {
        if let Node::Element(child_element) = child {
            // Check if this element should be removed
            if config.unknown_content && should_remove_unknown_element(child_element) {
                children_to_remove.push(index);
            } else if child_element.name != "foreignObject" {
                // Skip processing children of foreignObject
                child_elements_to_process.push(index);
            }
        }
    }

    // Remove unknown elements (in reverse order to maintain indices)
    for &index in children_to_remove.iter().rev() {
        element.children.remove(index);
    }

    // Now process the remaining child elements
    for &index in &child_elements_to_process {
        if let Some(Node::Element(child_element)) = element.children.get_mut(index) {
            // We need to collect parent attributes first to avoid borrowing issues
            let parent_attrs = element.attributes.clone();
            let parent_name = element.name.clone();

            // Create a temporary parent element for reference
            let mut temp_parent = Element::new(&parent_name);
            temp_parent.attributes = parent_attrs;

            visit_elements(child_element, config, Some(&temp_parent));
        }
    }
}

/// Check if an element should be removed as unknown
fn should_remove_unknown_element(element: &Element) -> bool {
    // Skip namespaced elements
    if element.name.contains(':') {
        return false;
    }

    // Check if it's a known SVG element
    !KNOWN_ELEMENTS.contains(element.name.as_str())
}

/// Remove unknown and default attributes from a single element
fn remove_unknown_and_default_attributes(
    element: &mut Element,
    config: &RemoveUnknownsAndDefaultsParams,
    parent_element: Option<&Element>,
) {
    let mut attrs_to_remove = Vec::new();

    for (attr_name, attr_value) in &element.attributes {
        let should_remove =
            should_remove_attribute(attr_name, attr_value, element, config, parent_element);

        if should_remove {
            attrs_to_remove.push(attr_name.clone());
        }
    }

    // Remove the attributes
    for attr_name in attrs_to_remove {
        element.attributes.shift_remove(&attr_name);
    }
}

/// Determine if an attribute should be removed
fn should_remove_attribute(
    attr_name: &str,
    attr_value: &str,
    element: &Element,
    config: &RemoveUnknownsAndDefaultsParams,
    parent_element: Option<&Element>,
) -> bool {
    // Keep data-* attributes if configured
    if config.keep_data_attrs && attr_name.starts_with("data-") {
        return false;
    }

    // Keep aria-* attributes if configured
    if config.keep_aria_attrs && attr_name.starts_with("aria-") {
        return false;
    }

    // Keep role attribute if configured
    if config.keep_role_attr && attr_name == "role" {
        return false;
    }

    // Always keep xmlns
    if attr_name == "xmlns" {
        return false;
    }

    // Keep namespaced attributes (xml:*, xlink:*)
    if attr_name.contains(':') {
        let prefix = attr_name.split(':').next().unwrap_or("");
        if prefix == "xml" || prefix == "xlink" {
            return false;
        }
    }

    // Check for unknown attributes
    if config.unknown_attrs && !is_known_attribute(attr_name) {
        return true;
    }

    // Check for default values (only if element doesn't have id)
    if config.default_attrs && !element.has_attr("id") && is_default_value(attr_name, attr_value) {
        return true;
    }

    // Check for useless overrides (simplified - only if element doesn't have id)
    if config.useless_overrides && !element.has_attr("id") {
        if let Some(parent) = parent_element {
            if let Some(parent_value) = parent.attr(attr_name) {
                if parent_value == attr_value {
                    return true;
                }
            }
        }
    }

    false
}

/// Check if an attribute is known/valid
fn is_known_attribute(attr_name: &str) -> bool {
    KNOWN_ATTRIBUTES.contains(attr_name)
}

/// Check if an attribute value is the default value
fn is_default_value(attr_name: &str, attr_value: &str) -> bool {
    if let Some(&default_value) = DEFAULT_ATTRIBUTE_VALUES.get(attr_name) {
        default_value == attr_value
    } else {
        false
    }
}

#[cfg(test)]
#[allow(unused_mut)]
mod tests {
    use super::*;
    use crate::ast::{Document, Element, Node};
    use serde_json::json;

    #[test]
    fn test_removes_unknown_attributes() {
        let mut document = Document::new();
        let mut element = Element::new("rect");

        element
            .attributes
            .insert("width".to_string(), "100".to_string());
        element
            .attributes
            .insert("unknown-attr".to_string(), "value".to_string());
        element
            .attributes
            .insert("height".to_string(), "50".to_string());

        document.root = element;

        let mut plugin = RemoveUnknownsAndDefaultsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert!(document.root.has_attr("width"));
        assert!(document.root.has_attr("height"));
        assert!(!document.root.has_attr("unknown-attr"));
    }

    #[test]
    fn test_removes_default_values() {
        let mut document = Document::new();
        let mut element = Element::new("rect");

        element.attributes.insert("x".to_string(), "0".to_string());
        element.attributes.insert("y".to_string(), "0".to_string());
        element
            .attributes
            .insert("width".to_string(), "100".to_string());
        element
            .attributes
            .insert("fill".to_string(), "black".to_string());

        document.root = element;

        let mut plugin = RemoveUnknownsAndDefaultsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert!(!document.root.has_attr("x")); // default value removed
        assert!(!document.root.has_attr("y")); // default value removed
        assert!(document.root.has_attr("width")); // not default, kept
        assert!(!document.root.has_attr("fill")); // default value removed
    }

    #[test]
    fn test_preserves_data_attributes() {
        let mut document = Document::new();
        let mut element = Element::new("rect");

        element
            .attributes
            .insert("data-test".to_string(), "value".to_string());
        element
            .attributes
            .insert("unknown-attr".to_string(), "value".to_string());

        document.root = element;

        let mut plugin = RemoveUnknownsAndDefaultsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert!(document.root.has_attr("data-test")); // preserved
        assert!(!document.root.has_attr("unknown-attr")); // removed
    }

    #[test]
    fn test_preserves_aria_attributes() {
        let mut document = Document::new();
        let mut element = Element::new("rect");

        element
            .attributes
            .insert("aria-label".to_string(), "test".to_string());
        element
            .attributes
            .insert("unknown-attr".to_string(), "value".to_string());

        document.root = element;

        let mut plugin = RemoveUnknownsAndDefaultsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert!(document.root.has_attr("aria-label")); // preserved
        assert!(!document.root.has_attr("unknown-attr")); // removed
    }

    #[test]
    fn test_role_attribute_handling() {
        let mut document = Document::new();
        let mut element = Element::new("rect");

        element
            .attributes
            .insert("role".to_string(), "button".to_string());

        document.root = element;

        // Test with keepRoleAttr = false (default)
        let mut plugin = RemoveUnknownsAndDefaultsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();
        assert!(!document.root.has_attr("role")); // removed

        // Test with keepRoleAttr = true
        let mut document2 = Document::new();
        let mut element2 = Element::new("rect");
        element2
            .attributes
            .insert("role".to_string(), "button".to_string());
        document2.root = element2;

        let params = json!({"keepRoleAttr": true});
        plugin
            .apply(
                &mut document2,
                &crate::plugin::PluginInfo::default(),
                Some(&params),
            )
            .unwrap();
        assert!(document2.root.has_attr("role")); // preserved
    }

    #[test]
    fn test_preserves_namespaced_attributes() {
        let mut document = Document::new();
        let mut element = Element::new("rect");

        element
            .attributes
            .insert("xml:space".to_string(), "preserve".to_string());
        element
            .attributes
            .insert("xlink:href".to_string(), "#test".to_string());
        element.attributes.insert(
            "xmlns".to_string(),
            "http://www.w3.org/2000/svg".to_string(),
        );
        element
            .attributes
            .insert("unknown-attr".to_string(), "value".to_string());

        document.root = element;

        let mut plugin = RemoveUnknownsAndDefaultsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert!(document.root.has_attr("xml:space")); // preserved
        assert!(document.root.has_attr("xlink:href")); // preserved
        assert!(document.root.has_attr("xmlns")); // preserved
        assert!(!document.root.has_attr("unknown-attr")); // removed
    }

    #[test]
    fn test_removes_unknown_elements() {
        let mut document = Document::new();
        let known_child = Element::new("rect");
        let unknown_child = Element::new("unknown-element");

        document.root.children.push(Node::Element(known_child));
        document.root.children.push(Node::Element(unknown_child));

        let mut plugin = RemoveUnknownsAndDefaultsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert_eq!(document.root.children.len(), 1);
        if let Node::Element(remaining_child) = &document.root.children[0] {
            assert_eq!(remaining_child.name, "rect");
        }
    }

    #[test]
    fn test_preserves_id_elements_from_default_removal() {
        let mut document = Document::new();
        let mut element = Element::new("rect");

        element
            .attributes
            .insert("id".to_string(), "test".to_string());
        element.attributes.insert("x".to_string(), "0".to_string()); // default value
        element
            .attributes
            .insert("fill".to_string(), "black".to_string()); // default value

        document.root = element;

        let mut plugin = RemoveUnknownsAndDefaultsPlugin;
        plugin
            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
            .unwrap();

        assert!(document.root.has_attr("id"));
        assert!(document.root.has_attr("x")); // preserved because element has id
        assert!(document.root.has_attr("fill")); // preserved because element has id
    }

    #[test]
    fn test_configuration_options() {
        let mut document = Document::new();
        let mut element = Element::new("rect");

        element
            .attributes
            .insert("unknown-attr".to_string(), "value".to_string());
        element.attributes.insert("x".to_string(), "0".to_string());

        document.root = element;

        let mut plugin = RemoveUnknownsAndDefaultsPlugin;
        let params = json!({
            "unknownAttrs": false,
            "defaultAttrs": false
        });
        plugin
            .apply(
                &mut document,
                &crate::plugin::PluginInfo::default(),
                Some(&params),
            )
            .unwrap();

        // Both should be preserved due to config
        assert!(document.root.has_attr("unknown-attr"));
        assert!(document.root.has_attr("x"));
    }

    #[test]
    fn test_plugin_name_and_description() {
        let mut plugin = RemoveUnknownsAndDefaultsPlugin;
        assert_eq!(plugin.name(), "removeUnknownsAndDefaults");
        assert_eq!(
            plugin.description(),
            "removes unknown elements content and attributes, removes attrs with default values"
        );
    }
}

```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs
# Language: rust

mod tests;

struct RemoveUnusedNSPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs
# Language: rust

mod tests;

struct RemoveUselessDefsPlugin {
}


Relative File Path: svgn/src/plugins/remove_useless_stroke_and_fill.rs

```rust
// this_file: svgn/src/plugins/remove_useless_stroke_and_fill.rs

use crate::ast::{Document, Element, Node};
use crate::plugin::{Plugin, PluginInfo, PluginResult};
use serde_json::Value;
use std::collections::{HashMap, HashSet};
use once_cell::sync::Lazy;

/// SVG shape elements that can have stroke and fill attributes
static SHAPE_ELEMENTS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "rect", "circle", "ellipse", "line", "polyline", "polygon", 
        "path", "text", "tspan", "textPath", "altGlyph", "glyph", "missing-glyph"
    ])
});

/// Remove useless stroke and fill attributes
///
/// This plugin removes stroke and fill attributes that are either:
/// - Set to "none" when no parent element has these attributes
/// - Set to transparent (opacity 0)
/// - Stroke width set to 0
/// 
/// It also handles inheritance and can optionally remove elements that have
/// no visible stroke or fill (removeNone parameter).
pub struct RemoveUselessStrokeAndFillPlugin;

#[derive(Debug)]
struct RemoveUselessStrokeAndFillParams {
    stroke: bool,
    fill: bool,
    remove_none: bool,
}

impl Default for RemoveUselessStrokeAndFillParams {
    fn default() -> Self {
        Self {
            stroke: true,
            fill: true,
            remove_none: false,
        }
    }
}

impl RemoveUselessStrokeAndFillPlugin {
    pub fn new() -> Self {
        Self
    }

    fn parse_params(&self, params: Option<&Value>) -> RemoveUselessStrokeAndFillParams {
        let mut result = RemoveUselessStrokeAndFillParams::default();
        
        if let Some(Value::Object(obj)) = params {
            if let Some(Value::Bool(stroke)) = obj.get("stroke") {
                result.stroke = *stroke;
            }
            if let Some(Value::Bool(fill)) = obj.get("fill") {
                result.fill = *fill;
            }
            if let Some(Value::Bool(remove_none)) = obj.get("removeNone") {
                result.remove_none = *remove_none;
            }
        }
        
        result
    }

    #[allow(clippy::only_used_in_recursion)]
    fn has_style_or_script(&self, element: &Element) -> bool {
        if element.name == "style" || element.name == "script" {
            return true;
        }
        
        for child in &element.children {
            if let Node::Element(child_elem) = child {
                if self.has_style_or_script(child_elem) {
                    return true;
                }
            }
        }
        
        false
    }

    fn process_element(
        &self,
        element: &mut Element,
        params: &RemoveUselessStrokeAndFillParams,
        parent_styles: &HashMap<String, String>,
        nodes_to_remove: &mut Vec<*mut Element>,
    ) -> HashMap<String, String> {
        // Skip elements with ID (they might be referenced by CSS)
        if element.attributes.contains_key("id") {
            return HashMap::new();
        }
        
        // Only process shape elements
        if !SHAPE_ELEMENTS.contains(&element.name.as_str()) {
            return HashMap::new();
        }
        
        // Compute current element styles
        let current_styles = self.compute_element_styles(element, parent_styles);
        
        // Process stroke attributes
        if params.stroke {
            self.process_stroke_attributes(element, &current_styles, parent_styles);
        }
        
        // Process fill attributes
        if params.fill {
            self.process_fill_attributes(element, &current_styles);
        }
        
        // Remove element if it has no visible stroke or fill
        if params.remove_none && self.should_remove_element(element, &current_styles) {
            nodes_to_remove.push(element as *mut Element);
        }
        
        current_styles
    }

    fn compute_element_styles(
        &self,
        element: &Element,
        parent_styles: &HashMap<String, String>,
    ) -> HashMap<String, String> {
        let mut styles = parent_styles.clone();
        
        // Override with element's own attributes
        for (attr, value) in &element.attributes {
            if attr.starts_with("stroke") || attr.starts_with("fill") || attr.starts_with("marker") {
                styles.insert(attr.clone(), value.clone());
            }
        }
        
        // Parse style attribute
        if let Some(style_attr) = element.attributes.get("style") {
            for part in style_attr.split(';') {
                if let Some((key, value)) = part.split_once(':') {
                    let key = key.trim();
                    let value = value.trim();
                    if key.starts_with("stroke") || key.starts_with("fill") || key.starts_with("marker") {
                        styles.insert(key.to_string(), value.to_string());
                    }
                }
            }
        }
        
        styles
    }

    fn process_stroke_attributes(
        &self,
        element: &mut Element,
        current_styles: &HashMap<String, String>,
        parent_styles: &HashMap<String, String>,
    ) {
        let stroke = current_styles.get("stroke");
        let stroke_opacity = current_styles.get("stroke-opacity");
        let stroke_width = current_styles.get("stroke-width");
        let marker_end = current_styles.get("marker-end");
        
        let should_remove_stroke = stroke.is_none_or(|s| s == "none")
            || stroke_opacity.is_some_and(|op| op == "0")
            || stroke_width.is_some_and(|w| w == "0");
        
        if should_remove_stroke {
            // Check if stroke-width affects marker visibility
            let can_remove = stroke_width.is_none_or(|w| w == "0") || marker_end.is_none();
            
            if can_remove {
                // Remove all stroke-related attributes
                let stroke_attrs: Vec<String> = element
                    .attributes
                    .keys()
                    .filter(|k| k.starts_with("stroke"))
                    .cloned()
                    .collect();
                
                for attr in stroke_attrs {
                    element.attributes.shift_remove(&attr);
                }
                
                // Set explicit "none" if parent has non-none stroke
                let parent_stroke = parent_styles.get("stroke");
                if parent_stroke.is_some_and(|s| s != "none") {
                    element.attributes.insert("stroke".to_string(), "none".to_string());
                }
            }
        }
    }

    fn process_fill_attributes(
        &self,
        element: &mut Element,
        current_styles: &HashMap<String, String>,
    ) {
        let fill = current_styles.get("fill");
        let fill_opacity = current_styles.get("fill-opacity");
        
        let should_remove_fill = fill.is_some_and(|f| f == "none")
            || fill_opacity.is_some_and(|op| op == "0");
        
        if should_remove_fill {
            // Remove all fill-related attributes except fill itself
            let fill_attrs: Vec<String> = element
                .attributes
                .keys()
                .filter(|k| k.starts_with("fill-"))
                .cloned()
                .collect();
            
            for attr in fill_attrs {
                element.attributes.shift_remove(&attr);
            }
            
            // Set explicit "none" if not already set
            if fill.is_none_or(|f| f != "none") {
                element.attributes.insert("fill".to_string(), "none".to_string());
            }
        }
    }

    fn should_remove_element(
        &self,
        element: &Element,
        current_styles: &HashMap<String, String>,
    ) -> bool {
        let stroke = current_styles.get("stroke");
        let fill = current_styles.get("fill");
        
        let no_stroke = stroke.is_none_or(|s| s == "none") || element.attributes.get("stroke").is_some_and(|s| s == "none");
        let no_fill = fill.is_some_and(|f| f == "none") || element.attributes.get("fill").is_some_and(|f| f == "none");
        
        no_stroke && no_fill
    }

    #[allow(clippy::only_used_in_recursion)]
    fn remove_marked_elements(&self, element: &mut Element, nodes_to_remove: &[*mut Element]) {
        element.children.retain(|child| {
            if let Node::Element(child_elem) = child {
                let child_ptr = child_elem as *const Element as *mut Element;
                !nodes_to_remove.contains(&child_ptr)
            } else {
                true
            }
        });
        
        // Process children recursively
        for child in &mut element.children {
            if let Node::Element(child_elem) = child {
                self.remove_marked_elements(child_elem, nodes_to_remove);
            }
        }
    }
}

impl Default for RemoveUselessStrokeAndFillPlugin {
    fn default() -> Self {
        Self::new()
    }
}

impl Plugin for RemoveUselessStrokeAndFillPlugin {
    fn name(&self) -> &'static str {
        "removeUselessStrokeAndFill"
    }

    fn description(&self) -> &'static str {
        "removes useless stroke and fill attributes"
    }

    fn apply(
        &mut self,
        document: &mut Document,
        _plugin_info: &PluginInfo,
        params: Option<&Value>,
    ) -> PluginResult<()> {
        let params = self.parse_params(params);
        
        // Skip optimization if there are style or script elements
        if self.has_style_or_script(&document.root) {
            return Ok(());
        }
        
        let mut nodes_to_remove = Vec::new();
        self.process_element_recursive(&mut document.root, &params, &HashMap::new(), &mut nodes_to_remove);
        
        // Remove marked elements
        if !nodes_to_remove.is_empty() {
            self.remove_marked_elements(&mut document.root, &nodes_to_remove);
        }
        
        Ok(())
    }
}

impl RemoveUselessStrokeAndFillPlugin {
    fn process_element_recursive(
        &self,
        element: &mut Element,
        params: &RemoveUselessStrokeAndFillParams,
        parent_styles: &HashMap<String, String>,
        nodes_to_remove: &mut Vec<*mut Element>,
    ) {
        // Process current element
        let current_styles = self.process_element(element, params, parent_styles, nodes_to_remove);
        
        // Process children with updated styles
        for child in &mut element.children {
            if let Node::Element(child_elem) = child {
                self.process_element_recursive(child_elem, params, &current_styles, nodes_to_remove);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::parse_svg;
    use crate::stringifier::stringify;

    #[test]
    fn test_remove_stroke_none() {
        let mut doc = parse_svg(r#"
            <svg>
                <rect stroke="none" fill="red" width="100" height="100"/>
            </svg>
        "#).unwrap();
        
        let mut plugin = RemoveUselessStrokeAndFillPlugin::new();
        let plugin_info = PluginInfo::default();
        plugin.apply(&mut doc, &plugin_info, None).unwrap();
        
        let output = stringify(&doc).unwrap();
        assert!(!output.contains(r#"stroke="none""#));
        assert!(output.contains(r#"fill="red""#));
    }

    #[test]
    fn test_remove_fill_none() {
        let mut doc = parse_svg(r#"
            <svg>
                <rect stroke="blue" fill="none" width="100" height="100"/>
            </svg>
        "#).unwrap();
        
        let mut plugin = RemoveUselessStrokeAndFillPlugin::new();
        let plugin_info = PluginInfo::default();
        plugin.apply(&mut doc, &plugin_info, None).unwrap();
        
        let output = stringify(&doc).unwrap();
        assert!(output.contains(r#"stroke="blue""#));
        assert!(output.contains(r#"fill="none""#)); // Should keep explicit none
    }

    #[test]
    fn test_remove_zero_opacity() {
        let mut doc = parse_svg(r#"
            <svg>
                <rect stroke-opacity="0" fill-opacity="0" width="100" height="100"/>
            </svg>
        "#).unwrap();
        
        let mut plugin = RemoveUselessStrokeAndFillPlugin::new();
        let plugin_info = PluginInfo::default();
        plugin.apply(&mut doc, &plugin_info, None).unwrap();
        
        let output = stringify(&doc).unwrap();
        assert!(!output.contains("stroke-opacity"));
        assert!(output.contains(r#"fill="none""#));
    }

    #[test]
    fn test_preserve_with_id() {
        let mut doc = parse_svg(r#"
            <svg>
                <rect id="test" stroke="none" fill="none" width="100" height="100"/>
            </svg>
        "#).unwrap();
        
        let mut plugin = RemoveUselessStrokeAndFillPlugin::new();
        let plugin_info = PluginInfo::default();
        plugin.apply(&mut doc, &plugin_info, None).unwrap();
        
        let output = stringify(&doc).unwrap();
        // Should preserve attributes because element has ID
        assert!(output.contains(r#"stroke="none""#));
        assert!(output.contains(r#"fill="none""#));
    }

    #[test]
    fn test_skip_with_style_element() {
        let mut doc = parse_svg(r#"
            <svg>
                <style>.test { fill: red; }</style>
                <rect stroke="none" fill="none" width="100" height="100"/>
            </svg>
        "#).unwrap();
        
        let mut plugin = RemoveUselessStrokeAndFillPlugin::new();
        let plugin_info = PluginInfo::default();
        plugin.apply(&mut doc, &plugin_info, None).unwrap();
        
        let output = stringify(&doc).unwrap();
        // Should preserve attributes because of style element
        assert!(output.contains(r#"stroke="none""#));
        assert!(output.contains(r#"fill="none""#));
    }
}
```

# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs
# Language: rust

mod tests;

struct RemoveUselessTransformsPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs
# Language: rust

mod tests;

struct RemoveViewBoxPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs
# Language: rust

mod tests;

struct RemoveXlinkConfig {
}

struct RemoveXlinkPlugin {
}

struct XlinkContext {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs
# Language: rust

mod tests;

struct RemoveXMLProcInstPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs
# Language: rust

mod tests;

struct RemoveXMLNSPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs
# Language: rust

mod tests;

struct SortAttrsPlugin {
}

struct SortAttrsParams {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs
# Language: rust

mod tests;

struct SortDefsChildrenPlugin {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs
# Language: rust

mod tests;

struct Stringifier {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs
# Language: rust

struct TestFixture {
}


# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/integration_test.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/cleanup_attrs.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/cleanup_ids.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/convert_colors.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/convert_ellipse_to_circle.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/convert_one_stop_gradients.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/convert_path_data.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/inline_styles.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/remove_attributes_by_selector.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/remove_comments.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/remove_deprecated_attrs.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/remove_dimensions.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins/remove_empty_attrs.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs
# Language: rust



# File: /Users/adam/Developer/vcs/github.twardoch/pub/svgn/test_css_debug.rs
# Language: rust



Relative File Path: tools/set-cargo-version.sh

```bash
#!/usr/bin/env bash
# Usage: set-cargo-version.sh [v1.2.3]
# Updates Cargo.toml workspace version (in place) to match given tag (removes leading v if present)
set -e
if [ -z "$1" ]; then
  echo "Usage: $0 <version>"
  exit 1
fi
RAW_VERSION="$1"
# Remove leading v (if present)
VERSION="${RAW_VERSION#v}"

CARGO_TOML="Cargo.toml"

# Update version in [workspace.package]
if [ -f "$CARGO_TOML" ]; then
  # Substitute version = "..."
  perl -pi -e 'BEGIN { $inws=0 } s/^version = "[0-9][^\"]*"/version = "'$VERSION'"/ if $inws; if (/^\[workspace\.package\]/) { $inws=1 } elsif (/^\[/ && !/^\[workspace\.package\]/) { $inws=0 }' "$CARGO_TOML"
  echo "Updated $CARGO_TOML: version = $VERSION"
else
  echo "Error: $CARGO_TOML not found."
  exit 2
fi
```