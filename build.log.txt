Generating code snapsht in ./llms.txt ...
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CodeToPrompt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Configuration for this run:                   â”‚
â”‚ Root Directory:                               â”‚
â”‚ /Users/adam/Developer/vcs/github.twardoch/pub â”‚
â”‚ /svgn                                         â”‚
â”‚ Include Patterns: ['*']                       â”‚
â”‚ Exclude Patterns: ['*.svg', '.specstory',     â”‚
â”‚ '*.md', '*.txt']                              â”‚
â”‚ Respect .gitignore: True                      â”‚
â”‚ Show Line Numbers: False                      â”‚
â”‚ Count Tokens: True                            â”‚
â”‚ Compress Code: False                          â”‚
â”‚ Max Tokens: Unlimited                         â”‚
â”‚ Tree Depth: 5                                 â”‚
â”‚ Output Format: default                        â”‚
â”‚ Interactive Mode: False                       â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Processing Complete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Summary:                                      â”‚
â”‚ Files Processed: 96                           â”‚
â”‚ Total Tokens: 211,094                         â”‚
â”‚ Output Destination: llms.txt                  â”‚
â”‚                                               â”‚
â”‚ Top 3 Files by Tokens:                        â”‚
â”‚   - Cargo.lock (14,781 tokens)                â”‚
â”‚   - svgn/Cargo.lock (14,781 tokens)           â”‚
â”‚   - svgn/src/plugins/convert_colors.rs (5,495 â”‚
â”‚ tokens)                                       â”‚
â”‚                                               â”‚
â”‚ Top 5 Extensions by Tokens:                   â”‚
â”‚   - .rs (158,490 tokens)                      â”‚
â”‚   - .lock (29,562 tokens)                     â”‚
â”‚   - .bak (11,168 tokens)                      â”‚
â”‚   - .sh (3,912 tokens)                        â”‚
â”‚   - .yml (2,940 tokens)                       â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
Building the svgn project...
   Compiling svgn v0.1.0 (/Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn)
    Finished `release` profile [optimized] target(s) in 36.36s
Running tests...
   Compiling svgn v0.1.0 (/Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 5.09s
     Running unittests src/lib.rs (target/debug/deps/svgn-3d9dade256195a14)

running 329 tests
test optimizer::tests::test_optimization_info ... ok
test ast::tests::test_child_operations ... ok
test config::tests::test_default_preset ... ok
test config::tests::test_default_config ... ok
test config::tests::test_plugin_management ... ok
test ast::tests::test_whitespace_detection ... ok
test optimizer::tests::test_datauri_encoding ... ok
test ast::tests::test_element_creation ... ok
test ast::tests::test_attribute_operations ... ok
test parser::tests::test_parse_invalid_xml ... ok
test parser::tests::test_parse_empty_element ... ok
test config::tests::test_json_parsing ... ok
test parser::tests::test_parse_simple_svg ... ok
test optimizer::tests::test_optimize_with_config ... ok
test config::tests::test_config_serialization ... ok
test parser::tests::test_parse_with_comments ... ok
test optimizer::tests::test_optimize_simple_svg ... ok
test parser::tests::test_parse_with_namespaces ... ok
test plugin::tests::test_apply_plugins ... ok
test parser::tests::test_parse_with_text ... ok
test plugin::tests::test_apply_unknown_plugin ... ok
test plugin::tests::test_plugin_config ... ok
test plugin::tests::test_plugin_registry ... ok
test plugins::add_attributes_to_svg_element::tests::test_add_attributes_with_values ... ok
test plugins::add_attributes_to_svg_element::tests::test_add_multiple_attributes ... ok
test plugins::add_attributes_to_svg_element::tests::test_add_single_attribute ... ok
test plugins::add_attributes_to_svg_element::tests::test_dont_overwrite_existing_attributes ... ok
test plugins::add_attributes_to_svg_element::tests::test_invalid_params ... ok
test plugins::add_attributes_to_svg_element::tests::test_missing_params ... ok
test plugins::add_attributes_to_svg_element::tests::test_non_svg_element ... ok
test plugins::add_attributes_to_svg_element::tests::test_validate_params ... ok
test plugins::add_classes_to_svg_element::tests::test_add_classes_to_existing ... ok
test plugins::add_classes_to_svg_element::tests::test_add_multiple_classes ... ok
test plugins::add_classes_to_svg_element::tests::test_add_single_class ... ok
test plugins::add_classes_to_svg_element::tests::test_duplicate_classes ... ok
test plugins::add_classes_to_svg_element::tests::test_empty_class_names ... ok
test plugins::add_classes_to_svg_element::tests::test_invalid_class_name_type ... ok
test plugins::add_classes_to_svg_element::tests::test_invalid_params ... ok
test plugins::add_classes_to_svg_element::tests::test_missing_params ... ok
test plugins::add_classes_to_svg_element::tests::test_non_svg_element ... ok
test plugins::add_classes_to_svg_element::tests::test_validate_params ... ok
test plugins::cleanup_attrs::tests::test_with_params ... ok
test plugins::cleanup_enable_background::tests::test_remove_without_filter ... ok
test plugins::cleanup_ids::tests::test_preserve_ids ... ok
test plugins::cleanup_ids::tests::test_skip_with_scripts ... ok
test plugins::cleanup_list_of_values::tests::test_plugin_name_and_description ... ok
test plugins::cleanup_list_of_values::tests::test_preserves_non_list_attributes ... ok
test plugins::cleanup_enable_background::tests::test_cleanup_with_filter ... ok
test plugins::cleanup_enable_background::tests::test_keep_non_matching ... ok
test plugins::cleanup_enable_background::tests::test_simplify_mask_pattern ... ok
test plugins::cleanup_numeric_values::tests::test_cleans_viewbox ... ok
test plugins::cleanup_ids::tests::test_minify_ids ... ok
test plugins::cleanup_ids::tests::test_remove_unused_ids ... ok
test plugins::cleanup_attrs::tests::test_cleanup_newlines ... ok
test plugins::cleanup_attrs::tests::test_cleanup_spaces ... ok
test plugins::cleanup_numeric_values::tests::test_plugin_name_and_description ... ok
test plugins::cleanup_list_of_values::tests::test_rounds_stroke_dasharray ... ok
test plugins::cleanup_list_of_values::tests::test_configurable_precision ... ok
test plugins::cleanup_list_of_values::tests::test_configurable_leading_zero ... ok
test plugins::cleanup_list_of_values::tests::test_handles_enable_background_with_new ... ok
test plugins::cleanup_list_of_values::tests::test_rounds_points_list ... ok
test plugins::cleanup_list_of_values::tests::test_handles_comma_separated_values ... ok
test plugins::cleanup_list_of_values::tests::test_rounds_viewbox ... ok
test plugins::cleanup_list_of_values::tests::test_converts_units_in_lists ... ok
test plugins::cleanup_list_of_values::tests::test_handles_mixed_separators ... ok
test plugins::cleanup_list_of_values::tests::test_rounds_text_positioning ... ok
test plugins::collapse_groups::tests::test_collapse_empty_group ... ok
test plugins::collapse_groups::tests::test_concatenate_transforms ... ok
test plugins::collapse_groups::tests::test_move_attributes_to_single_child ... ok
test plugins::collapse_groups::tests::test_nested_groups ... ok
test plugins::collapse_groups::tests::test_preserve_group_with_id ... ok
test plugins::collapse_groups::tests::test_preserve_group_with_multiple_children ... ok
test plugins::convert_colors::tests::test_convert_to_short_hex ... ok
test plugins::convert_ellipse_to_circle::tests::test_convert_equal_radii ... ok
test plugins::convert_ellipse_to_circle::tests::test_convert_rx_auto ... ok
test plugins::convert_ellipse_to_circle::tests::test_convert_ry_auto ... ok
test plugins::convert_ellipse_to_circle::tests::test_default_zero_values ... ok
test plugins::convert_ellipse_to_circle::tests::test_keep_unequal_radii ... ok
test plugins::convert_one_stop_gradients::tests::test_apply_with_empty_document ... ok
test plugins::convert_ellipse_to_circle::tests::test_nested_ellipses ... ok
test plugins::convert_one_stop_gradients::tests::test_apply_with_no_gradients ... ok
test plugins::convert_one_stop_gradients::tests::test_extract_gradient_id ... ok
test plugins::convert_one_stop_gradients::tests::test_plugin_creation ... ok
test plugins::convert_shape_to_path::tests::test_convert_circle ... ok
test plugins::convert_shape_to_path::tests::test_convert_line ... ok
test plugins::convert_shape_to_path::tests::test_convert_rect_basic ... ok
test plugins::cleanup_numeric_values::tests::test_preserves_non_numeric_values ... ok
test plugins::cleanup_numeric_values::tests::test_configurable_default_px ... ok
test plugins::convert_shape_to_path::tests::test_convert_rect_with_position ... ok
test plugins::cleanup_numeric_values::tests::test_preserves_version_attribute ... ok
test plugins::cleanup_numeric_values::tests::test_configurable_leading_zero ... ok
test plugins::cleanup_numeric_values::tests::test_configurable_precision ... ok
test plugins::cleanup_numeric_values::tests::test_removes_leading_zeros ... ok
test plugins::cleanup_numeric_values::tests::test_converts_units_to_px ... ok
test plugins::cleanup_numeric_values::tests::test_removes_default_px_units ... ok
test plugins::cleanup_numeric_values::tests::test_rounds_decimal_values ... ok
test plugins::convert_shape_to_path::tests::test_precision_formatting ... ok
test plugins::convert_shape_to_path::tests::test_rect_with_rounded_corners_not_converted ... ok
test plugins::merge_styles::tests::test_merge_styles ... ok
test plugins::merge_styles::tests::test_merge_styles_with_media ... ok
test plugins::merge_styles::tests::test_remove_empty_styles ... ok
test plugins::convert_shape_to_path::tests::test_convert_polygon ... ok
test plugins::convert_shape_to_path::tests::test_convert_polyline ... ok
test plugins::convert_colors::tests::test_color_params ... ok
test plugins::minify_styles::tests::test_empty_style_element_removal ... ok
test plugins::minify_styles::tests::test_complex_css_minification ... ok
test plugins::minify_styles::tests::test_minify_css_basic ... ok
test plugins::minify_styles::tests::test_style_attribute_minification ... ok
test plugins::minify_styles::tests::test_minify_css_block ... ok
test plugins::minify_styles::tests::test_minify_css_block_trailing_semicolon ... ok
test plugins::minify_styles::tests::test_minify_css_with_comments ... ok
test plugins::minify_styles::tests::test_minify_style_element ... ok
test plugins::minify_styles::tests::test_minify_css_preserve_comments ... ok
test plugins::minify_styles::tests::test_preserve_important ... ok
test plugins::prefix_ids::tests::test_apply_with_custom_config ... ok
test plugins::prefix_ids::tests::test_apply_with_href ... ok
test plugins::prefix_ids::tests::test_apply_with_ids ... ok
test plugins::prefix_ids::tests::test_escape_identifier_name ... ok
test plugins::prefix_ids::tests::test_plugin_creation ... ok
test plugins::prefix_ids::tests::test_prefix_id ... ok
test plugins::convert_colors::tests::test_color_name_to_hex ... ok
test plugins::prefix_ids::tests::test_prefix_reference ... ok
test plugins::remove_attrs::tests::test_no_attrs_parameter_error ... ok
test plugins::remove_attrs::tests::test_plugin_name_and_description ... ok
test plugins::convert_colors::tests::test_rgb_to_hex ... ok
test plugins::remove_comments::tests::test_remove_comments ... ok
test plugins::remove_deprecated_attrs::tests::test_animation_attribute_target ... ok
test plugins::remove_deprecated_attrs::tests::test_keep_xml_lang_without_lang ... ok
test plugins::remove_deprecated_attrs::tests::test_remove_unsafe_attributes ... ok
test plugins::remove_deprecated_attrs::tests::test_remove_xml_lang_when_lang_exists ... ok
test plugins::prefix_ids::tests::test_generate_prefix ... ok
test plugins::remove_desc::tests::test_remove_any ... ok
test plugins::remove_desc::tests::test_remove_empty_desc ... ok
test plugins::remove_attrs::tests::test_custom_separator ... ok
test plugins::remove_desc::tests::test_preserve_custom_desc ... ok
test plugins::remove_dimensions::tests::test_create_viewbox_from_dimensions ... ok
test plugins::remove_desc::tests::test_remove_standard_desc ... ok
test plugins::remove_dimensions::tests::test_decimal_dimensions ... ok
test plugins::remove_dimensions::tests::test_invalid_dimensions_ignored ... ok
test plugins::remove_dimensions::tests::test_missing_dimension_ignored ... ok
test plugins::remove_dimensions::tests::test_nested_svg_elements ... ok
test plugins::remove_dimensions::tests::test_no_dimensions_no_change ... ok
test plugins::remove_attrs::tests::test_element_specific_removal ... ok
test plugins::remove_dimensions::tests::test_only_processes_svg_elements ... ok
test plugins::remove_dimensions::tests::test_plugin_creation ... ok
test plugins::remove_dimensions::tests::test_remove_dimensions_with_existing_viewbox ... ok
test plugins::remove_dimensions::tests::test_zero_dimensions ... ok
test plugins::remove_doctype::tests::test_empty_document ... ok
test plugins::remove_attrs::tests::test_value_specific_removal ... ok
test plugins::remove_doctype::tests::test_remove_doctype ... ok
test plugins::remove_editors_ns_data::tests::test_apply_preserves_normal_content ... ok
test plugins::remove_editors_ns_data::tests::test_apply_removes_editor_content ... ok
test plugins::remove_editors_ns_data::tests::test_apply_with_additional_namespaces ... ok
test plugins::remove_editors_ns_data::tests::test_plugin_creation ... ok
test plugins::remove_editors_ns_data::tests::test_collect_editor_prefixes ... ok
test plugins::remove_editors_ns_data::tests::test_remove_editor_attributes ... ok
test plugins::remove_editors_ns_data::tests::test_should_remove_element ... ok
test plugins::remove_elements_by_attr::tests::test_apply_no_config_does_nothing ... ok
test plugins::remove_elements_by_attr::tests::test_apply_recursive ... ok
test plugins::remove_elements_by_attr::tests::test_apply_removes_by_class ... ok
test plugins::remove_elements_by_attr::tests::test_apply_removes_by_id ... ok
test plugins::remove_elements_by_attr::tests::test_parse_config_mixed ... ok
test plugins::remove_elements_by_attr::tests::test_parse_config_multiple_classes ... ok
test plugins::remove_elements_by_attr::tests::test_parse_config_multiple_ids ... ok
test plugins::remove_elements_by_attr::tests::test_parse_config_single_class ... ok
test plugins::remove_attrs::tests::test_nested_elements ... ok
test plugins::remove_elements_by_attr::tests::test_parse_config_single_id ... ok
test plugins::remove_elements_by_attr::tests::test_plugin_creation ... ok
test plugins::remove_elements_by_attr::tests::test_should_remove_element_by_class ... ok
test plugins::remove_elements_by_attr::tests::test_should_remove_element_by_id ... ok
test plugins::remove_empty_attrs::tests::test_nested_elements ... ok
test plugins::remove_empty_attrs::tests::test_no_attributes ... ok
test plugins::remove_attrs::tests::test_simple_attribute_removal ... ok
test plugins::remove_empty_attrs::tests::test_plugin_name_and_description ... ok
test plugins::remove_empty_attrs::tests::test_preserves_conditional_processing_attrs ... ok
test plugins::remove_attrs::tests::test_preserve_current_color ... ok
test plugins::remove_empty_attrs::tests::test_removes_empty_attributes ... ok
test plugins::remove_empty_containers::tests::test_keeps_non_container_elements ... ok
test plugins::remove_empty_containers::tests::test_plugin_name_and_description ... ok
test plugins::remove_attrs::tests::test_preserve_current_color_case_insensitive ... ok
test plugins::remove_empty_containers::tests::test_preserves_elements_in_switch ... ok
test plugins::remove_empty_containers::tests::test_preserves_g_with_filter ... ok
test plugins::remove_empty_containers::tests::test_preserves_mask_with_id ... ok
test plugins::remove_empty_containers::tests::test_preserves_pattern_with_attributes ... ok
test plugins::remove_empty_containers::tests::test_preserves_svg_root ... ok
test plugins::remove_empty_containers::tests::test_removes_empty_defs ... ok
test plugins::remove_empty_containers::tests::test_removes_empty_g ... ok
test plugins::remove_empty_containers::tests::test_removes_nested_empty_containers ... ok
test plugins::remove_empty_text::tests::test_configurable_text_removal ... ok
test plugins::remove_empty_text::tests::test_configurable_tref_removal ... ok
test plugins::remove_empty_text::tests::test_configurable_tspan_removal ... ok
test plugins::remove_empty_text::tests::test_mixed_text_elements ... ok
test plugins::remove_empty_text::tests::test_plugin_name_and_description ... ok
test plugins::remove_empty_text::tests::test_preserves_text_with_content ... ok
test plugins::remove_empty_text::tests::test_preserves_tref_with_href ... ok
test plugins::remove_empty_text::tests::test_removes_empty_text ... ok
test plugins::remove_empty_text::tests::test_removes_empty_tspan ... ok
test plugins::remove_empty_text::tests::test_removes_tref_without_href ... ok
test plugins::remove_hidden_elems::tests::test_config_display_none_disabled ... ok
test plugins::remove_hidden_elems::tests::test_plugin_name_and_description ... ok
test plugins::remove_hidden_elems::tests::test_nested_hidden_elements ... ok
test plugins::remove_hidden_elems::tests::test_remove_display_none ... ok
test plugins::remove_hidden_elems::tests::test_remove_empty_groups ... ok
test plugins::remove_hidden_elems::tests::test_remove_empty_path ... ok
test plugins::remove_hidden_elems::tests::test_remove_opacity_zero ... ok
test plugins::remove_hidden_elems::tests::test_remove_visibility_hidden ... ok
test plugins::remove_hidden_elems::tests::test_remove_zero_radius_circle ... ok
test plugins::remove_hidden_elems::tests::test_remove_zero_radius_ellipse ... ok
test plugins::remove_hidden_elems::tests::test_remove_zero_width_rect ... ok
test plugins::remove_attrs::tests::test_regex_pattern_removal ... ok
test plugins::remove_hidden_elems::tests::test_zero_line ... ok
test plugins::remove_metadata::tests::test_remove_metadata ... ok
test plugins::remove_non_inheritable_group_attrs::tests::test_only_affects_groups ... ok
test plugins::remove_non_inheritable_group_attrs::tests::test_plugin_name_and_description ... ok
test plugins::remove_non_inheritable_group_attrs::tests::test_empty_group ... ok
test plugins::remove_non_inheritable_group_attrs::tests::test_nested_groups ... ok
test plugins::remove_non_inheritable_group_attrs::tests::test_all_non_inheritable_attrs ... ok
test plugins::remove_non_inheritable_group_attrs::tests::test_remove_non_inheritable_attrs ... ok
test plugins::remove_off_canvas_paths::tests::test_nested_elements ... ok
test plugins::remove_off_canvas_paths::tests::test_no_viewbox_no_removal ... ok
test plugins::remove_off_canvas_paths::tests::test_plugin_name_and_description ... ok
test plugins::prefix_ids::tests::test_get_basename ... ok
test plugins::remove_off_canvas_paths::tests::test_remove_circle_outside_viewbox ... ok
test plugins::remove_off_canvas_paths::tests::test_remove_line_outside_viewbox ... ok
test plugins::remove_off_canvas_paths::tests::test_remove_polygon_outside_viewbox ... ok
test plugins::remove_off_canvas_paths::tests::test_remove_rect_outside_viewbox ... ok
test plugins::remove_raster_images::tests::test_plugin_name_and_description ... ok
test plugins::remove_off_canvas_paths::tests::test_viewbox_with_offset ... ok
test plugins::remove_scripts::tests::test_normal_anchor_preserved ... ok
test plugins::remove_scripts::tests::test_javascript_url_in_anchor ... ok
test plugins::remove_scripts::tests::test_plugin_name_and_description ... ok
test plugins::remove_scripts::tests::test_remove_event_attributes ... ok
test plugins::remove_attrs::tests::test_multiple_attribute_removal ... ok
test plugins::remove_scripts::tests::test_xlink_href_with_javascript ... ok
test plugins::remove_scripts::tests::test_remove_script_elements ... ok
test plugins::remove_style_element::tests::test_remove_multiple_style_elements ... ok
test plugins::remove_title::tests::test_remove_title ... ok
test plugins::remove_style_element::tests::test_remove_style_elements ... ok
test plugins::remove_unknowns_and_defaults::tests::test_configuration_options ... ok
test plugins::convert_style_to_attrs::tests::test_preserve_existing_attributes ... ok
test plugins::remove_unknowns_and_defaults::tests::test_plugin_name_and_description ... ok
test plugins::remove_unknowns_and_defaults::tests::test_preserves_aria_attributes ... ok
test plugins::remove_unknowns_and_defaults::tests::test_preserves_data_attributes ... ok
test plugins::remove_unknowns_and_defaults::tests::test_preserves_id_elements_from_default_removal ... ok
test plugins::remove_raster_images::tests::test_preserve_non_image_elements ... ok
test plugins::remove_unknowns_and_defaults::tests::test_preserves_namespaced_attributes ... ok
test plugins::remove_raster_images::tests::test_preserve_svg_images ... ok
test plugins::remove_raster_images::tests::test_case_sensitivity ... ok
test plugins::remove_raster_images::tests::test_remove_gif_image ... ok
test plugins::remove_raster_images::tests::test_nested_images ... ok
test plugins::remove_raster_images::tests::test_remove_png_image ... ok
test plugins::remove_raster_images::tests::test_remove_jpeg_image ... ok
test plugins::remove_unknowns_and_defaults::tests::test_removes_default_values ... ok
test plugins::remove_raster_images::tests::test_url_with_path ... ok
test plugins::remove_raster_images::tests::test_remove_data_uri_images ... ok
test plugins::remove_unknowns_and_defaults::tests::test_removes_unknown_attributes ... ok
test plugins::remove_unknowns_and_defaults::tests::test_removes_unknown_elements ... ok
test plugins::remove_unknowns_and_defaults::tests::test_role_attribute_handling ... ok
test plugins::remove_unused_ns::tests::test_mixed_used_and_unused_namespaces ... ok
test plugins::remove_unused_ns::tests::test_no_namespaces_to_remove ... ok
test plugins::remove_unused_ns::tests::test_nested_element_namespace_usage ... ok
test plugins::remove_unused_ns::tests::test_plugin_name_and_description ... ok
test plugins::remove_unused_ns::tests::test_preserve_used_namespace_in_attributes ... ok
test plugins::remove_unused_ns::tests::test_preserve_used_namespace_in_element_name ... ok
test plugins::remove_unused_ns::tests::test_remove_all_unused_namespaces ... ok
test plugins::remove_unused_ns::tests::test_remove_unused_namespace ... ok
test plugins::remove_useless_defs::tests::test_flatten_nested_useless_elements ... ok
test plugins::remove_useless_defs::tests::test_non_rendering_elements_without_id ... ok
test plugins::remove_useless_defs::tests::test_plugin_name_and_description ... ok
test plugins::remove_useless_defs::tests::test_preserve_elements_with_id ... ok
test plugins::remove_useless_defs::tests::test_preserve_style_elements ... ok
test plugins::remove_useless_defs::tests::test_remove_elements_without_id ... ok
test plugins::remove_useless_defs::tests::test_remove_empty_defs ... ok
test plugins::remove_useless_transforms::tests::test_is_useless_transform ... ok
test plugins::remove_useless_transforms::tests::test_preserve_non_identity_transform ... ok
test plugins::remove_useless_transforms::tests::test_remove_identity_scale ... ok
test plugins::remove_useless_transforms::tests::test_remove_identity_translate ... ok
test plugins::remove_view_box::tests::test_comma_separated_viewbox ... ok
test plugins::remove_view_box::tests::test_keep_viewbox_different_origin ... ok
test plugins::remove_view_box::tests::test_keep_viewbox_different_dimensions ... ok
test plugins::remove_view_box::tests::test_keep_viewbox_missing_width_or_height ... ok
test plugins::remove_view_box::tests::test_keep_viewbox_with_px_units ... ok
test plugins::remove_view_box::tests::test_mixed_separator_viewbox ... ok
test plugins::remove_view_box::tests::test_nested_svg_preserved ... ok
test plugins::remove_view_box::tests::test_pattern_element ... ok
test plugins::remove_view_box::tests::test_plugin_name_and_description ... ok
test plugins::remove_view_box::tests::test_remove_redundant_viewbox ... ok
test plugins::remove_xlink::tests::test_convert_xlink_href_to_href ... ok
test plugins::remove_xlink::tests::test_convert_xlink_show_to_target ... ok
test plugins::remove_xlink::tests::test_convert_xlink_title_to_title_element ... ok
test plugins::remove_xlink::tests::test_include_legacy_option ... ok
test plugins::remove_xlink::tests::test_plugin_name_and_description ... ok
test plugins::remove_xlink::tests::test_preserve_existing_href ... ok
test plugins::remove_xlink::tests::test_preserve_legacy_elements ... ok
test plugins::remove_xml_proc_inst::tests::test_preserve_other_pi ... ok
test plugins::remove_xml_proc_inst::tests::test_remove_xml_declaration ... ok
test plugins::remove_xmlns::tests::test_complex_nested_structure ... ok
test plugins::remove_xmlns::tests::test_ignore_non_svg_elements ... ok
test plugins::remove_xmlns::tests::test_plugin_name_and_description ... ok
test plugins::remove_xmlns::tests::test_no_xmlns_attribute ... ok
test plugins::convert_colors::tests::test_convert_rgb_to_hex_function ... ok
test plugins::remove_xmlns::tests::test_preserve_other_xmlns_attributes ... ok
test plugins::remove_xmlns::tests::test_remove_xmlns_from_nested_svg ... ok
test plugins::remove_xmlns::tests::test_remove_xmlns_from_svg ... ok
test plugins::sort_attrs::tests::test_alphabetical_fallback ... ok
test plugins::sort_attrs::tests::test_custom_order ... ok
test plugins::sort_attrs::tests::test_grouped_attributes ... ok
test plugins::sort_attrs::tests::test_nested_elements ... ok
test plugins::sort_attrs::tests::test_plugin_name_and_description ... ok
test plugins::sort_attrs::tests::test_sorts_by_default_order ... ok
test plugins::sort_attrs::tests::test_xmlns_alphabetical_ordering ... ok
test plugins::sort_attrs::tests::test_xmlns_front_ordering ... ok
test plugins::sort_defs_children::tests::test_empty_defs ... ok
test plugins::sort_defs_children::tests::test_complex_sorting ... ok
test plugins::sort_defs_children::tests::test_nested_defs ... ok
test plugins::sort_defs_children::tests::test_plugin_name_and_description ... ok
test plugins::sort_defs_children::tests::test_preserve_non_element_nodes ... ok
test plugins::sort_defs_children::tests::test_sort_alphabetically ... ok
test plugins::sort_defs_children::tests::test_sort_by_frequency ... ok
test plugins::sort_defs_children::tests::test_sort_by_name_length ... ok
test stringifier::tests::test_attribute_escaping ... ok
test stringifier::tests::test_quote_styles ... ok
test stringifier::tests::test_self_closing_elements ... ok
test stringifier::tests::test_stringify_pretty ... ok
test stringifier::tests::test_stringify_simple_element ... ok
test stringifier::tests::test_stringify_with_comment ... ok
test stringifier::tests::test_stringify_with_text ... ok
test plugins::convert_style_to_attrs::tests::test_convert_style_to_attrs ... ok
test plugins::convert_style_to_attrs::tests::test_complex_css_parsing ... ok

test result: ok. 329 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s

     Running unittests src/bin/svgn.rs (target/debug/deps/svgn-ca08cf017ff2152e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/fixture_tests.rs (target/debug/deps/fixture_tests-d8289f415c634316)

running 5 tests
test test_remove_empty_attrs_fixture ... ok
test test_remove_comments_with_params_fixture ... ok
test test_multipass_optimization ... ok
test test_cleanup_attrs_fixture ... ok
test test_convert_colors_fixture ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.04s

     Running tests/integration_test.rs (target/debug/deps/integration_test-887aab6439f011be)

running 4 tests
test test_error_handling_invalid_svg ... ok
test test_pretty_print_formatting ... ok
test test_full_optimization_pipeline ... ok
test test_default_preset_pipeline ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.07s

     Running tests/plugins.rs (target/debug/deps/plugins-531f496e45f09548)

running 5 tests
test test_remove_title_01 ... ok
test test_remove_comments_02_preserve_legal ... ok
test test_remove_comments_03_no_preserve ... ok
test test_remove_comments_01 ... ok
test test_remove_metadata_01 ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/svgo_compatibility_tests.rs (target/debug/deps/svgo_compatibility_tests-5fc6331b8d883aa7)

running 16 tests
test test_optimization_info ... ok
test test_remove_title ... ok
test test_remove_comments_preserve_legal ... ok
test test_remove_comments_basic ... ok
test test_convert_ellipse_to_circle ... ok
test test_remove_dimensions_with_viewbox ... ok
test test_remove_empty_attrs ... ok
test test_pretty_print_vs_minified ... ok
test test_multiple_plugins_pipeline ... ok
test test_remove_metadata ... ok
test test_error_resilience ... ok
test test_multipass_optimization ... ok
test test_plugin_with_params ... ok
test test_convert_colors_basic ... ok
test test_cleanup_ids_minification ... ok
test test_cleanup_attrs_basic ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

   Doc-tests svgn

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

Running linter (clippy)...
   Compiling svgn v0.1.0 (/Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.38s
Checking code formatting...
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/benches/optimization.rs:3:
 //! Benchmarks for SVG optimization performance
 
 use criterion::{black_box, criterion_group, criterion_main, Criterion};
[31m-use svgn::{optimize_default, Config, optimize_with_config};
(B[m[32m+use svgn::{optimize_default, optimize_with_config, Config};
(B[m 
 const SIMPLE_SVG: &str = r#"<svg width="100" height="100">
     <rect x="10" y="10" width="50" height="50" fill="red"/>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/benches/optimization.rs:39:
 fn bench_with_pretty_printing(c: &mut Criterion) {
     let mut config = Config::with_default_preset();
     config.js2svg.pretty = true;
[31m-    
(B[m[32m+
(B[m     c.bench_function("optimize with pretty printing", |b| {
         b.iter(|| optimize_with_config(black_box(SIMPLE_SVG), black_box(config.clone())))
     });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/benches/optimization.rs:48:
 fn bench_multipass_optimization(c: &mut Criterion) {
     let mut config = Config::with_default_preset();
     config.multipass = true;
[31m-    
(B[m[32m+
(B[m     c.bench_function("multipass optimization", |b| {
         b.iter(|| optimize_with_config(black_box(COMPLEX_SVG), black_box(config.clone())))
     });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/benches/optimization.rs:62:
     bench_multipass_optimization
 );
 criterion_main!(benches);
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/build.rs:29:
         println!("cargo:rustc-env=SVGN_VERSION={}", env!("CARGO_PKG_VERSION"));
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs:1:
 // Example program to test the new style plugins
 
 use svgn::parser::Parser;
[31m-use svgn::stringifier::Stringifier;
(B[m use svgn::plugin::{Plugin, PluginInfo};
[31m-use svgn::plugins::{RemoveStyleElement, MergeStylesPlugin, ConvertStyleToAttrsPlugin};
(B[m[32m+use svgn::plugins::{ConvertStyleToAttrsPlugin, MergeStylesPlugin, RemoveStyleElement};
(B[m[32m+use svgn::stringifier::Stringifier;
(B[m 
 fn main() {
     // Test RemoveStyleElement
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs:13:
         <rect class="cls-1" width="10" height="10"/>
         <style>.cls-2{stroke:blue;}</style>
     </svg>"#;
[31m-    
(B[m[32m+
(B[m     let parser = Parser::new();
     let mut doc1 = parser.parse(svg1).unwrap();
     let mut plugin1 = RemoveStyleElement;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs:20:
[31m-    let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+    let plugin_info = PluginInfo {
(B[m[32m+        path: None,
(B[m[32m+        multipass_count: 0,
(B[m[32m+    };
(B[m     plugin1.apply(&mut doc1, &plugin_info, None).unwrap();
[31m-    
(B[m[32m+
(B[m     let stringifier = Stringifier::new();
     let output1 = stringifier.stringify(&doc1).unwrap();
     println!("Original:\n{}", svg1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs:26:
     println!("After RemoveStyleElement:\n{}\n", output1);
[31m-    
(B[m[32m+
(B[m     // Test MergeStyles
     println!("Testing MergeStyles plugin:");
     let svg2 = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs:33:
         <rect class="a"/>
         <rect class="b"/>
     </svg>"#;
[31m-    
(B[m[32m+
(B[m     let mut doc2 = parser.parse(svg2).unwrap();
     let mut plugin2 = MergeStylesPlugin;
     plugin2.apply(&mut doc2, &plugin_info, None).unwrap();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs:40:
[31m-    
(B[m[32m+
(B[m     let output2 = stringifier.stringify(&doc2).unwrap();
     println!("Original:\n{}", svg2);
     println!("After MergeStyles:\n{}\n", output2);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs:44:
[31m-    
(B[m[32m+
(B[m     // Test ConvertStyleToAttrs
     println!("Testing ConvertStyleToAttrs plugin:");
     let svg3 = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs:48:
         <rect style="fill: red; stroke: blue; opacity: 0.5" width="100" height="100"/>
         <circle style="fill: green; custom-prop: value" r="50"/>
     </svg>"#;
[31m-    
(B[m[32m+
(B[m     let mut doc3 = parser.parse(svg3).unwrap();
     let mut plugin3 = ConvertStyleToAttrsPlugin;
     plugin3.apply(&mut doc3, &plugin_info, None).unwrap();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs:55:
[31m-    
(B[m[32m+
(B[m     let output3 = stringifier.stringify(&doc3).unwrap();
     println!("Original:\n{}", svg3);
     println!("After ConvertStyleToAttrs:\n{}", output3);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/examples/test_style_plugins.rs:59:
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:20:
                 .help("Input file or directory")
                 .short('i')
                 .long("input")
[31m-                .value_name("FILE/DIR")
(B[m[32m+                .value_name("FILE/DIR"),
(B[m         )
         .arg(
             Arg::new("output")
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:27:
                 .help("Output file or directory")
                 .short('o')
                 .long("output")
[31m-                .value_name("FILE/DIR")
(B[m[32m+                .value_name("FILE/DIR"),
(B[m         )
         .arg(
             Arg::new("folder")
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:34:
                 .help("Input folder, optimize and rewrite all *.svg files")
                 .short('f')
                 .long("folder")
[31m-                .value_name("DIR")
(B[m[32m+                .value_name("DIR"),
(B[m         )
         .arg(
             Arg::new("pretty")
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:41:
                 .help("Make SVG pretty printed")
                 .short('p')
                 .long("pretty")
[31m-                .action(ArgAction::SetTrue)
(B[m[32m+                .action(ArgAction::SetTrue),
(B[m         )
         .arg(
             Arg::new("config")
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:48:
                 .help("Custom config file")
                 .long("config")
[31m-                .value_name("FILE")
(B[m[32m+                .value_name("FILE"),
(B[m         )
         .arg(
             Arg::new("disable")
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:54:
                 .help("Disable a plugin by name")
                 .long("disable")
                 .value_name("PLUGIN")
[31m-                .action(ArgAction::Append)
(B[m[32m+                .action(ArgAction::Append),
(B[m         )
         .arg(
             Arg::new("enable")
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:61:
                 .help("Enable a plugin by name")
                 .long("enable")
                 .value_name("PLUGIN")
[31m-                .action(ArgAction::Append)
(B[m[32m+                .action(ArgAction::Append),
(B[m         )
         .arg(
             Arg::new("datauri")
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:68:
                 .help("Output as Data URI string (base64, enc, unenc)")
                 .long("datauri")
[31m-                .value_name("FORMAT")
(B[m[32m+                .value_name("FORMAT"),
(B[m         )
         .arg(
             Arg::new("multipass")
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:74:
                 .help("Optimize SVG multiple times")
                 .long("multipass")
[31m-                .action(ArgAction::SetTrue)
(B[m[32m+                .action(ArgAction::SetTrue),
(B[m         )
         .arg(
             Arg::new("quiet")
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:80:
                 .help("Only output error messages")
                 .short('q')
                 .long("quiet")
[31m-                .action(ArgAction::SetTrue)
(B[m[32m+                .action(ArgAction::SetTrue),
(B[m         )
         .get_matches();
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:87:
     let result = run_cli(matches);
[31m-    
(B[m[32m+
(B[m     if let Err(e) = result {
         eprintln!("Error: {}", e);
         std::process::exit(1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:170:
     if let Some(output_file) = output_path {
         fs::write(output_file, &result.data)?;
         if !quiet {
[31m-            eprintln!("Optimized: {} â†’ {} ({:.1}% reduction)", 
(B[m[31m-                     format_bytes(result.info.original_size),
(B[m[31m-                     format_bytes(result.info.optimized_size),
(B[m[31m-                     result.info.compression_percentage());
(B[m[32m+            eprintln!(
(B[m[32m+                "Optimized: {} â†’ {} ({:.1}% reduction)",
(B[m[32m+                format_bytes(result.info.original_size),
(B[m[32m+                format_bytes(result.info.optimized_size),
(B[m[32m+                result.info.compression_percentage()
(B[m[32m+            );
(B[m         }
     } else {
         // Write to stdout
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:183:
     Ok(())
 }
 
[31m-fn process_folder(folder_path: &str, config: &Config, quiet: bool) -> Result<(), Box<dyn std::error::Error>> {
(B[m[32m+fn process_folder(
(B[m[32m+    folder_path: &str,
(B[m[32m+    config: &Config,
(B[m[32m+    quiet: bool,
(B[m[32m+) -> Result<(), Box<dyn std::error::Error>> {
(B[m     let folder = PathBuf::from(folder_path);
[31m-    
(B[m[32m+
(B[m     if !folder.is_dir() {
         return Err(format!("{} is not a directory", folder_path).into());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:192:
 
     let svg_files = find_svg_files(&folder)?;
[31m-    
(B[m[32m+
(B[m     if svg_files.is_empty() {
         if !quiet {
             eprintln!("No SVG files found in {}", folder_path);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:205:
 
     for svg_file in svg_files {
         let input_content = fs::read_to_string(&svg_file)?;
[31m-        
(B[m[32m+
(B[m         let mut file_config = config.clone();
         file_config.path = Some(svg_file.to_string_lossy().to_string());
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:212:
         match optimize_with_config(&input_content, file_config) {
             Ok(result) => {
                 fs::write(&svg_file, &result.data)?;
[31m-                
(B[m[32m+
(B[m                 total_original += result.info.original_size;
                 total_optimized += result.info.optimized_size;
                 processed_count += 1;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:219:
 
                 if !quiet {
[31m-                    println!("Optimized: {} ({:.1}% reduction)",
(B[m[31m-                            svg_file.display(),
(B[m[31m-                            result.info.compression_percentage());
(B[m[32m+                    println!(
(B[m[32m+                        "Optimized: {} ({:.1}% reduction)",
(B[m[32m+                        svg_file.display(),
(B[m[32m+                        result.info.compression_percentage()
(B[m[32m+                    );
(B[m                 }
             }
             Err(e) => {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:237:
         };
 
         eprintln!("\nTotal: {} files processed", processed_count);
[31m-        eprintln!("Size: {} â†’ {} ({:.1}% reduction)",
(B[m[31m-                 format_bytes(total_original),
(B[m[31m-                 format_bytes(total_optimized),
(B[m[31m-                 total_reduction);
(B[m[32m+        eprintln!(
(B[m[32m+            "Size: {} â†’ {} ({:.1}% reduction)",
(B[m[32m+            format_bytes(total_original),
(B[m[32m+            format_bytes(total_optimized),
(B[m[32m+            total_reduction
(B[m[32m+        );
(B[m     }
 
     Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:248:
 
 fn find_svg_files(dir: &PathBuf) -> Result<Vec<PathBuf>, Box<dyn std::error::Error>> {
     let mut svg_files = Vec::new();
[31m-    
(B[m[32m+
(B[m     for entry in fs::read_dir(dir)? {
         let entry = entry?;
         let path = entry.path();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:255:
[31m-        
(B[m[32m+
(B[m         if path.is_file() {
             if let Some(extension) = path.extension() {
                 if extension.to_string_lossy().to_lowercase() == "svg" {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:261:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     svg_files.sort();
     Ok(svg_files)
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:268:
 
 fn format_bytes(bytes: usize) -> String {
     const UNITS: &[&str] = &["B", "KB", "MB", "GB"];
[31m-    
(B[m[32m+
(B[m     if bytes == 0 {
         return "0 B".to_string();
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:275:
[31m-    
(B[m[32m+
(B[m     let bytes_f = bytes as f64;
     let i = (bytes_f.log10() / 3.0).floor() as usize;
     let i = i.min(UNITS.len() - 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:279:
[31m-    
(B[m[32m+
(B[m     let size = bytes_f / (1000.0_f64.powi(i as i32));
[31m-    
(B[m[32m+
(B[m     if i == 0 {
         format!("{} {}", bytes, UNITS[i])
     } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/bin/svgn.rs:285:
         format!("{:.1} {}", size, UNITS[i])
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:1:
 // this_file: svgn/src/ast.rs
 
 //! Abstract Syntax Tree (AST) for SVG documents
[31m-//! 
(B[m[32m+//!
(B[m //! This module defines the core data structures for representing SVG documents
 //! in memory. The AST is designed for efficient traversal and mutation during
 //! optimization passes.
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:8:
 
[31m-use std::collections::HashMap;
(B[m use indexmap::IndexMap;
[32m+use std::collections::HashMap;
(B[m 
 /// A complete SVG document
 #[derive(Debug, Clone, PartialEq)]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:56:
     /// XML comment
     Comment(String),
     /// Processing instruction
[31m-    ProcessingInstruction {
(B[m[31m-        target: String,
(B[m[31m-        data: String,
(B[m[31m-    },
(B[m[32m+    ProcessingInstruction { target: String, data: String },
(B[m     /// CDATA section
     CData(String),
     /// DOCTYPE declaration
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:158:
 
     /// Check if element has only whitespace text content
     pub fn is_whitespace_only(&self) -> bool {
[31m-        self.children.iter().all(|child| {
(B[m[31m-            match child {
(B[m[31m-                Node::Text(text) => text.trim().is_empty(),
(B[m[31m-                Node::Comment(_) => true,
(B[m[31m-                _ => false,
(B[m[31m-            }
(B[m[32m+        self.children.iter().all(|child| match child {
(B[m[32m+            Node::Text(text) => text.trim().is_empty(),
(B[m[32m+            Node::Comment(_) => true,
(B[m[32m+            _ => false,
(B[m         })
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:183:
     pub fn is_comment(&self) -> bool {
         matches!(self, Node::Comment(_))
     }
[31m-    
(B[m[32m+
(B[m     /// Check if this node is a DOCTYPE
     pub fn is_doctype(&self) -> bool {
         matches!(self, Node::DocType(_))
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:238:
     #[test]
     fn test_attribute_operations() {
         let mut element = Element::new("rect");
[31m-        
(B[m[32m+
(B[m         element.set_attr("x".to_string(), "10".to_string());
         assert_eq!(element.attr("x"), Some(&"10".to_string()));
         assert!(element.has_attr("x"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:245:
[31m-        
(B[m[32m+
(B[m         let removed = element.remove_attr("x");
         assert_eq!(removed, Some("10".to_string()));
         assert!(!element.has_attr("x"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:252:
     fn test_child_operations() {
         let mut parent = Element::new("g");
         let child = Element::new("rect");
[31m-        
(B[m[32m+
(B[m         parent.add_child(Node::Element(child));
         parent.add_child(Node::Text("test".to_string()));
         parent.add_child(Node::Comment("comment".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:259:
[31m-        
(B[m[32m+
(B[m         assert_eq!(parent.children.len(), 3);
         assert_eq!(parent.child_elements().count(), 1);
         assert!(!parent.is_empty());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:267:
         let mut element = Element::new("g");
         element.add_child(Node::Text("   \n  ".to_string()));
         element.add_child(Node::Comment("comment".to_string()));
[31m-        
(B[m[32m+
(B[m         assert!(element.is_whitespace_only());
[31m-        
(B[m[32m+
(B[m         element.add_child(Node::Text("content".to_string()));
         assert!(!element.is_whitespace_only());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/ast.rs:276:
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/collections.rs:1:
[31m-
(B[m[31m-
(B[m[31m-
(B[m[31m-use std::collections::{HashMap, HashSet};
(B[m use once_cell::sync::Lazy;
[32m+use std::collections::{HashMap, HashSet};
(B[m 
 pub static COLORS_NAMES: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
     HashMap::from([
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/collections.rs:458:
 });
 
 /// Animation event attributes in SVG
[31m-pub static ANIMATION_EVENT_ATTRS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
(B[m[31m-    HashSet::from([
(B[m[31m-        "onbegin",
(B[m[31m-        "onend", 
(B[m[31m-        "onrepeat",
(B[m[31m-        "onload",
(B[m[31m-    ])
(B[m[31m-});
(B[m[32m+pub static ANIMATION_EVENT_ATTRS: Lazy<HashSet<&'static str>> =
(B[m[32m+    Lazy::new(|| HashSet::from(["onbegin", "onend", "onrepeat", "onload"]));
(B[m 
 /// Document event attributes in SVG
 pub static DOCUMENT_EVENT_ATTRS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/collections.rs:472:
     HashSet::from([
[31m-        "onabort",
(B[m[31m-        "onerror",
(B[m[31m-        "onresize",
(B[m[31m-        "onscroll", 
(B[m[31m-        "onunload",
(B[m[31m-        "onzoom",
(B[m[32m+        "onabort", "onerror", "onresize", "onscroll", "onunload", "onzoom",
(B[m     ])
 });
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/collections.rs:482:
 /// Document element event attributes in SVG
[31m-pub static DOCUMENT_ELEMENT_EVENT_ATTRS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
(B[m[31m-    HashSet::from([
(B[m[31m-        "oncopy",
(B[m[31m-        "oncut",
(B[m[31m-        "onpaste",
(B[m[31m-    ])
(B[m[31m-});
(B[m[32m+pub static DOCUMENT_ELEMENT_EVENT_ATTRS: Lazy<HashSet<&'static str>> =
(B[m[32m+    Lazy::new(|| HashSet::from(["oncopy", "oncut", "onpaste"]));
(B[m 
 /// Global event attributes in SVG
 pub static GLOBAL_EVENT_ATTRS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/collections.rs:570:
 pub static REFERENCES_PROPS: Lazy<HashSet<&'static str>> = Lazy::new(|| {
     HashSet::from([
         "clip-path",
[31m-        "color-profile", 
(B[m[32m+        "color-profile",
(B[m         "fill",
         "filter",
         "marker-end",
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:29:
 pub type ConfigResult<T> = Result<T, ConfigError>;
 
 /// Main configuration structure
[31m-#[derive(Debug, Clone, Serialize, Deserialize)]
(B[m[31m-#[derive(Default)]
(B[m[32m+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
(B[m pub struct Config {
     /// Path to the file being processed (for context)
     #[serde(skip_serializing_if = "Option::is_none")]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:37:
     pub path: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// Plugin configurations
     #[serde(default, deserialize_with = "deserialize_plugins")]
     pub plugins: Vec<PluginConfig>,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:42:
[31m-    
(B[m[32m+
(B[m     /// Multi-pass optimization
     #[serde(default)]
     pub multipass: bool,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:46:
[31m-    
(B[m[32m+
(B[m     /// Output formatting options
     #[serde(default)]
     pub js2svg: Js2SvgOptions,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:50:
[31m-    
(B[m[32m+
(B[m     /// Data URI output format
     #[serde(skip_serializing_if = "Option::is_none")]
     pub datauri: Option<DataUriFormat>,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:54:
[31m-    
(B[m[32m+
(B[m     /// Parser options
     #[serde(default)]
     pub parser: ParserOptions,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:63:
     /// Pretty-print the output
     #[serde(default)]
     pub pretty: bool,
[31m-    
(B[m[32m+
(B[m     /// Indentation for pretty-printing (number of spaces)
     #[serde(default = "default_indent")]
     pub indent: usize,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:70:
[31m-    
(B[m[32m+
(B[m     /// Use self-closing tags for empty elements
     #[serde(default = "default_true")]
     pub self_closing: bool,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:74:
[31m-    
(B[m[32m+
(B[m     /// Quote attributes (always, never, auto)
     #[serde(default = "default_quote_attrs")]
     pub quote_attrs: QuoteAttrsStyle,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:107:
     /// Preserve whitespace in text content
     #[serde(default)]
     pub preserve_whitespace: bool,
[31m-    
(B[m[32m+
(B[m     /// Preserve comments
     #[serde(default)]
     pub preserve_comments: bool,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:114:
 }
 
 // Default value functions for serde
[31m-fn default_indent() -> usize { 2 }
(B[m[31m-fn default_true() -> bool { true }
(B[m[31m-fn default_quote_attrs() -> QuoteAttrsStyle { QuoteAttrsStyle::Auto }
(B[m[32m+fn default_indent() -> usize {
(B[m[32m+    2
(B[m[32m+}
(B[m[32m+fn default_true() -> bool {
(B[m[32m+    true
(B[m[32m+}
(B[m[32m+fn default_quote_attrs() -> QuoteAttrsStyle {
(B[m[32m+    QuoteAttrsStyle::Auto
(B[m[32m+}
(B[m 
[31m-
(B[m impl Default for Js2SvgOptions {
     fn default() -> Self {
         Self {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:149:
     pub fn from_file<P: AsRef<Path>>(path: P) -> ConfigResult<Self> {
         let path = path.as_ref();
         let content = std::fs::read_to_string(path)?;
[31m-        
(B[m[32m+
(B[m         match path.extension().and_then(|s| s.to_str()) {
             Some("json") => Self::from_json(&content),
             Some("toml") => Self::from_toml(&content),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:157:
                 // For JavaScript config files, we would need to execute them
                 // For now, return an error suggesting JSON or TOML
                 Err(ConfigError::InvalidConfig(
[31m-                    "JavaScript config files not yet supported. Please use JSON or TOML format.".to_string()
(B[m[32m+                    "JavaScript config files not yet supported. Please use JSON or TOML format."
(B[m[32m+                        .to_string(),
(B[m                 ))
             }
             _ => {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:217:
     /// Create a config with the default preset
     pub fn with_default_preset() -> Self {
         let mut config = Self::new();
[31m-        
(B[m[32m+
(B[m         // Add default plugins (excluding unimplemented complex plugins for now)
         let default_plugins = vec![
             "removeComments",
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:224:
[31m-            "removeMetadata", 
(B[m[32m+            "removeMetadata",
(B[m             "removeTitle",
             "removeDesc",
             "removeDoctype",
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:241:
             // "convertTransform",   // Requires matrix math
             // "mergePaths",         // Requires path analysis
             // "moveElemsAttrsToGroup", // Requires DOM analysis
[31m-            // "moveGroupAttrsToElems", // Requires DOM analysis  
(B[m[32m+            // "moveGroupAttrsToElems", // Requires DOM analysis
(B[m             // "inlineStyles",       // Requires CSS parsing
             "removeEmptyText",
             "removeEmptyContainers",
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:261:
 /// Load configuration from common file names in the given directory
 pub fn load_config_from_directory<P: AsRef<Path>>(dir: P) -> ConfigResult<Option<Config>> {
     let dir = dir.as_ref();
[31m-    
(B[m[32m+
(B[m     // Common config file names (in order of preference)
     let config_names = [
         "svgn.config.toml",
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:268:
[31m-        "svgn.config.json", 
(B[m[32m+        "svgn.config.json",
(B[m         "svgo.config.json",
         "svgo.config.js",
         "svgo.config.cjs",
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:289:
 {
     use serde::de::{self, SeqAccess, Visitor};
     use serde_json::Value;
[31m-    
(B[m[32m+
(B[m     struct PluginsVisitor;
[31m-    
(B[m[32m+
(B[m     impl<'de> Visitor<'de> for PluginsVisitor {
         type Value = Vec<PluginConfig>;
[31m-        
(B[m[32m+
(B[m         fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
             formatter.write_str("an array of plugin names or plugin config objects")
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:301:
[31m-        
(B[m[32m+
(B[m         fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
         where
             A: SeqAccess<'de>,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:305:
         {
             let mut plugins = Vec::new();
[31m-            
(B[m[32m+
(B[m             while let Some(value) = seq.next_element::<Value>()? {
                 let plugin = match value {
                     Value::String(name) => PluginConfig::new(name),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:311:
[31m-                    Value::Object(_) => {
(B[m[31m-                        serde_json::from_value(value)
(B[m[31m-                            .map_err(de::Error::custom)?
(B[m[31m-                    }
(B[m[32m+                    Value::Object(_) => serde_json::from_value(value).map_err(de::Error::custom)?,
(B[m                     _ => return Err(de::Error::custom("Invalid plugin format")),
                 };
                 plugins.push(plugin);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:318:
             }
[31m-            
(B[m[32m+
(B[m             Ok(plugins)
         }
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:323:
[31m-    
(B[m[32m+
(B[m     deserializer.deserialize_seq(PluginsVisitor)
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:356:
     #[test]
     fn test_plugin_management() {
         let mut config = Config::new();
[31m-        
(B[m[32m+
(B[m         config.add_plugin(PluginConfig::new("test".to_string()));
         assert_eq!(config.plugins.len(), 1);
         assert!(config.get_plugin("test").is_some());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:363:
[31m-        
(B[m[32m+
(B[m         config.set_plugin_enabled("test", false);
         assert!(!config.get_plugin("test").unwrap().enabled);
[31m-        
(B[m[32m+
(B[m         config.remove_plugin("test");
         assert_eq!(config.plugins.len(), 0);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/config.rs:402:
         assert_eq!(config.js2svg.indent, 4);
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/lib.rs:7:
 //! performance improvements.
 
 pub mod ast;
[32m+pub mod collections;
(B[m[32m+pub mod config;
(B[m[32m+pub mod optimizer;
(B[m[32m+pub mod parser;
(B[m pub mod plugin;
 pub mod plugins;
[31m-pub mod parser;
(B[m pub mod stringifier;
[31m-pub mod config;
(B[m[31m-pub mod optimizer;
(B[m[31m-pub mod collections;
(B[m 
 // Re-export main types
 pub use ast::{Document, Element, Node};
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/lib.rs:20:
 pub use config::Config;
[31m-pub use optimizer::{optimize, optimize_with_config, OptimizeOptions, OptimizationResult};
(B[m[32m+pub use optimizer::{optimize, optimize_with_config, OptimizationResult, OptimizeOptions};
(B[m pub use plugin::{Plugin, PluginConfig, PluginRegistry};
 
 /// Library version (from git tag or Cargo.toml)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:6:
 //! parsing, plugin application, and output generation.
 
 use crate::config::Config;
[31m-use crate::parser::{Parser, ParseError};
(B[m[31m-use crate::plugin::{PluginRegistry, PluginError};
(B[m[32m+use crate::parser::{ParseError, Parser};
(B[m[32m+use crate::plugin::{PluginError, PluginRegistry};
(B[m use crate::stringifier::{Stringifier, StringifyError};
 use serde::{Deserialize, Serialize};
 use thiserror::Error;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:88:
 
 impl OptimizationInfo {
     /// Create new optimization info
[31m-    pub fn new(original_size: usize, optimized_size: usize, plugins_applied: usize, passes: usize) -> Self {
(B[m[32m+    pub fn new(
(B[m[32m+        original_size: usize,
(B[m[32m+        optimized_size: usize,
(B[m[32m+        plugins_applied: usize,
(B[m[32m+        passes: usize,
(B[m[32m+    ) -> Self {
(B[m         let compression_ratio = if original_size > 0 {
             1.0 - (optimized_size as f64 / original_size as f64)
         } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:123:
 pub fn optimize(input: &str, options: OptimizeOptions) -> OptimizeResult<OptimizationResult> {
     let original_size = input.len();
     let config = options.config;
[31m-    
(B[m[32m+
(B[m     // Set up parser
     let parser = Parser::new()
         .preserve_whitespace(config.parser.preserve_whitespace)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:138:
     }
 
     // Get or create plugin registry
[31m-    let mut registry = options.registry.unwrap_or_else(|| {
(B[m[31m-        crate::plugin::create_default_registry()
(B[m[31m-    });
(B[m[32m+    let mut registry = options
(B[m[32m+        .registry
(B[m[32m+        .unwrap_or_else(|| crate::plugin::create_default_registry());
(B[m 
     // Apply optimization passes
     let mut passes = 0;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:149:
 
     loop {
         passes += 1;
[31m-        
(B[m[32m+
(B[m         // Apply plugins
         let _initial_plugin_count = plugins_applied;
         let plugin_info = crate::plugin::PluginInfo {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:157:
             multipass_count: passes - 1,
         };
         registry.apply_plugins(&mut document, &config.plugins, &plugin_info)?;
[31m-        
(B[m[32m+
(B[m         // For now, assume all enabled plugins were applied
         // In a real implementation, we'd track this more precisely
         plugins_applied += config.plugins.iter().filter(|p| p.enabled).count();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:179:
             };
 
             let optimized_size = final_output.len();
[31m-            let info = OptimizationInfo::new(original_size, optimized_size, plugins_applied, passes);
(B[m[32m+            let info =
(B[m[32m+                OptimizationInfo::new(original_size, optimized_size, plugins_applied, passes);
(B[m 
             return Ok(OptimizationResult {
                 data: final_output,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:196:
 /// Apply data URI encoding to the SVG output
 fn apply_datauri_encoding(svg: &str, format: &crate::config::DataUriFormat) -> String {
     use crate::config::DataUriFormat;
[31m-    
(B[m[32m+
(B[m     match format {
         DataUriFormat::Base64 => {
             // For now, just return the SVG as-is
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:222:
 
 fn url_encode(input: &str) -> String {
     // This is a placeholder - use proper URL encoding in real implementation
[31m-    input.replace(' ', "%20")
(B[m[32m+    input
(B[m[32m+        .replace(' ', "%20")
(B[m         .replace('<', "%3C")
         .replace('>', "%3E")
         .replace('"', "%22")
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:254:
 
         // Create config with removeComments plugin
         let mut config = Config::new();
[31m-        config.plugins.push(PluginConfig::new("removeComments".to_string()));
(B[m[32m+        config
(B[m[32m+            .plugins
(B[m[32m+            .push(PluginConfig::new("removeComments".to_string()));
(B[m 
         let result = optimize_with_config(svg, config).unwrap();
[31m-        
(B[m[32m+
(B[m         assert!(!result.data.is_empty());
         assert!(result.info.original_size > 0);
         assert!(result.info.optimized_size > 0);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:280:
     #[test]
     fn test_optimization_info() {
         let info = OptimizationInfo::new(1000, 800, 5, 2);
[31m-        
(B[m[32m+
(B[m         assert_eq!(info.original_size, 1000);
         assert_eq!(info.optimized_size, 800);
         assert_eq!(info.size_reduction(), 200);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:292:
     #[test]
     fn test_datauri_encoding() {
         use crate::config::DataUriFormat;
[31m-        
(B[m[32m+
(B[m         let svg = "<svg></svg>";
[31m-        
(B[m[32m+
(B[m         let base64_result = apply_datauri_encoding(svg, &DataUriFormat::Base64);
         assert!(base64_result.starts_with("data:image/svg+xml;base64,"));
[31m-        
(B[m[32m+
(B[m         let enc_result = apply_datauri_encoding(svg, &DataUriFormat::Enc);
         assert!(enc_result.starts_with("data:image/svg+xml,"));
[31m-        
(B[m[32m+
(B[m         let unenc_result = apply_datauri_encoding(svg, &DataUriFormat::Unenc);
         assert!(unenc_result.starts_with("data:image/svg+xml,"));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/optimizer.rs:307:
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:6:
 //! using the quick-xml crate for fast streaming XML parsing.
 
 use crate::ast::{Document, Element, Node};
[31m-use quick_xml::events::{Event, BytesStart};
(B[m[31m-use quick_xml::{Reader, Error as XmlError};
(B[m[32m+use quick_xml::events::{BytesStart, Event};
(B[m[32m+use quick_xml::{Error as XmlError, Reader};
(B[m use thiserror::Error;
 
 /// Parser error types
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:73:
             match reader.read_event_into(&mut buf) {
                 Ok(Event::Start(ref e)) => {
                     let element = self.parse_start_element(e)?;
[31m-                    
(B[m[32m+
(B[m                     if current_element.is_none() {
                         // This is the root element
                         current_element = Some(element);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:99:
                 }
                 Ok(Event::Empty(ref e)) => {
                     let element = self.parse_start_element(e)?;
[31m-                    
(B[m[32m+
(B[m                     if let Some(ref mut parent) = current_element {
                         parent.add_child(Node::Element(element));
                     } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:111:
                 Ok(Event::Text(ref e)) => {
                     let text = e.unescape()?;
                     let text_content = text.to_string();
[31m-                    
(B[m[32m+
(B[m                     if self.preserve_whitespace || !text_content.trim().is_empty() {
                         if let Some(ref mut element) = current_element {
                             element.add_child(Node::Text(text_content));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:143:
                     let parts: Vec<&str> = pi_data.splitn(2, ' ').collect();
                     let target = parts[0].to_string();
                     let data = parts.get(1).unwrap_or(&"").to_string();
[31m-                    
(B[m[32m+
(B[m                     let pi_node = Node::ProcessingInstruction { target, data };
[31m-                    
(B[m[32m+
(B[m                     if let Some(ref mut element) = current_element {
                         element.add_child(pi_node);
                     } else if !found_root {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:157:
                 Ok(Event::Decl(ref e)) => {
                     // Handle XML declaration
                     if let Ok(version) = e.version() {
[31m-                        document.metadata.version = Some(String::from_utf8_lossy(&version).to_string());
(B[m[32m+                        document.metadata.version =
(B[m[32m+                            Some(String::from_utf8_lossy(&version).to_string());
(B[m                     }
                     if let Some(Ok(enc)) = e.encoding() {
[31m-                        document.metadata.encoding = Some(String::from_utf8_lossy(&enc).to_string());
(B[m[32m+                        document.metadata.encoding =
(B[m[32m+                            Some(String::from_utf8_lossy(&enc).to_string());
(B[m                     }
                 }
                 Ok(Event::DocType(ref e)) => {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:196:
             let attr = attr_result.map_err(|e| ParseError::AttrError(e.to_string()))?;
             let key = std::str::from_utf8(attr.key.as_ref())?.to_string();
             let value = attr.unescape_value()?.to_string();
[31m-            
(B[m[32m+
(B[m             // Handle namespace declarations
             if key.starts_with("xmlns") {
                 if key == "xmlns" {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:203:
                     element.namespaces.insert("".to_string(), value.clone());
                 } else if let Some(ns_name) = key.strip_prefix("xmlns:") {
[31m-                    element.namespaces.insert(ns_name.to_string(), value.clone());
(B[m[32m+                    element
(B[m[32m+                        .namespaces
(B[m[32m+                        .insert(ns_name.to_string(), value.clone());
(B[m                 }
             }
[31m-            
(B[m[32m+
(B[m             element.set_attr(key, value);
         }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:230:
 
     #[test]
     fn test_parse_simple_svg() {
[31m-        let svg = r#"<svg width="100" height="100"><rect x="10" y="10" width="50" height="50"/></svg>"#;
(B[m[32m+        let svg =
(B[m[32m+            r#"<svg width="100" height="100"><rect x="10" y="10" width="50" height="50"/></svg>"#;
(B[m         let document = parse_svg(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(document.root.name, "svg");
         assert_eq!(document.root.attr("width"), Some(&"100".to_string()));
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:239:
[31m-        
(B[m[32m+
(B[m         if let Some(Node::Element(rect)) = document.root.children.first() {
             assert_eq!(rect.name, "rect");
             assert_eq!(rect.attr("x"), Some(&"10".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:249:
     fn test_parse_with_text() {
         let svg = r#"<svg><text>Hello World</text></svg>"#;
         let document = parse_svg(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         if let Some(Node::Element(text_elem)) = document.root.children.first() {
             assert_eq!(text_elem.name, "text");
             if let Some(Node::Text(text)) = text_elem.children.first() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:267:
         let svg = r#"<svg><!-- This is a comment --><rect/></svg>"#;
         let parser = Parser::new().preserve_comments(true);
         let document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(document.root.children.len(), 2);
         if let Some(Node::Comment(comment)) = document.root.children.first() {
             assert_eq!(comment, " This is a comment ");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:280:
     fn test_parse_empty_element() {
         let svg = r#"<svg/>"#;
         let document = parse_svg(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(document.root.name, "svg");
         assert!(document.root.children.is_empty());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:289:
     fn test_parse_with_namespaces() {
         let svg = r#"<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><rect/></svg>"#;
         let document = parse_svg(svg).unwrap();
[31m-        
(B[m[31m-        assert_eq!(document.root.namespaces.get(""), Some(&"http://www.w3.org/2000/svg".to_string()));
(B[m[31m-        assert_eq!(document.root.namespaces.get("xlink"), Some(&"http://www.w3.org/1999/xlink".to_string()));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.namespaces.get(""),
(B[m[32m+            Some(&"http://www.w3.org/2000/svg".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.namespaces.get("xlink"),
(B[m[32m+            Some(&"http://www.w3.org/1999/xlink".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/parser.rs:301:
         assert!(result.is_err());
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugin.rs:63:
 pub trait Plugin: Send + Sync {
     /// Plugin name (must be unique)
     fn name(&self) -> &'static str;
[31m-    
(B[m[32m+
(B[m     /// Plugin description
     fn description(&self) -> &'static str;
[31m-    
(B[m[32m+
(B[m     /// Apply the plugin transformation to the document
[31m-    fn apply(&mut self, document: &mut Document, plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()>;
(B[m[31m-    
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()>;
(B[m[32m+
(B[m     /// Check if the plugin should be applied based on the document
     /// Default implementation always returns true
[31m-    fn should_apply(&self, _document: &Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> bool {
(B[m[32m+    fn should_apply(
(B[m[32m+        &self,
(B[m[32m+        _document: &Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> bool {
(B[m         true
     }
[31m-    
(B[m[32m+
(B[m     /// Validate plugin parameters
     /// Default implementation accepts any parameters
     fn validate_params(&self, _params: Option<&Value>) -> PluginResult<()> {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugin.rs:146:
 
     /// Get a plugin by name
     pub fn get(&self, name: &str) -> Option<&dyn Plugin> {
[31m-        self.plugins.iter().find(|p| p.name() == name).map(|p| p.as_ref())
(B[m[32m+        self.plugins
(B[m[32m+            .iter()
(B[m[32m+            .find(|p| p.name() == name)
(B[m[32m+            .map(|p| p.as_ref())
(B[m     }
 
     /// Get a plugin by name (mutable)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugin.rs:205:
 /// Create the default plugin registry with all built-in plugins
 pub fn create_default_registry() -> PluginRegistry {
     let mut registry = PluginRegistry::new();
[31m-    
(B[m[32m+
(B[m     // Register built-in plugins
     registry.register(crate::plugins::CleanupAttrsPlugin);
     registry.register(crate::plugins::CleanupEnableBackgroundPlugin);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugin.rs:254:
     registry.register(crate::plugins::MinifyStylesPlugin);
     registry.register(crate::plugins::ConvertPathDataPlugin);
     registry.register(crate::plugins::RemoveUselessTransformsPlugin);
[31m-    
(B[m[32m+
(B[m     registry
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugin.rs:277:
             "Test plugin"
         }
 
[31m-        fn apply(&mut self, _document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+        fn apply(
(B[m[32m+            &mut self,
(B[m[32m+            _document: &mut Document,
(B[m[32m+            _plugin_info: &PluginInfo,
(B[m[32m+            _params: Option<&Value>,
(B[m[32m+        ) -> PluginResult<()> {
(B[m             Ok(())
         }
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugin.rs:299:
         assert!(config.enabled);
         assert!(config.params.is_none());
 
[31m-        let config_with_params = PluginConfig::with_params(
(B[m[31m-            "test".to_string(),
(B[m[31m-            json!({"option": "value"})
(B[m[31m-        );
(B[m[32m+        let config_with_params =
(B[m[32m+            PluginConfig::with_params("test".to_string(), json!({"option": "value"}));
(B[m         assert!(config_with_params.params.is_some());
 
         let disabled_config = PluginConfig::new("test".to_string()).disabled();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugin.rs:339:
         assert!(result.is_err());
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:5:
 //! This plugin adds attributes to the outer <svg> element.
 
 use crate::ast::{Document, Element};
[31m-use crate::plugin::{Plugin, PluginInfo, PluginResult, PluginError};
(B[m[32m+use crate::plugin::{Plugin, PluginError, PluginInfo, PluginResult};
(B[m use serde_json::Value;
 
 /// Plugin that adds attributes to the outer <svg> element
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:15:
     fn name(&self) -> &'static str {
         "addAttributesToSVGElement"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "adds attributes to an outer <svg> element"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:22:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let params = params.ok_or_else(|| {
             PluginError::InvalidConfig(
[31m-                "addAttributesToSVGElement plugin requires parameters".to_string()
(B[m[32m+                "addAttributesToSVGElement plugin requires parameters".to_string(),
(B[m             )
         })?;
[31m-        
(B[m[32m+
(B[m         let config = AddAttributesConfig::from_params(params)?;
[31m-        
(B[m[32m+
(B[m         // Only modify if the root element is an SVG
         if document.root.name == "svg" {
             add_attributes_to_element(&mut document.root, &config);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:35:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     fn validate_params(&self, params: Option<&Value>) -> PluginResult<()> {
         if let Some(params) = params {
             AddAttributesConfig::from_params(params)?;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:43:
         } else {
             return Err(PluginError::InvalidConfig(
[31m-                "addAttributesToSVGElement plugin requires parameters".to_string()
(B[m[32m+                "addAttributesToSVGElement plugin requires parameters".to_string(),
(B[m             ));
         }
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:65:
 impl AddAttributesConfig {
     fn from_params(params: &Value) -> PluginResult<Self> {
         let mut attributes = Vec::new();
[31m-        
(B[m[32m+
(B[m         // Handle single attribute
         if let Some(attribute) = params.get("attribute") {
             attributes.push(Self::parse_attribute_spec(attribute)?);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:72:
         }
[31m-        
(B[m[32m+
(B[m         // Handle multiple attributes
         if let Some(attrs) = params.get("attributes") {
             if let Some(array) = attrs.as_array() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:79:
                 }
             } else {
                 return Err(PluginError::InvalidConfig(
[31m-                    "attributes parameter must be an array".to_string()
(B[m[32m+                    "attributes parameter must be an array".to_string(),
(B[m                 ));
             }
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:86:
[31m-        
(B[m[32m+
(B[m         if attributes.is_empty() {
             return Err(PluginError::InvalidConfig(
                 "addAttributesToSVGElement plugin requires either 'attribute' or 'attributes' parameter".to_string()
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:90:
             ));
         }
[31m-        
(B[m[32m+
(B[m         Ok(Self { attributes })
     }
[31m-    
(B[m[32m+
(B[m     fn parse_attribute_spec(spec: &Value) -> PluginResult<AttributeSpec> {
         match spec {
             Value::String(name) => Ok(AttributeSpec::Name(name.clone())),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:99:
             Value::Object(obj) => {
                 if obj.len() != 1 {
                     return Err(PluginError::InvalidConfig(
[31m-                        "Attribute object must have exactly one key-value pair".to_string()
(B[m[32m+                        "Attribute object must have exactly one key-value pair".to_string(),
(B[m                     ));
                 }
[31m-                
(B[m[32m+
(B[m                 let (key, value) = obj.iter().next().unwrap();
                 let value_str = match value {
                     Value::String(s) => s.clone(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:109:
                     Value::Bool(b) => b.to_string(),
                     Value::Number(n) => n.to_string(),
                     Value::Null => "".to_string(),
[31m-                    _ => return Err(PluginError::InvalidConfig(
(B[m[31m-                        "Attribute value must be string, number, boolean, or null".to_string()
(B[m[31m-                    )),
(B[m[32m+                    _ => {
(B[m[32m+                        return Err(PluginError::InvalidConfig(
(B[m[32m+                            "Attribute value must be string, number, boolean, or null".to_string(),
(B[m[32m+                        ))
(B[m[32m+                    }
(B[m                 };
[31m-                
(B[m[32m+
(B[m                 Ok(AttributeSpec::NameValue(key.clone(), value_str))
             }
             _ => Err(PluginError::InvalidConfig(
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:120:
[31m-                "Attribute specification must be string or object".to_string()
(B[m[31m-            ))
(B[m[32m+                "Attribute specification must be string or object".to_string(),
(B[m[32m+            )),
(B[m         }
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:147:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element};
[31m-    use serde_json::json;
(B[m     use indexmap::IndexMap;
[32m+    use serde_json::json;
(B[m 
     fn create_test_svg_document() -> Document {
         let mut doc = Document::new();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:155:
         let mut element = Element::new("svg");
[31m-        
(B[m[32m+
(B[m         let mut attrs = IndexMap::new();
         attrs.insert("width".to_string(), "100".to_string());
         attrs.insert("height".to_string(), "100".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:160:
         element.attributes = attrs;
[31m-        
(B[m[32m+
(B[m         doc.root = element;
         doc
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:166:
     #[test]
     fn test_add_single_attribute() {
         let mut plugin = AddAttributesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "attribute": "focusable"
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:175:
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[31m-        assert_eq!(document.root.attributes.get("focusable"), Some(&"".to_string()));
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("focusable"),
(B[m[32m+            Some(&"".to_string())
(B[m[32m+        );
(B[m         // Existing attributes should remain
[31m-        assert_eq!(document.root.attributes.get("width"), Some(&"100".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("width"),
(B[m[32m+            Some(&"100".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:184:
     fn test_add_multiple_attributes() {
         let mut plugin = AddAttributesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "attributes": ["focusable", "role"]
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:192:
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[31m-        assert_eq!(document.root.attributes.get("focusable"), Some(&"".to_string()));
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("focusable"),
(B[m[32m+            Some(&"".to_string())
(B[m[32m+        );
(B[m         assert_eq!(document.root.attributes.get("role"), Some(&"".to_string()));
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:199:
     #[test]
     fn test_add_attributes_with_values() {
         let mut plugin = AddAttributesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "attributes": [
                 {"focusable": false},
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:209:
                 {"role": "img"}
             ]
         });
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[31m-        assert_eq!(document.root.attributes.get("focusable"), Some(&"false".to_string()));
(B[m[31m-        assert_eq!(document.root.attributes.get("data-image"), Some(&"icon".to_string()));
(B[m[31m-        assert_eq!(document.root.attributes.get("role"), Some(&"img".to_string()));
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("focusable"),
(B[m[32m+            Some(&"false".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("data-image"),
(B[m[32m+            Some(&"icon".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("role"),
(B[m[32m+            Some(&"img".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:221:
     fn test_dont_overwrite_existing_attributes() {
         let mut plugin = AddAttributesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         // Add an attribute that already exists
[31m-        document.root.attributes.insert("width".to_string(), "200".to_string());
(B[m[31m-        
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "200".to_string());
(B[m[32m+
(B[m         let params = json!({
             "attributes": [{"width": "300"}]
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:232:
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Should not overwrite existing attribute
[31m-        assert_eq!(document.root.attributes.get("width"), Some(&"200".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("width"),
(B[m[32m+            Some(&"200".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:240:
     fn test_non_svg_element() {
         let mut plugin = AddAttributesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = Document::new();
         document.root = Element::new("rect"); // Not an SVG element
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "attribute": "focusable"
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:249:
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Should not add attributes to non-svg elements
         assert_eq!(document.root.attributes.get("focusable"), None);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:256:
     #[test]
     fn test_missing_params() {
         let mut plugin = AddAttributesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let result = plugin.apply(&mut document, &plugin_info, None);
         assert!(result.is_err());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:266:
     #[test]
     fn test_invalid_params() {
         let mut plugin = AddAttributesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "invalid": "param"
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:275:
[31m-        
(B[m[32m+
(B[m         let result = plugin.apply(&mut document, &plugin_info, Some(&params));
         assert!(result.is_err());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:280:
     #[test]
     fn test_validate_params() {
         let plugin = AddAttributesToSVGElementPlugin;
[31m-        
(B[m[32m+
(B[m         // Valid params
         let valid_params = json!({
             "attribute": "focusable"
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:287:
         });
         assert!(plugin.validate_params(Some(&valid_params)).is_ok());
[31m-        
(B[m[32m+
(B[m         // Invalid params - missing required fields
         let invalid_params = json!({
             "invalid": "param"
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:293:
         });
         assert!(plugin.validate_params(Some(&invalid_params)).is_err());
[31m-        
(B[m[32m+
(B[m         // No params
         assert!(plugin.validate_params(None).is_err());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_attributes_to_svg_element.rs:299:
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:5:
 //! This plugin adds class names to the outer <svg> element.
 
 use crate::ast::{Document, Element};
[31m-use crate::plugin::{Plugin, PluginInfo, PluginResult, PluginError};
(B[m[32m+use crate::plugin::{Plugin, PluginError, PluginInfo, PluginResult};
(B[m use serde_json::Value;
 use std::collections::HashSet;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:16:
     fn name(&self) -> &'static str {
         "addClassesToSVGElement"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "adds classnames to an outer <svg> element"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:23:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let params = params.ok_or_else(|| {
             PluginError::InvalidConfig(
[31m-                "addClassesToSVGElement plugin requires parameters".to_string()
(B[m[32m+                "addClassesToSVGElement plugin requires parameters".to_string(),
(B[m             )
         })?;
[31m-        
(B[m[32m+
(B[m         let config = AddClassesConfig::from_params(params)?;
[31m-        
(B[m[32m+
(B[m         // Only modify if the root element is an SVG
         if document.root.name == "svg" {
             add_classes_to_element(&mut document.root, &config);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:36:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     fn validate_params(&self, params: Option<&Value>) -> PluginResult<()> {
         if let Some(params) = params {
             AddClassesConfig::from_params(params)?;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:44:
         } else {
             return Err(PluginError::InvalidConfig(
[31m-                "addClassesToSVGElement plugin requires parameters".to_string()
(B[m[32m+                "addClassesToSVGElement plugin requires parameters".to_string(),
(B[m             ));
         }
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:58:
 impl AddClassesConfig {
     fn from_params(params: &Value) -> PluginResult<Self> {
         let mut class_names = Vec::new();
[31m-        
(B[m[32m+
(B[m         // Handle single className
         if let Some(class_name) = params.get("className") {
             if let Some(name) = class_name.as_str() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:65:
                 class_names.push(name.to_string());
             } else {
                 return Err(PluginError::InvalidConfig(
[31m-                    "className parameter must be a string".to_string()
(B[m[32m+                    "className parameter must be a string".to_string(),
(B[m                 ));
             }
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:72:
[31m-        
(B[m[32m+
(B[m         // Handle multiple classNames
         if let Some(classes) = params.get("classNames") {
             if let Some(array) = classes.as_array() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:78:
                         class_names.push(name.to_string());
                     } else {
                         return Err(PluginError::InvalidConfig(
[31m-                            "All classNames must be strings".to_string()
(B[m[32m+                            "All classNames must be strings".to_string(),
(B[m                         ));
                     }
                 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:85:
             } else {
                 return Err(PluginError::InvalidConfig(
[31m-                    "classNames parameter must be an array".to_string()
(B[m[32m+                    "classNames parameter must be an array".to_string(),
(B[m                 ));
             }
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:91:
[31m-        
(B[m[32m+
(B[m         if class_names.is_empty() {
             return Err(PluginError::InvalidConfig(
                 "addClassesToSVGElement plugin requires either 'className' or 'classNames' parameter".to_string()
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:95:
             ));
         }
[31m-        
(B[m[32m+
(B[m         Ok(Self { class_names })
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:102:
 fn add_classes_to_element(element: &mut Element, config: &AddClassesConfig) {
     // Get existing classes or create new set
     let mut class_set = HashSet::new();
[31m-    
(B[m[32m+
(B[m     // Parse existing class attribute if it exists
     if let Some(existing_class) = element.attributes.get("class") {
         for class in existing_class.split_whitespace() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:111:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Add new classes
     for class_name in &config.class_names {
         if !class_name.is_empty() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:118:
             class_set.insert(class_name.clone());
         }
     }
[31m-    
(B[m[32m+
(B[m     // Convert back to space-separated string
     let mut classes: Vec<_> = class_set.into_iter().collect();
     classes.sort(); // Sort for consistent output
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:125:
     let class_string = classes.join(" ");
[31m-    
(B[m[32m+
(B[m     // Update the class attribute
     element.attributes.insert("class".to_string(), class_string);
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:133:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element};
[31m-    use serde_json::json;
(B[m     use indexmap::IndexMap;
[32m+    use serde_json::json;
(B[m 
     fn create_test_svg_document() -> Document {
         let mut doc = Document::new();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:141:
         let mut element = Element::new("svg");
[31m-        
(B[m[32m+
(B[m         let mut attrs = IndexMap::new();
         attrs.insert("width".to_string(), "100".to_string());
         attrs.insert("height".to_string(), "100".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:146:
         element.attributes = attrs;
[31m-        
(B[m[32m+
(B[m         doc.root = element;
         doc
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:152:
     fn create_test_svg_document_with_classes() -> Document {
         let mut doc = Document::new();
         let mut element = Element::new("svg");
[31m-        
(B[m[32m+
(B[m         let mut attrs = IndexMap::new();
         attrs.insert("width".to_string(), "100".to_string());
         attrs.insert("class".to_string(), "existing-class".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:159:
         element.attributes = attrs;
[31m-        
(B[m[32m+
(B[m         doc.root = element;
         doc
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:165:
     #[test]
     fn test_add_single_class() {
         let mut plugin = AddClassesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "className": "my-svg"
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:174:
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[31m-        assert_eq!(document.root.attributes.get("class"), Some(&"my-svg".to_string()));
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("class"),
(B[m[32m+            Some(&"my-svg".to_string())
(B[m[32m+        );
(B[m         // Existing attributes should remain
[31m-        assert_eq!(document.root.attributes.get("width"), Some(&"100".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("width"),
(B[m[32m+            Some(&"100".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:183:
     fn test_add_multiple_classes() {
         let mut plugin = AddClassesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "classNames": ["my-svg", "size-large", "theme-dark"]
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:191:
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let class_attr = document.root.attributes.get("class").unwrap();
         let classes: HashSet<&str> = class_attr.split_whitespace().collect();
[31m-        
(B[m[32m+
(B[m         assert!(classes.contains("my-svg"));
         assert!(classes.contains("size-large"));
         assert!(classes.contains("theme-dark"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:203:
     #[test]
     fn test_add_classes_to_existing() {
         let mut plugin = AddClassesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document_with_classes();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "classNames": ["new-class", "another-class"]
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:212:
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let class_attr = document.root.attributes.get("class").unwrap();
         let classes: HashSet<&str> = class_attr.split_whitespace().collect();
[31m-        
(B[m[32m+
(B[m         assert!(classes.contains("existing-class"));
         assert!(classes.contains("new-class"));
         assert!(classes.contains("another-class"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:224:
     #[test]
     fn test_duplicate_classes() {
         let mut plugin = AddClassesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document_with_classes();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "classNames": ["existing-class", "new-class"]
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:233:
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let class_attr = document.root.attributes.get("class").unwrap();
         let classes: HashSet<&str> = class_attr.split_whitespace().collect();
[31m-        
(B[m[32m+
(B[m         // Should not duplicate existing class
         assert!(classes.contains("existing-class"));
         assert!(classes.contains("new-class"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:245:
     #[test]
     fn test_empty_class_names() {
         let mut plugin = AddClassesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "classNames": ["valid-class", "", "  ", "another-valid"]
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:254:
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let class_attr = document.root.attributes.get("class").unwrap();
         let classes: HashSet<&str> = class_attr.split_whitespace().collect();
[31m-        
(B[m[32m+
(B[m         assert!(classes.contains("valid-class"));
         assert!(classes.contains("another-valid"));
         assert_eq!(classes.len(), 2); // Empty strings should be filtered out
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:265:
     #[test]
     fn test_non_svg_element() {
         let mut plugin = AddClassesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = Document::new();
         document.root = Element::new("rect"); // Not an SVG element
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "className": "my-class"
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:275:
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Should not add classes to non-svg elements
         assert_eq!(document.root.attributes.get("class"), None);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:282:
     #[test]
     fn test_missing_params() {
         let mut plugin = AddClassesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let result = plugin.apply(&mut document, &plugin_info, None);
         assert!(result.is_err());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:292:
     #[test]
     fn test_invalid_params() {
         let mut plugin = AddClassesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "invalid": "param"
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:301:
[31m-        
(B[m[32m+
(B[m         let result = plugin.apply(&mut document, &plugin_info, Some(&params));
         assert!(result.is_err());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:306:
     #[test]
     fn test_invalid_class_name_type() {
         let mut plugin = AddClassesToSVGElementPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_svg_document();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "className": 123
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:315:
[31m-        
(B[m[32m+
(B[m         let result = plugin.apply(&mut document, &plugin_info, Some(&params));
         assert!(result.is_err());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:320:
     #[test]
     fn test_validate_params() {
         let plugin = AddClassesToSVGElementPlugin;
[31m-        
(B[m[32m+
(B[m         // Valid params
         let valid_params = json!({
             "className": "my-class"
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:327:
         });
         assert!(plugin.validate_params(Some(&valid_params)).is_ok());
[31m-        
(B[m[32m+
(B[m         let valid_params2 = json!({
             "classNames": ["class1", "class2"]
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:333:
         assert!(plugin.validate_params(Some(&valid_params2)).is_ok());
[31m-        
(B[m[32m+
(B[m         // Invalid params - missing required fields
         let invalid_params = json!({
             "invalid": "param"
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:338:
         });
         assert!(plugin.validate_params(Some(&invalid_params)).is_err());
[31m-        
(B[m[32m+
(B[m         // No params
         assert!(plugin.validate_params(None).is_err());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/add_classes_to_svg_element.rs:344:
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:15:
 pub struct CleanupAttrsPlugin;
 
 // Compile regex patterns once at startup
[31m-static REG_NEWLINES_NEED_SPACE: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"(\S)\r?\n(\S)").unwrap()
(B[m[31m-});
(B[m[31m-static REG_NEWLINES: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"\r?\n").unwrap()
(B[m[31m-});
(B[m[31m-static REG_SPACES: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"\s{2,}").unwrap()
(B[m[31m-});
(B[m[32m+static REG_NEWLINES_NEED_SPACE: LazyLock<Regex> =
(B[m[32m+    LazyLock::new(|| Regex::new(r"(\S)\r?\n(\S)").unwrap());
(B[m[32m+static REG_NEWLINES: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"\r?\n").unwrap());
(B[m[32m+static REG_SPACES: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"\s{2,}").unwrap());
(B[m 
 impl Plugin for CleanupAttrsPlugin {
     fn name(&self) -> &'static str {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:30:
         "cleanupAttrs"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Cleanup attributes from newlines, trailing and repeating spaces"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:36:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &crate::plugin::PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &crate::plugin::PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Parse parameters with defaults
         let newlines = params
             .and_then(|v| v.get("newlines"))
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:41:
             .and_then(|v| v.as_bool())
             .unwrap_or(true);
[31m-            
(B[m[32m+
(B[m         let trim = params
             .and_then(|v| v.get("trim"))
             .and_then(|v| v.as_bool())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:47:
             .unwrap_or(true);
[31m-            
(B[m[32m+
(B[m         let spaces = params
             .and_then(|v| v.get("spaces"))
             .and_then(|v| v.as_bool())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:52:
             .unwrap_or(true);
[31m-        
(B[m[32m+
(B[m         // Process the root element and all its descendants
         cleanup_element_attrs(&mut document.root, newlines, trim, spaces);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:64:
     for (_name, value) in element.attributes.iter_mut() {
         if newlines {
             // Replace newlines that need a space (between non-whitespace chars)
[31m-            *value = REG_NEWLINES_NEED_SPACE.replace_all(value, "$1 $2").to_string();
(B[m[32m+            *value = REG_NEWLINES_NEED_SPACE
(B[m[32m+                .replace_all(value, "$1 $2")
(B[m[32m+                .to_string();
(B[m             // Remove simple newlines
             *value = REG_NEWLINES.replace_all(value, "").to_string();
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:71:
[31m-        
(B[m[32m+
(B[m         if trim {
             *value = value.trim().to_string();
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:75:
[31m-        
(B[m[32m+
(B[m         if spaces {
             // Replace multiple spaces with a single space
             *value = REG_SPACES.replace_all(value, " ").to_string();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:79:
         }
     }
[31m-    
(B[m[32m+
(B[m     // Recursively process child elements
     for child in &mut element.children {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:93:
     use super::*;
     use crate::parser::Parser;
     use serde_json::json;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_cleanup_newlines() {
         let svg = r#"<svg viewBox="0
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:103:
 2" y="3
 4"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupAttrsPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that newlines are replaced with spaces where needed
[31m-        assert_eq!(document.root.attr("viewBox"), Some(&"0 10 20 30".to_string()));
(B[m[31m-        
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attr("viewBox"),
(B[m[32m+            Some(&"0 10 20 30".to_string())
(B[m[32m+        );
(B[m[32m+
(B[m         let rect = document.root.child_elements().next().unwrap();
         assert_eq!(rect.attr("x"), Some(&"1 2".to_string()));
         assert_eq!(rect.attr("y"), Some(&"3 4".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:119:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_cleanup_spaces() {
         let svg = r#"<svg class="  foo    bar  ">
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:124:
             <rect fill="  red  "/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupAttrsPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that multiple spaces are reduced to single spaces and trimmed
         assert_eq!(document.root.attr("class"), Some(&"foo bar".to_string()));
[31m-        
(B[m[32m+
(B[m         let rect = document.root.child_elements().next().unwrap();
         assert_eq!(rect.attr("fill"), Some(&"red".to_string()));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:139:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_with_params() {
         let svg = r#"<svg class="  foo    bar  ">
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:143:
             <rect x="1
 2"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupAttrsPlugin;
         let params = json!({
             "newlines": false,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:153:
             "spaces": false,
             "trim": true
         });
[31m-        
(B[m[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Only trim should be applied
         assert_eq!(document.root.attr("class"), Some(&"foo    bar".to_string()));
[31m-        
(B[m[32m+
(B[m         let rect = document.root.child_elements().next().unwrap();
         // Newline should remain but be trimmed
         assert_eq!(rect.attr("x"), Some(&"1\n2".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_attrs.rs:165:
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:18:
 
 // Regex to match the enable-background format: "new 0 0 <width> <height>"
 static REG_ENABLE_BACKGROUND: LazyLock<Regex> = LazyLock::new(|| {
[31m-    Regex::new(r"^new\s0\s0\s([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)\s([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)$").unwrap()
(B[m[32m+    Regex::new(r"^new\s0\s0\s([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)\s([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)$")
(B[m[32m+        .unwrap()
(B[m });
 
 impl Plugin for CleanupEnableBackgroundPlugin {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:25:
     fn name(&self) -> &'static str {
         "cleanupEnableBackground"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Remove or cleanup enable-background attribute when possible"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:32:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &crate::plugin::PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &crate::plugin::PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // First check if there are any filter elements in the document
         let has_filter = has_filter_element(&document.root);
[31m-        
(B[m[32m+
(B[m         // Process the document
         cleanup_enable_background(&mut document.root, has_filter);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:46:
     if element.name == "filter" {
         return true;
     }
[31m-    
(B[m[32m+
(B[m     for child in &element.children {
         if let Node::Element(child_element) = child {
             if has_filter_element(child_element) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:54:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     false
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:68:
         // Check if this is an element that can have enable-background
         let is_valid_element = matches!(element.name.as_str(), "svg" | "mask" | "pattern");
         let has_dimensions = element.has_attr("width") && element.has_attr("height");
[31m-        
(B[m[32m+
(B[m         if is_valid_element && has_dimensions {
             if let Some(enable_bg) = element.attr("enable-background") {
[31m-                if let (Some(width), Some(height)) = (element.attr("width"), element.attr("height")) {
(B[m[32m+                if let (Some(width), Some(height)) = (element.attr("width"), element.attr("height"))
(B[m[32m+                {
(B[m                     // Clean up the value
                     if let Some(cleaned) = cleanup_value(enable_bg, &element.name, width, height) {
                         element.set_attr("enable-background".to_string(), cleaned);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:82:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Process child elements
     for child in &mut element.children {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:108:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Keep the original value if it doesn't match our pattern or dimensions
     Some(value.to_string())
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:118:
 mod tests {
     use super::*;
     use crate::parser::Parser;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_without_filter() {
         let svg = r#"<svg width="100" height="50" enable-background="new 0 0 100 50">
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:125:
             <rect x="10" y="10" width="80" height="30"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupEnableBackgroundPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Should remove enable-background when no filter is present
         assert!(!document.root.has_attr("enable-background"));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:137:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_cleanup_with_filter() {
         let svg = r#"<svg width="100" height="50" enable-background="new 0 0 100 50">
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:143:
             </filter>
             <rect x="10" y="10" width="80" height="30" filter="url(#blur)"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupEnableBackgroundPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Should remove enable-background even with filter when dimensions match
         assert!(!document.root.has_attr("enable-background"));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:156:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_keep_non_matching() {
         let svg = r#"<svg width="100" height="50" enable-background="new 0 0 200 100">
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:161:
                 <feGaussianBlur stdDeviation="2"/>
             </filter>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupEnableBackgroundPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Should keep enable-background when dimensions don't match
         assert_eq!(
             document.root.attr("enable-background"),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:174:
             Some(&"new 0 0 200 100".to_string())
         );
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_simplify_mask_pattern() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:182:
             <mask width="100" height="50" enable-background="new 0 0 100 50"/>
             <pattern width="200" height="100" enable-background="new 0 0 200 100"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupEnableBackgroundPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check mask - should be simplified to "new"
[31m-        let mask = document.root.child_elements().find(|e| e.name == "mask").unwrap();
(B[m[32m+        let mask = document
(B[m[32m+            .root
(B[m[32m+            .child_elements()
(B[m[32m+            .find(|e| e.name == "mask")
(B[m[32m+            .unwrap();
(B[m         assert_eq!(mask.attr("enable-background"), Some(&"new".to_string()));
[31m-        
(B[m[32m+
(B[m         // Check pattern - should be simplified to "new"
[31m-        let pattern = document.root.child_elements().find(|e| e.name == "pattern").unwrap();
(B[m[32m+        let pattern = document
(B[m[32m+            .root
(B[m[32m+            .child_elements()
(B[m[32m+            .find(|e| e.name == "pattern")
(B[m[32m+            .unwrap();
(B[m         assert_eq!(pattern.attr("enable-background"), Some(&"new".to_string()));
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_enable_background.rs:201:
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:17:
 pub struct CleanupIdsPlugin;
 
 // Regex patterns for finding ID references
[31m-static REG_REFERENCES_URL: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r#"\burl\(#([^)]+)\)"#).unwrap()
(B[m[31m-});
(B[m[31m-static REG_REFERENCES_URL_QUOTED: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r#"\burl\(["']#([^"']+)["']\)"#).unwrap()
(B[m[31m-});
(B[m[31m-static REG_REFERENCES_HREF: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"^#(.+?)$").unwrap()
(B[m[31m-});
(B[m[31m-static REG_REFERENCES_BEGIN: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"(\w+)\.[a-zA-Z]").unwrap()
(B[m[31m-});
(B[m[32m+static REG_REFERENCES_URL: LazyLock<Regex> =
(B[m[32m+    LazyLock::new(|| Regex::new(r#"\burl\(#([^)]+)\)"#).unwrap());
(B[m[32m+static REG_REFERENCES_URL_QUOTED: LazyLock<Regex> =
(B[m[32m+    LazyLock::new(|| Regex::new(r#"\burl\(["']#([^"']+)["']\)"#).unwrap());
(B[m[32m+static REG_REFERENCES_HREF: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"^#(.+?)$").unwrap());
(B[m[32m+static REG_REFERENCES_BEGIN: LazyLock<Regex> =
(B[m[32m+    LazyLock::new(|| Regex::new(r"(\w+)\.[a-zA-Z]").unwrap());
(B[m 
 // Characters used for generating minified IDs
 const GENERATE_ID_CHARS: &[char] = &[
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:35:
[31m-    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
(B[m[31m-    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
(B[m[31m-    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
(B[m[31m-    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
(B[m[32m+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
(B[m[32m+    't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
(B[m[32m+    'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
(B[m ];
 
 // Properties that can contain URL references
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:42:
 const REFERENCES_PROPS: &[&str] = &[
[31m-    "clip-path", "color-profile", "fill", "filter",
(B[m[31m-    "marker-end", "marker-mid", "marker-start", "mask", "stroke", "style"
(B[m[32m+    "clip-path",
(B[m[32m+    "color-profile",
(B[m[32m+    "fill",
(B[m[32m+    "filter",
(B[m[32m+    "marker-end",
(B[m[32m+    "marker-mid",
(B[m[32m+    "marker-start",
(B[m[32m+    "mask",
(B[m[32m+    "stroke",
(B[m[32m+    "style",
(B[m ];
 
 impl Plugin for CleanupIdsPlugin {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:48:
     fn name(&self) -> &'static str {
         "cleanupIds"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Remove unused IDs and minify used IDs"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:55:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &crate::plugin::PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &crate::plugin::PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Parse parameters
         let remove = params
             .and_then(|v| v.get("remove"))
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:60:
             .and_then(|v| v.as_bool())
             .unwrap_or(true);
[31m-            
(B[m[32m+
(B[m         let minify = params
             .and_then(|v| v.get("minify"))
             .and_then(|v| v.as_bool())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:66:
             .unwrap_or(true);
[31m-            
(B[m[32m+
(B[m         let preserve: HashSet<String> = params
             .and_then(|v| v.get("preserve"))
             .and_then(|v| v.as_array())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:75:
                     .collect()
             })
             .unwrap_or_default();
[31m-            
(B[m[32m+
(B[m         let preserve_prefixes: Vec<String> = params
             .and_then(|v| v.get("preservePrefixes"))
             .and_then(|v| v.as_array())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:86:
                     .collect()
             })
             .unwrap_or_default();
[31m-            
(B[m[32m+
(B[m         let force = params
             .and_then(|v| v.get("force"))
             .and_then(|v| v.as_bool())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:93:
             .unwrap_or(false);
[31m-        
(B[m[32m+
(B[m         // Check if we should deoptimize (skip processing)
         if !force && (has_scripts(&document.root) || has_styles(&document.root)) {
             return Ok(());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:98:
         }
[31m-        
(B[m[32m+
(B[m         // Collect all IDs and their references
         let mut node_by_id: HashMap<String, *mut Element> = HashMap::new();
         let mut references_by_id: HashMap<String, Vec<(String, String)>> = HashMap::new();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:103:
[31m-        
(B[m[32m+
(B[m         // First pass: collect IDs and references
         collect_ids_and_refs(&mut document.root, &mut node_by_id, &mut references_by_id);
[31m-        
(B[m[32m+
(B[m         // Helper to check if an ID should be preserved
         let is_id_preserved = |id: &str| -> bool {
[31m-            preserve.contains(id) || 
(B[m[31m-            preserve_prefixes.iter().any(|prefix| id.starts_with(prefix))
(B[m[32m+            preserve.contains(id)
(B[m[32m+                || preserve_prefixes
(B[m[32m+                    .iter()
(B[m[32m+                    .any(|prefix| id.starts_with(prefix))
(B[m         };
[31m-        
(B[m[32m+
(B[m         // Second pass: process IDs
         let mut current_id = None;
         let mut id_mappings: HashMap<String, String> = HashMap::new();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:116:
[31m-        
(B[m[32m+
(B[m         // Process referenced IDs first
         for id in references_by_id.keys() {
             if let Some(&node_ptr) = node_by_id.get(id) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:125:
                         loop {
                             current_id = generate_id(current_id);
                             new_id = get_id_string(current_id.as_ref().unwrap());
[31m-                            
(B[m[32m+
(B[m                             // Make sure the new ID is unique and not preserved
[31m-                            if !is_id_preserved(&new_id) && 
(B[m[31m-                               !node_by_id.contains_key(&new_id) &&
(B[m[31m-                               !id_mappings.values().any(|v| v == &new_id) {
(B[m[32m+                            if !is_id_preserved(&new_id)
(B[m[32m+                                && !node_by_id.contains_key(&new_id)
(B[m[32m+                                && !id_mappings.values().any(|v| v == &new_id)
(B[m[32m+                            {
(B[m                                 break;
                             }
                         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:136:
[31m-                        
(B[m[32m+
(B[m                         // Update the ID
                         node.set_attr("id".to_string(), new_id.clone());
                         id_mappings.insert(id.clone(), new_id);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:140:
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 // Mark this ID as processed (referenced)
                 node_by_id.remove(id);
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:146:
         }
[31m-        
(B[m[32m+
(B[m         // Update all references with new IDs
         if !id_mappings.is_empty() {
             update_references(&mut document.root, &id_mappings);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:151:
         }
[31m-        
(B[m[32m+
(B[m         // Remove unreferenced IDs if requested
         if remove {
             for (id, node_ptr) in node_by_id {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:161:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:171:
     if element.name == "script" && !element.is_empty() {
         return true;
     }
[31m-    
(B[m[32m+
(B[m     // Check for javascript: links
     if element.name == "a" {
         if let Some(href) = element.attr("href") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:180:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Check for event attributes (onclick, onload, etc.)
     for (attr_name, _) in &element.attributes {
         if attr_name.starts_with("on") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:187:
             return true;
         }
     }
[31m-    
(B[m[32m+
(B[m     // Check children
     for child in &element.children {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:196:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     false
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:205:
     if element.name == "style" && !element.is_empty() {
         return true;
     }
[31m-    
(B[m[32m+
(B[m     // Check children
     for child in &element.children {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:214:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     false
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:222:
 fn collect_ids_and_refs(
     element: &mut Element,
     node_by_id: &mut HashMap<String, *mut Element>,
[31m-    references_by_id: &mut HashMap<String, Vec<(String, String)>>
(B[m[32m+    references_by_id: &mut HashMap<String, Vec<(String, String)>>,
(B[m ) {
     // Check for ID attribute
     if let Some(id) = element.attr("id").cloned() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:230:
         // Only keep the first occurrence of each ID
         node_by_id.entry(id).or_insert(element_ptr);
     }
[31m-    
(B[m[32m+
(B[m     // Check for references in attributes
     for (attr_name, attr_value) in &element.attributes {
         let ids = find_references(attr_name, attr_value);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:241:
                 .push((attr_name.clone(), attr_value.clone()));
         }
     }
[31m-    
(B[m[32m+
(B[m     // Process children
     for child in &mut element.children {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:253:
 /// Find ID references in attribute values
 fn find_references(attribute: &str, value: &str) -> Vec<String> {
     let mut results = Vec::new();
[31m-    
(B[m[32m+
(B[m     // Check for URL references: url(#id) and url('#id')
     if REFERENCES_PROPS.contains(&attribute) {
         // Try unquoted URL references
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:269:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Check for href references: #id
     if attribute == "href" || attribute.ends_with(":href") {
         if let Some(cap) = REG_REFERENCES_HREF.captures(value) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:278:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Check for begin attribute references: elementId.event
     if attribute == "begin" {
         if let Some(cap) = REG_REFERENCES_BEGIN.captures(value) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:287:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     results
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:295:
 fn generate_id(current_id: Option<Vec<usize>>) -> Option<Vec<usize>> {
     let mut id = current_id.unwrap_or_else(|| vec![usize::MAX]); // Start before 'a'
     let max_index = GENERATE_ID_CHARS.len() - 1;
[31m-    
(B[m[32m+
(B[m     // Increment the ID
     let last_idx = id.len() - 1;
     if id[last_idx] == usize::MAX {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:303:
     } else {
         id[last_idx] += 1;
     }
[31m-    
(B[m[32m+
(B[m     // Handle carry-over
     for i in (1..id.len()).rev() {
         if id[i] > max_index {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:311:
             id[i - 1] += 1;
         }
     }
[31m-    
(B[m[32m+
(B[m     // Add new position if needed
     if id[0] > max_index {
         id[0] = 0;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:318:
         id.insert(0, 0);
     }
[31m-    
(B[m[32m+
(B[m     Some(id)
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:324:
 /// Convert ID array to string
 fn get_id_string(id: &[usize]) -> String {
[31m-    id.iter()
(B[m[31m-        .map(|&i| GENERATE_ID_CHARS[i])
(B[m[31m-        .collect()
(B[m[32m+    id.iter().map(|&i| GENERATE_ID_CHARS[i]).collect()
(B[m }
 
 /// Update all references with new IDs
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:333:
     // Update attributes
     for (attr_name, attr_value) in element.attributes.iter_mut() {
         let mut new_value = attr_value.clone();
[31m-        
(B[m[32m+
(B[m         // Update URL references
         if REFERENCES_PROPS.contains(&attr_name.as_str()) {
             for (old_id, new_id) in id_mappings {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:340:
                 // Handle both encoded and non-encoded IDs
                 new_value = new_value
[31m-                    .replace(&format!("#{}\"", urlencoding::encode(old_id)), &format!("#{}\"", new_id))
(B[m[31m-                    .replace(&format!("#{}'", urlencoding::encode(old_id)), &format!("#{}'", new_id))
(B[m[31m-                    .replace(&format!("#{})", urlencoding::encode(old_id)), &format!("#{})", new_id))
(B[m[32m+                    .replace(
(B[m[32m+                        &format!("#{}\"", urlencoding::encode(old_id)),
(B[m[32m+                        &format!("#{}\"", new_id),
(B[m[32m+                    )
(B[m[32m+                    .replace(
(B[m[32m+                        &format!("#{}'", urlencoding::encode(old_id)),
(B[m[32m+                        &format!("#{}'", new_id),
(B[m[32m+                    )
(B[m[32m+                    .replace(
(B[m[32m+                        &format!("#{})", urlencoding::encode(old_id)),
(B[m[32m+                        &format!("#{})", new_id),
(B[m[32m+                    )
(B[m                     .replace(&format!("#{}\"", old_id), &format!("#{}\"", new_id))
                     .replace(&format!("#{}'", old_id), &format!("#{}'", new_id))
                     .replace(&format!("#{})", old_id), &format!("#{})", new_id));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:348:
             }
         }
[31m-        
(B[m[32m+
(B[m         // Update href references
         if attr_name == "href" || attr_name.ends_with(":href") {
             for (old_id, new_id) in id_mappings {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:356:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         // Update begin attribute references
         if attr_name == "begin" {
             for (old_id, new_id) in id_mappings {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:363:
                 new_value = new_value.replace(&format!("{}.", old_id), &format!("{}.", new_id));
             }
         }
[31m-        
(B[m[32m+
(B[m         *attr_value = new_value;
     }
[31m-    
(B[m[32m+
(B[m     // Process children
     for child in &mut element.children {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:381:
     use super::*;
     use crate::parser::Parser;
     use serde_json::json;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_unused_ids() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:396:
             <rect id="unused-rect" width="100" height="100"/>
             <rect fill="url(#used-gradient)" width="100" height="100"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupIdsPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that unused IDs are removed
         let defs = document.root.child_elements().next().unwrap();
         let unused_gradient = defs.child_elements().next().unwrap();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:409:
         assert!(!unused_gradient.has_attr("id"));
[31m-        
(B[m[32m+
(B[m         let unused_rect = document.root.child_elements().nth(1).unwrap();
         assert!(!unused_rect.has_attr("id"));
[31m-        
(B[m[32m+
(B[m         // Check that used ID is kept (and minified)
         let used_gradient = defs.child_elements().nth(1).unwrap();
         assert!(used_gradient.has_attr("id"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:417:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_minify_ids() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:426:
             </defs>
             <rect fill="url(#myVeryLongGradientId)" width="100" height="100"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupIdsPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that ID is minified
         let defs = document.root.child_elements().next().unwrap();
         let gradient = defs.child_elements().next().unwrap();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:439:
         let new_id = gradient.attr("id").unwrap();
         assert!(new_id.len() < "myVeryLongGradientId".len());
[31m-        
(B[m[32m+
(B[m         // Check that reference is updated
         let rect = document.root.child_elements().nth(1).unwrap();
         let fill = rect.attr("fill").unwrap();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:445:
         assert!(fill.contains(&format!("#{}", new_id)));
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_preserve_ids() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:452:
             <rect id="icon-rect" width="50" height="50"/>
             <rect id="normal-rect" width="25" height="25"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupIdsPlugin;
         let params = json!({
             "preserve": ["preserve-me"],
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:462:
             "preservePrefixes": ["icon-"]
         });
[31m-        
(B[m[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that preserved IDs are kept
         let rect1 = document.root.child_elements().next().unwrap();
         assert_eq!(rect1.attr("id"), Some(&"preserve-me".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:470:
[31m-        
(B[m[32m+
(B[m         let rect2 = document.root.child_elements().nth(1).unwrap();
         assert_eq!(rect2.attr("id"), Some(&"icon-rect".to_string()));
[31m-        
(B[m[32m+
(B[m         // Check that non-preserved ID is removed (no references to it)
         let rect3 = document.root.child_elements().nth(2).unwrap();
         assert!(!rect3.has_attr("id"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:477:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_skip_with_scripts() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:482:
             <script>console.log('test');</script>
             <rect id="unused-rect" width="100" height="100"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = CleanupIdsPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Should not remove ID when scripts are present
         let rect = document.root.child_elements().nth(1).unwrap();
         assert!(rect.has_attr("id"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_ids.rs:495:
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:2:
 
 //! Plugin to round list of values to fixed precision
 //!
[31m-//! Rounds lists of numeric values (like viewBox, points, stroke-dasharray) 
(B[m[32m+//! Rounds lists of numeric values (like viewBox, points, stroke-dasharray)
(B[m //! to the specified precision and optimizes units.
 
 use crate::ast::{Document, Element, Node};
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:9:
 use crate::plugin::{Plugin, PluginInfo, PluginResult};
[32m+use regex::Regex;
(B[m use serde_json::Value;
 use std::collections::HashMap;
 use std::sync::LazyLock;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:13:
[31m-use regex::Regex;
(B[m 
 /// Regular expression to match numeric values with optional units
 static NUMERIC_VALUE_REGEX: LazyLock<Regex> = LazyLock::new(|| {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:18:
 });
 
 /// Regular expression to split lists of values (space and/or comma separated)
[31m-static SEPARATOR_REGEX: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"\s+,?\s*|,\s*").unwrap()
(B[m[31m-});
(B[m[32m+static SEPARATOR_REGEX: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"\s+,?\s*|,\s*").unwrap());
(B[m 
 /// Regular expression to match the "new" keyword (for enable-background)
[31m-static NEW_KEYWORD_REGEX: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"^new$").unwrap()
(B[m[31m-});
(B[m[32m+static NEW_KEYWORD_REGEX: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"^new$").unwrap());
(B[m 
 /// Conversion factors from absolute units to pixels
 static ABSOLUTE_LENGTHS: LazyLock<HashMap<&'static str, f64>> = LazyLock::new(|| {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:32:
     [
[31m-        ("cm", 96.0 / 2.54),  // 96 DPI / 2.54 cm per inch
(B[m[31m-        ("mm", 96.0 / 25.4),  // 96 DPI / 25.4 mm per inch
(B[m[31m-        ("in", 96.0),         // 96 pixels per inch
(B[m[31m-        ("pt", 4.0 / 3.0),    // 4/3 pixels per point
(B[m[31m-        ("pc", 16.0),         // 16 pixels per pica
(B[m[31m-        ("px", 1.0),          // 1 pixel per pixel
(B[m[32m+        ("cm", 96.0 / 2.54), // 96 DPI / 2.54 cm per inch
(B[m[32m+        ("mm", 96.0 / 25.4), // 96 DPI / 25.4 mm per inch
(B[m[32m+        ("in", 96.0),        // 96 pixels per inch
(B[m[32m+        ("pt", 4.0 / 3.0),   // 4/3 pixels per point
(B[m[32m+        ("pc", 16.0),        // 16 pixels per pica
(B[m[32m+        ("px", 1.0),         // 1 pixel per pixel
(B[m     ]
     .into_iter()
     .collect()
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:45:
 static LIST_ATTRIBUTES: LazyLock<[&'static str; 8]> = LazyLock::new(|| {
     [
         "points",
[31m-        "enable-background", 
(B[m[32m+        "enable-background",
(B[m         "viewBox",
         "stroke-dasharray",
         "dx",
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:52:
[31m-        "dy", 
(B[m[32m+        "dy",
(B[m         "x",
         "y",
     ]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:86:
     /// Parse parameters from JSON value
     pub fn from_value(value: Option<&Value>) -> Self {
         let mut params = Self::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(map)) = value {
             if let Some(Value::Number(precision)) = map.get("floatPrecision") {
                 if let Some(precision) = precision.as_u64() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:103:
                 params.convert_to_px = *convert_to_px;
             }
         }
[31m-        
(B[m[32m+
(B[m         params
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:117:
         "rounds list of values to the fixed precision"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = CleanupListOfValuesParams::from_value(params);
         visit_elements(&mut document.root, &config);
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:127:
 /// Visit all elements in the AST and apply list value cleanup
 fn visit_elements(element: &mut Element, config: &CleanupListOfValuesParams) {
     cleanup_list_values_in_element(element, config);
[31m-    
(B[m[32m+
(B[m     for child in &mut element.children {
         if let Node::Element(child_element) = child {
             visit_elements(child_element, config);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:147:
 /// Round all values in a space/comma-separated list
 fn round_values(lists: &str, config: &CleanupListOfValuesParams) -> String {
     let mut rounded_list = Vec::new();
[31m-    
(B[m[32m+
(B[m     for elem in SEPARATOR_REGEX.split(lists) {
         if elem.is_empty() {
             continue;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:154:
         }
[31m-        
(B[m[32m+
(B[m         // Check for "new" keyword (enable-background)
         if NEW_KEYWORD_REGEX.is_match(elem) {
             rounded_list.push("new".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:159:
             continue;
         }
[31m-        
(B[m[32m+
(B[m         // Check for numeric value
         if let Some(captures) = NUMERIC_VALUE_REGEX.captures(elem) {
             if let Some(rounded) = process_numeric_value(&captures, elem, config) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:169:
             rounded_list.push(elem.to_string());
         }
     }
[31m-    
(B[m[32m+
(B[m     rounded_list.join(" ")
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:183:
     let mut number: f64 = number_str.parse().ok()?;
     let unit = captures.get(3).map(|m| m.as_str()).unwrap_or("");
     let mut final_unit = unit;
[31m-    
(B[m[32m+
(B[m     // Convert absolute units to pixels if beneficial
     if config.convert_to_px && !unit.is_empty() && ABSOLUTE_LENGTHS.contains_key(unit) {
         let conversion_factor = ABSOLUTE_LENGTHS[unit];
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:190:
         let original_number: f64 = number_str.parse().unwrap();
         let px_value = original_number * conversion_factor;
         let px_rounded = round_to_precision(px_value, config.float_precision);
[31m-        
(B[m[32m+
(B[m         // Format the px value and see if it's shorter
         let px_formatted = format_number(px_rounded, config);
         let px_str = if config.default_px {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:198:
         } else {
             px_formatted.clone() + "px"
         };
[31m-        
(B[m[32m+
(B[m         // Use px conversion if it results in a shorter string
         if px_str.len() < original.len() {
             number = px_rounded;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:209:
     } else {
         number = round_to_precision(number, config.float_precision);
     }
[31m-    
(B[m[32m+
(B[m     // Format the number
     let mut result = format_number(number, config);
[31m-    
(B[m[32m+
(B[m     // Remove default 'px' units if enabled
     if config.default_px && final_unit == "px" {
         final_unit = "";
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:219:
     }
[31m-    
(B[m[32m+
(B[m     result.push_str(final_unit);
     Some(result)
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:240:
             .trim_end_matches('.')
             .to_string()
     };
[31m-    
(B[m[32m+
(B[m     if config.leading_zero {
         remove_leading_zero(&formatted)
     } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:253:
     if value.len() > 1 && value.starts_with("0.") {
         return value[1..].to_string();
     }
[31m-    
(B[m[32m+
(B[m     if value.len() > 2 && value.starts_with("-0.") {
         return format!("-{}", &value[2..]);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:260:
[31m-    
(B[m[32m+
(B[m     value.to_string()
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:272:
     fn test_rounds_points_list() {
         let mut document = Document::new();
         let mut element = Element::new("polygon");
[31m-        element.attributes.insert("points".to_string(), "208.250977 77.1308594 223.069336 92.456789".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "points".to_string(),
(B[m[32m+            "208.250977 77.1308594 223.069336 92.456789".to_string(),
(B[m[32m+        );
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:279:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("points"), Some(&"208.251 77.131 223.069 92.457".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("points"),
(B[m[32m+            Some(&"208.251 77.131 223.069 92.457".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:285:
     fn test_rounds_viewbox() {
         let mut document = Document::new();
         let mut element = Element::new("svg");
[31m-        element.attributes.insert("viewBox".to_string(), "0.12345 1.6789 200.28423 200.28423".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "viewBox".to_string(),
(B[m[32m+            "0.12345 1.6789 200.28423 200.28423".to_string(),
(B[m[32m+        );
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:292:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("viewBox"), Some(&".123 1.679 200.284 200.284".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("viewBox"),
(B[m[32m+            Some(&".123 1.679 200.284 200.284".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:298:
     fn test_rounds_stroke_dasharray() {
         let mut document = Document::new();
         let mut element = Element::new("path");
[31m-        element.attributes.insert("stroke-dasharray".to_string(), "5.555 10.9999 15.123456".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "stroke-dasharray".to_string(),
(B[m[32m+            "5.555 10.9999 15.123456".to_string(),
(B[m[32m+        );
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:305:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("stroke-dasharray"), Some(&"5.555 11 15.123".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("stroke-dasharray"),
(B[m[32m+            Some(&"5.555 11 15.123".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:311:
     fn test_handles_enable_background_with_new() {
         let mut document = Document::new();
         let mut element = Element::new("svg");
[31m-        element.attributes.insert("enable-background".to_string(), "new 0.12345 1.6789 200.28423 200.28423".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "enable-background".to_string(),
(B[m[32m+            "new 0.12345 1.6789 200.28423 200.28423".to_string(),
(B[m[32m+        );
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:318:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("enable-background"), Some(&"new .123 1.679 200.284 200.284".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("enable-background"),
(B[m[32m+            Some(&"new .123 1.679 200.284 200.284".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:324:
     fn test_rounds_text_positioning() {
         let mut document = Document::new();
         let mut element = Element::new("text");
[31m-        element.attributes.insert("dx".to_string(), "1.234567 2.567890 3.999999".to_string());
(B[m[31m-        element.attributes.insert("dy".to_string(), "0.555 -0.333 0.125".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("dx".to_string(), "1.234567 2.567890 3.999999".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("dy".to_string(), "0.555 -0.333 0.125".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:332:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("dx"), Some(&"1.235 2.568 4".to_string()));
(B[m[31m-        assert_eq!(document.root.attributes.get("dy"), Some(&".555 -.333 .125".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("dx"),
(B[m[32m+            Some(&"1.235 2.568 4".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("dy"),
(B[m[32m+            Some(&".555 -.333 .125".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:339:
     fn test_handles_comma_separated_values() {
         let mut document = Document::new();
         let mut element = Element::new("polygon");
[31m-        element.attributes.insert("points".to_string(), "1.234567,2.567890,3.999999,4.12345".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "points".to_string(),
(B[m[32m+            "1.234567,2.567890,3.999999,4.12345".to_string(),
(B[m[32m+        );
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:346:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("points"), Some(&"1.235 2.568 4 4.123".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("points"),
(B[m[32m+            Some(&"1.235 2.568 4 4.123".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:352:
     fn test_handles_mixed_separators() {
         let mut document = Document::new();
         let mut element = Element::new("polygon");
[31m-        element.attributes.insert("points".to_string(), "1.234567, 2.567890 , 3.999999  4.12345".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "points".to_string(),
(B[m[32m+            "1.234567, 2.567890 , 3.999999  4.12345".to_string(),
(B[m[32m+        );
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:359:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("points"), Some(&"1.235 2.568 4 4.123".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("points"),
(B[m[32m+            Some(&"1.235 2.568 4 4.123".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:365:
     fn test_converts_units_in_lists() {
         let mut document = Document::new();
         let mut element = Element::new("polygon");
[31m-        element.attributes.insert("points".to_string(), "1in 96pt 3cm 4px".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("points".to_string(), "1in 96pt 3cm 4px".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:372:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        // 1in = 96px (shorter: "96" vs "1in"), 
(B[m[32m+        // 1in = 96px (shorter: "96" vs "1in"),
(B[m         // 96pt = 128px (shorter: "128" vs "96pt", do convert)
[31m-        // 3cm â‰ˆ 113.386px (longer: "113.386" vs "3cm", don't convert) 
(B[m[32m+        // 3cm â‰ˆ 113.386px (longer: "113.386" vs "3cm", don't convert)
(B[m         // 4px = 4 (remove px)
[31m-        assert_eq!(document.root.attributes.get("points"), Some(&"96 128 3cm 4".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("points"),
(B[m[32m+            Some(&"96 128 3cm 4".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:382:
     fn test_configurable_precision() {
         let mut document = Document::new();
         let mut element = Element::new("polygon");
[31m-        element.attributes.insert("points".to_string(), "1.23456 2.78901".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("points".to_string(), "1.23456 2.78901".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:389:
         let params = json!({"floatPrecision": 2});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("points"), Some(&"1.23 2.79".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("points"),
(B[m[32m+            Some(&"1.23 2.79".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:396:
     fn test_configurable_leading_zero() {
         let mut document = Document::new();
         let mut element = Element::new("polygon");
[31m-        element.attributes.insert("points".to_string(), "0.5 -0.25".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("points".to_string(), "0.5 -0.25".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:403:
         let params = json!({"leadingZero": false});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("points"), Some(&"0.5 -0.25".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("points"),
(B[m[32m+            Some(&"0.5 -0.25".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:410:
     fn test_preserves_non_list_attributes() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        element.attributes.insert("width".to_string(), "100.555".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100.555".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupListOfValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:418:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // These shouldn't be affected by this plugin
[31m-        assert_eq!(document.root.attributes.get("fill"), Some(&"red".to_string()));
(B[m[31m-        assert_eq!(document.root.attributes.get("width"), Some(&"100.555".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("fill"),
(B[m[32m+            Some(&"red".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("width"),
(B[m[32m+            Some(&"100.555".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_list_of_values.rs:426:
     fn test_plugin_name_and_description() {
         let mut plugin = CleanupListOfValuesPlugin;
         assert_eq!(plugin.name(), "cleanupListOfValues");
[31m-        assert_eq!(plugin.description(), "rounds list of values to the fixed precision");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "rounds list of values to the fixed precision"
(B[m[32m+        );
(B[m     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:7:
 
 use crate::ast::{Document, Element, Node};
 use crate::plugin::{Plugin, PluginInfo, PluginResult};
[32m+use regex::Regex;
(B[m use serde_json::Value;
 use std::collections::HashMap;
 use std::sync::LazyLock;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:13:
[31m-use regex::Regex;
(B[m 
 /// Regular expression to match numeric values with optional units
 static NUMERIC_VALUE_REGEX: LazyLock<Regex> = LazyLock::new(|| {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:20:
 /// Conversion factors from absolute units to pixels
 static ABSOLUTE_LENGTHS: LazyLock<HashMap<&'static str, f64>> = LazyLock::new(|| {
     [
[31m-        ("cm", 96.0 / 2.54),  // 96 DPI / 2.54 cm per inch
(B[m[31m-        ("mm", 96.0 / 25.4),  // 96 DPI / 25.4 mm per inch
(B[m[31m-        ("in", 96.0),         // 96 pixels per inch
(B[m[31m-        ("pt", 4.0 / 3.0),    // 4/3 pixels per point
(B[m[31m-        ("pc", 16.0),         // 16 pixels per pica
(B[m[31m-        ("px", 1.0),          // 1 pixel per pixel
(B[m[32m+        ("cm", 96.0 / 2.54), // 96 DPI / 2.54 cm per inch
(B[m[32m+        ("mm", 96.0 / 25.4), // 96 DPI / 25.4 mm per inch
(B[m[32m+        ("in", 96.0),        // 96 pixels per inch
(B[m[32m+        ("pt", 4.0 / 3.0),   // 4/3 pixels per point
(B[m[32m+        ("pc", 16.0),        // 16 pixels per pica
(B[m[32m+        ("px", 1.0),         // 1 pixel per pixel
(B[m     ]
     .into_iter()
     .collect()
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:62:
     /// Parse parameters from JSON value
     pub fn from_value(value: Option<&Value>) -> Self {
         let mut params = Self::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(map)) = value {
             if let Some(Value::Number(precision)) = map.get("floatPrecision") {
                 if let Some(precision) = precision.as_u64() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:79:
                 params.convert_to_px = *convert_to_px;
             }
         }
[31m-        
(B[m[32m+
(B[m         params
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:93:
         "rounds numeric values to the fixed precision, removes default \"px\" units"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = CleanupNumericValuesParams::from_value(params);
         visit_elements(&mut document.root, &config);
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:103:
 /// Visit all elements in the AST and apply numeric value cleanup
 fn visit_elements(element: &mut Element, config: &CleanupNumericValuesParams) {
     cleanup_numeric_values_in_element(element, config);
[31m-    
(B[m[32m+
(B[m     for child in &mut element.children {
         if let Node::Element(child_element) = child {
             visit_elements(child_element, config);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:117:
     if let Some(viewbox) = element.attributes.get_mut("viewBox") {
         cleanup_viewbox_value(viewbox, config);
     }
[31m-    
(B[m[32m+
(B[m     // Process all other attributes
     for (name, value) in &mut element.attributes {
         // Skip version attribute - it's a text string
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:124:
         if name == "version" {
             continue;
         }
[31m-        
(B[m[32m+
(B[m         // Skip viewBox as we handled it above
         if name == "viewBox" {
             continue;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:131:
         }
[31m-        
(B[m[32m+
(B[m         if let Some(cleaned) = cleanup_numeric_value(value, config) {
             *value = cleaned;
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:151:
             }
         })
         .collect();
[31m-    
(B[m[32m+
(B[m     *viewbox = nums.join(" ");
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:158:
 /// Clean up a single numeric value with optional units
 fn cleanup_numeric_value(value: &str, config: &CleanupNumericValuesParams) -> Option<String> {
     let captures = NUMERIC_VALUE_REGEX.captures(value)?;
[31m-    
(B[m[32m+
(B[m     let number_str = captures.get(1)?.as_str();
     let mut number: f64 = number_str.parse().ok()?;
     let unit = captures.get(3).map(|m| m.as_str()).unwrap_or("");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:165:
     let mut final_unit = unit;
[31m-    
(B[m[32m+
(B[m     // Convert absolute units to pixels if beneficial
     if config.convert_to_px && !unit.is_empty() && ABSOLUTE_LENGTHS.contains_key(unit) {
         let conversion_factor = ABSOLUTE_LENGTHS[unit];
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:170:
         let original_number: f64 = number_str.parse().unwrap();
         let px_value = original_number * conversion_factor;
         let px_rounded = round_to_precision(px_value, config.float_precision);
[31m-        
(B[m[32m+
(B[m         // Format the px value and see if it's shorter
         let px_formatted = format_number(px_rounded, config);
         let px_str = if config.default_px {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:178:
         } else {
             px_formatted.clone() + "px"
         };
[31m-        
(B[m[32m+
(B[m         // Use px conversion if it results in a shorter or equal string
         if px_str.len() <= value.len() {
             number = px_rounded;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:189:
     } else {
         number = round_to_precision(number, config.float_precision);
     }
[31m-    
(B[m[32m+
(B[m     // Format the number
     let mut result = format_number(number, config);
[31m-    
(B[m[32m+
(B[m     // Remove default 'px' units if enabled
     if config.default_px && final_unit == "px" {
         final_unit = "";
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:199:
     }
[31m-    
(B[m[32m+
(B[m     result.push_str(final_unit);
     Some(result)
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:220:
             .trim_end_matches('.')
             .to_string()
     };
[31m-    
(B[m[32m+
(B[m     if config.leading_zero {
         remove_leading_zero(&formatted)
     } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:233:
     if value.len() > 1 && value.starts_with("0.") {
         return value[1..].to_string();
     }
[31m-    
(B[m[32m+
(B[m     if value.len() > 2 && value.starts_with("-0.") {
         return format!("-{}", &value[2..]);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:240:
[31m-    
(B[m[32m+
(B[m     value.to_string()
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:252:
     fn test_rounds_decimal_values() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        element.attributes.insert("x".to_string(), "1.23456".to_string());
(B[m[31m-        element.attributes.insert("y".to_string(), "2.7891011".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("x".to_string(), "1.23456".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("y".to_string(), "2.7891011".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupNumericValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:260:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("x"), Some(&"1.235".to_string()));
(B[m[31m-        assert_eq!(document.root.attributes.get("y"), Some(&"2.789".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("x"),
(B[m[32m+            Some(&"1.235".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("y"),
(B[m[32m+            Some(&"2.789".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:267:
     fn test_removes_leading_zeros() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        element.attributes.insert("opacity".to_string(), "0.5".to_string());
(B[m[31m-        element.attributes.insert("fill-opacity".to_string(), "-0.25".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("opacity".to_string(), "0.5".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill-opacity".to_string(), "-0.25".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupNumericValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:275:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("opacity"), Some(&".5".to_string()));
(B[m[31m-        assert_eq!(document.root.attributes.get("fill-opacity"), Some(&"-.25".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("opacity"),
(B[m[32m+            Some(&".5".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("fill-opacity"),
(B[m[32m+            Some(&"-.25".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:282:
     fn test_removes_default_px_units() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        element.attributes.insert("width".to_string(), "100px".to_string());
(B[m[31m-        element.attributes.insert("height".to_string(), "50.5px".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100px".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50.5px".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupNumericValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:290:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("width"), Some(&"100".to_string()));
(B[m[31m-        assert_eq!(document.root.attributes.get("height"), Some(&"50.5".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("width"),
(B[m[32m+            Some(&"100".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("height"),
(B[m[32m+            Some(&"50.5".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:297:
     fn test_converts_units_to_px() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        element.attributes.insert("width".to_string(), "1in".to_string()); // 96px -> "96" (shorter)
(B[m[31m-        element.attributes.insert("height".to_string(), "1pt".to_string()); // 4/3 px -> "1.333" (longer, don't convert)
(B[m[31m-        element.attributes.insert("x".to_string(), "2in".to_string()); // 192px -> "192" (shorter)
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "1in".to_string()); // 96px -> "96" (shorter)
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "1pt".to_string()); // 4/3 px -> "1.333" (longer, don't convert)
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("x".to_string(), "2in".to_string()); // 192px -> "192" (shorter)
(B[m         document.root = element;
 
         let mut plugin = CleanupNumericValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:306:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("width"), Some(&"96".to_string()));
(B[m[31m-        assert_eq!(document.root.attributes.get("height"), Some(&"1pt".to_string())); // Not converted due to length
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("width"),
(B[m[32m+            Some(&"96".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("height"),
(B[m[32m+            Some(&"1pt".to_string())
(B[m[32m+        ); // Not converted due to length
(B[m         assert_eq!(document.root.attributes.get("x"), Some(&"192".to_string()));
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:314:
     fn test_preserves_version_attribute() {
         let mut document = Document::new();
         let mut element = Element::new("svg");
[31m-        element.attributes.insert("version".to_string(), "1.1".to_string());
(B[m[31m-        element.attributes.insert("width".to_string(), "1.1".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("version".to_string(), "1.1".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "1.1".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupNumericValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:322:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Version should be unchanged, width should be rounded
[31m-        assert_eq!(document.root.attributes.get("version"), Some(&"1.1".to_string()));
(B[m[31m-        assert_eq!(document.root.attributes.get("width"), Some(&"1.1".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("version"),
(B[m[32m+            Some(&"1.1".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("width"),
(B[m[32m+            Some(&"1.1".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:330:
     fn test_cleans_viewbox() {
         let mut document = Document::new();
         let mut element = Element::new("svg");
[31m-        element.attributes.insert("viewBox".to_string(), "0.12345 1.6789 100.555 50.9999".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "viewBox".to_string(),
(B[m[32m+            "0.12345 1.6789 100.555 50.9999".to_string(),
(B[m[32m+        );
(B[m         document.root = element;
 
         let mut plugin = CleanupNumericValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:337:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("viewBox"), Some(&".123 1.679 100.555 51".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("viewBox"),
(B[m[32m+            Some(&".123 1.679 100.555 51".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:343:
     fn test_configurable_precision() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        element.attributes.insert("x".to_string(), "1.23456".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("x".to_string(), "1.23456".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupNumericValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:350:
         let params = json!({"floatPrecision": 2});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         assert_eq!(document.root.attributes.get("x"), Some(&"1.23".to_string()));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:357:
     fn test_configurable_leading_zero() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        element.attributes.insert("opacity".to_string(), "0.5".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("opacity".to_string(), "0.5".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupNumericValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:364:
         let params = json!({"leadingZero": false});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("opacity"), Some(&"0.5".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("opacity"),
(B[m[32m+            Some(&"0.5".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:371:
     fn test_configurable_default_px() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        element.attributes.insert("width".to_string(), "100px".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100px".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupNumericValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:378:
         let params = json!({"defaultPx": false});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("width"), Some(&"100px".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("width"),
(B[m[32m+            Some(&"100px".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:385:
     fn test_preserves_non_numeric_values() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        element.attributes.insert("id".to_string(), "test123".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("id".to_string(), "test123".to_string());
(B[m         document.root = element;
 
         let mut plugin = CleanupNumericValuesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:393:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
[31m-        assert_eq!(document.root.attributes.get("fill"), Some(&"red".to_string()));
(B[m[31m-        assert_eq!(document.root.attributes.get("id"), Some(&"test123".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("fill"),
(B[m[32m+            Some(&"red".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("id"),
(B[m[32m+            Some(&"test123".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/cleanup_numeric_values.rs:400:
     fn test_plugin_name_and_description() {
         let mut plugin = CleanupNumericValuesPlugin;
         assert_eq!(plugin.name(), "cleanupNumericValues");
[31m-        assert_eq!(plugin.description(), "rounds numeric values to the fixed precision, removes default \"px\" units");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "rounds numeric values to the fixed precision, removes default \"px\" units"
(B[m[32m+        );
(B[m     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:1:
 // this_file: svgn/src/plugins/collapse_groups.rs
 
 use crate::ast::{Document, Element, Node};
[31m-use crate::plugin::{Plugin, PluginInfo, PluginResult, PluginError};
(B[m use crate::collections::{ANIMATION_ELEMS, INHERITABLE_ATTRS};
[32m+use crate::plugin::{Plugin, PluginError, PluginInfo, PluginResult};
(B[m use serde::{Deserialize, Serialize};
 
 #[derive(Debug, Clone, Serialize, Deserialize)]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:24:
                         }
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 // Check children recursively
                 for child in &element.children {
                     if Self::has_animated_attr(child, attr_name) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:54:
             if let Node::Element(first_child) = &mut element.children[0] {
                 // TODO: Add style computation for filter check when style support is implemented
                 let node_has_filter = element.attributes.contains_key("filter");
[31m-                
(B[m[32m+
(B[m                 // Check conditions for moving attributes
                 if first_child.attributes.get("id").is_none()
                     && !node_has_filter
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:61:
[31m-                    && (element.attributes.get("class").is_none() 
(B[m[32m+                    && (element.attributes.get("class").is_none()
(B[m                         || first_child.attributes.get("class").is_none())
[31m-                    && ((element.attributes.get("clip-path").is_none() 
(B[m[32m+                    && ((element.attributes.get("clip-path").is_none()
(B[m                         && element.attributes.get("mask").is_none())
[31m-                        || (first_child.name == "g" 
(B[m[32m+                        || (first_child.name == "g"
(B[m                             && element.attributes.get("transform").is_none()
                             && first_child.attributes.get("transform").is_none()))
                 {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:87:
                                 } else if existing_value == "inherit" {
                                     // Replace inherit with actual value
                                     first_child.attributes.insert(name, value);
[31m-                                } else if !INHERITABLE_ATTRS.contains(name.as_str()) 
(B[m[31m-                                    && existing_value != &value {
(B[m[32m+                                } else if !INHERITABLE_ATTRS.contains(name.as_str())
(B[m[32m+                                    && existing_value != &value
(B[m[32m+                                {
(B[m                                     // Non-inheritable attributes must match
                                     return false;
                                 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:149:
         "collapses useless groups"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&serde_json::Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&serde_json::Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let _config: CollapseGroupsConfig = if let Some(p) = params {
[31m-            serde_json::from_value(p.clone()).map_err(|e| PluginError::InvalidConfig(e.to_string()))?
(B[m[32m+            serde_json::from_value(p.clone())
(B[m[32m+                .map_err(|e| PluginError::InvalidConfig(e.to_string()))?
(B[m         } else {
             CollapseGroupsConfig {}
         };
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:170:
         if params.is_none() || params.unwrap().is_object() {
             Ok(())
         } else {
[31m-            Err(PluginError::InvalidConfig("Configuration must be an object or null".to_string()))
(B[m[32m+            Err(PluginError::InvalidConfig(
(B[m[32m+                "Configuration must be an object or null".to_string(),
(B[m[32m+            ))
(B[m         }
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:184:
     #[test]
     fn test_collapse_empty_group() {
         let input = r#"<svg><g><rect width="10" height="10"/></g></svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut doc = parser.parse(input).unwrap();
         let mut plugin = CollapseGroupsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:191:
         let config = serde_json::json!({});
         let info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &info, Some(&config)).unwrap();
[31m-        
(B[m[32m+
(B[m         // Check that the group was collapsed
         assert_eq!(doc.root.children.len(), 1);
         if let Node::Element(rect) = &doc.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:207:
     #[test]
     fn test_move_attributes_to_single_child() {
         let input = r#"<svg><g fill="red"><rect width="10" height="10"/></g></svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut doc = parser.parse(input).unwrap();
         let mut plugin = CollapseGroupsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:214:
         let config = serde_json::json!({});
         let info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &info, Some(&config)).unwrap();
[31m-        
(B[m[32m+
(B[m         // Check that the group was collapsed and attributes moved
         assert_eq!(doc.root.children.len(), 1);
         if let Node::Element(rect) = &doc.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:231:
     #[test]
     fn test_preserve_group_with_multiple_children() {
         let input = r#"<svg><g fill="red"><rect width="10" height="10"/><circle r="5"/></g></svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut doc = parser.parse(input).unwrap();
         let mut plugin = CollapseGroupsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:238:
         let config = serde_json::json!({});
         let info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &info, Some(&config)).unwrap();
[31m-        
(B[m[32m+
(B[m         // Group should be preserved because it has multiple children
         assert_eq!(doc.root.children.len(), 1);
         if let Node::Element(group) = &doc.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:254:
     #[test]
     fn test_concatenate_transforms() {
         let input = r#"<svg><g transform="translate(10,10)"><rect transform="scale(2)" width="10" height="10"/></g></svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut doc = parser.parse(input).unwrap();
         let mut plugin = CollapseGroupsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:261:
         let config = serde_json::json!({});
         let info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &info, Some(&config)).unwrap();
[31m-        
(B[m[32m+
(B[m         // Check that transforms were concatenated
         assert_eq!(doc.root.children.len(), 1);
         if let Node::Element(rect) = &doc.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:269:
             assert_eq!(rect.name, "rect");
[31m-            assert_eq!(rect.attributes.get("transform"), Some(&"translate(10,10) scale(2)".to_string()));
(B[m[32m+            assert_eq!(
(B[m[32m+                rect.attributes.get("transform"),
(B[m[32m+                Some(&"translate(10,10) scale(2)".to_string())
(B[m[32m+            );
(B[m             assert_eq!(rect.attributes.get("width"), Some(&"10".to_string()));
             assert_eq!(rect.attributes.get("height"), Some(&"10".to_string()));
         } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:278:
     #[test]
     fn test_nested_groups() {
         let input = r#"<svg><g><g><rect width="10" height="10"/></g></g></svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut doc = parser.parse(input).unwrap();
         let mut plugin = CollapseGroupsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:285:
         let config = serde_json::json!({});
         let info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &info, Some(&config)).unwrap();
[31m-        
(B[m[32m+
(B[m         // Both groups should be collapsed
         assert_eq!(doc.root.children.len(), 1);
         if let Node::Element(rect) = &doc.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:301:
     #[test]
     fn test_preserve_group_with_id() {
         let input = r#"<svg><g id="mygroup"><rect id="myrect" width="10" height="10"/></g></svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut doc = parser.parse(input).unwrap();
         let mut plugin = CollapseGroupsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:308:
         let config = serde_json::json!({});
         let info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &info, Some(&config)).unwrap();
[31m-        
(B[m[32m+
(B[m         // Group should NOT be preserved just because child has id
         // The group itself has id, so it can't move attributes to child
         assert_eq!(doc.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/collapse_groups.rs:322:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:21:
     fn name(&self) -> &'static str {
         "convertColors"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "converts colors: rgb() to #rrggbb and #rrggbb to #rgb"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:28:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = ConvertColorsConfig::from_params(params);
         let mut mask_counter = 0;
[31m-        
(B[m[32m+
(B[m         convert_colors_in_element(&mut document.root, &config, &mut mask_counter);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:49:
 impl ConvertColorsConfig {
     fn from_params(params: Option<&Value>) -> Self {
         let params = params.unwrap_or(&Value::Null);
[31m-        
(B[m[32m+
(B[m         Self {
[31m-            current_color: params.get("currentColor")
(B[m[32m+            current_color: params
(B[m[32m+                .get("currentColor")
(B[m                 .and_then(|v| v.as_str())
                 .map(|s| s.to_string()),
[31m-            names2hex: params.get("names2hex")
(B[m[32m+            names2hex: params
(B[m[32m+                .get("names2hex")
(B[m                 .and_then(|v| v.as_bool())
                 .unwrap_or(true),
[31m-            rgb2hex: params.get("rgb2hex")
(B[m[32m+            rgb2hex: params
(B[m[32m+                .get("rgb2hex")
(B[m                 .and_then(|v| v.as_bool())
                 .unwrap_or(true),
[31m-            convert_case: params.get("convertCase")
(B[m[32m+            convert_case: params
(B[m[32m+                .get("convertCase")
(B[m                 .and_then(|v| v.as_str())
                 .map(|s| s.to_string()),
[31m-            shorthex: params.get("shorthex")
(B[m[32m+            shorthex: params
(B[m[32m+                .get("shorthex")
(B[m                 .and_then(|v| v.as_bool())
                 .unwrap_or(true),
[31m-            shortname: params.get("shortname")
(B[m[32m+            shortname: params
(B[m[32m+                .get("shortname")
(B[m                 .and_then(|v| v.as_bool())
                 .unwrap_or(true),
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:73:
     }
 }
 
[31m-fn convert_colors_in_element(element: &mut Element, config: &ConvertColorsConfig, mask_counter: &mut usize) {
(B[m[32m+fn convert_colors_in_element(
(B[m[32m+    element: &mut Element,
(B[m[32m+    config: &ConvertColorsConfig,
(B[m[32m+    mask_counter: &mut usize,
(B[m[32m+) {
(B[m     // Track mask elements
     if element.name == "mask" {
         *mask_counter += 1;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:80:
     }
[31m-    
(B[m[32m+
(B[m     convert_colors_in_element_attrs(element, config, *mask_counter);
[31m-    
(B[m[32m+
(B[m     // Process children
     for child in &mut element.children {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:87:
             convert_colors_in_element(child_element, config, mask_counter);
         }
     }
[31m-    
(B[m[32m+
(B[m     // Untrack mask elements
     if element.name == "mask" {
         *mask_counter -= 1;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:94:
     }
 }
 
[31m-fn convert_colors_in_element_attrs(element: &mut Element, config: &ConvertColorsConfig, mask_counter: usize) {
(B[m[32m+fn convert_colors_in_element_attrs(
(B[m[32m+    element: &mut Element,
(B[m[32m+    config: &ConvertColorsConfig,
(B[m[32m+    mask_counter: usize,
(B[m[32m+) {
(B[m     let color_props = get_color_properties();
[31m-    
(B[m[32m+
(B[m     for (name, value) in element.attributes.iter_mut() {
         if color_props.contains(name.as_str()) {
             let mut val = value.clone();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:103:
[31m-            
(B[m[32m+
(B[m             // Convert colors to currentColor
             if let Some(ref current_color_pattern) = config.current_color {
                 if mask_counter == 0 && (val == *current_color_pattern || val != "none") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:107:
                     val = "currentColor".to_string();
                 }
             }
[31m-            
(B[m[32m+
(B[m             // Convert color names to hex
             if config.names2hex {
                 let color_name = val.to_lowercase();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:115:
                     val = hex_value.clone();
                 }
             }
[31m-            
(B[m[32m+
(B[m             // Convert rgb() to hex
             if config.rgb2hex {
                 if let Some(hex_color) = convert_rgb_to_hex(&val) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:122:
                     val = hex_color;
                 }
             }
[31m-            
(B[m[32m+
(B[m             // Apply case conversion
             if let Some(ref case) = config.convert_case {
                 if !includes_url_reference(&val) && val != "currentColor" {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:133:
                     }
                 }
             }
[31m-            
(B[m[32m+
(B[m             // Convert long hex to short hex
             if config.shorthex {
                 if let Some(short_hex) = convert_to_short_hex(&val) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:140:
                     val = short_hex;
                 }
             }
[31m-            
(B[m[32m+
(B[m             // Convert hex to short name (but not when we just converted from RGB)
             if config.shortname {
                 let color_name = val.to_lowercase();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:148:
                     val = short_name.clone();
                 }
             }
[31m-            
(B[m[32m+
(B[m             *value = val;
         }
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:167:
 
 fn get_color_names() -> HashMap<String, String> {
     let mut colors = HashMap::new();
[31m-    
(B[m[32m+
(B[m     // Basic color names (subset from SVG spec)
     colors.insert("aliceblue".to_string(), "#f0f8ff".to_string());
     colors.insert("antiquewhite".to_string(), "#faebd7".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:316:
     colors.insert("whitesmoke".to_string(), "#f5f5f5".to_string());
     colors.insert("yellow".to_string(), "#ff0".to_string());
     colors.insert("yellowgreen".to_string(), "#9acd32".to_string());
[31m-    
(B[m[32m+
(B[m     colors
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:323:
 fn get_color_short_names() -> HashMap<String, String> {
     let mut colors = HashMap::new();
[31m-    
(B[m[32m+
(B[m     // Hex to short names (reverse mapping)
     colors.insert("#000080".to_string(), "navy".to_string());
     colors.insert("#008000".to_string(), "green".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:340:
     colors.insert("#ff00ff".to_string(), "magenta".to_string());
     colors.insert("#ffffff".to_string(), "white".to_string());
     colors.insert("#000000".to_string(), "black".to_string());
[31m-    
(B[m[32m+
(B[m     colors
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:347:
 fn convert_rgb_to_hex(value: &str) -> Option<String> {
     let re = Regex::new(r"^rgb\(\s*([+-]?(?:\d*\.\d+|\d+\.?)%?)\s*[,\s]+\s*([+-]?(?:\d*\.\d+|\d+\.?)%?)\s*[,\s]+\s*([+-]?(?:\d*\.\d+|\d+\.?)%?)\s*\)$").ok()?;
[31m-    
(B[m[32m+
(B[m     let caps = re.captures(value)?;
     let mut nums = Vec::new();
[31m-    
(B[m[32m+
(B[m     for i in 1..=3 {
         let m = caps.get(i)?.as_str();
         let n = if m.contains('%') {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:359:
         };
         nums.push(n.clamp(0, 255) as u8);
     }
[31m-    
(B[m[32m+
(B[m     Some(format!("#{:02x}{:02x}{:02x}", nums[0], nums[1], nums[2]))
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:383:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element};
[31m-    use serde_json::json;
(B[m     use indexmap::IndexMap;
[32m+    use serde_json::json;
(B[m 
     fn create_test_document_with_colors() -> Document {
         let mut doc = Document::new();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:391:
         let mut element = Element::new("rect");
[31m-        
(B[m[32m+
(B[m         let mut attrs = IndexMap::new();
         attrs.insert("fill".to_string(), "red".to_string());
         attrs.insert("stroke".to_string(), "rgb(255, 0, 255)".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:396:
         element.attributes = attrs;
[31m-        
(B[m[32m+
(B[m         doc.root = element;
         doc
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:402:
     #[test]
     fn test_color_name_to_hex() {
         let mut plugin = ConvertColorsPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_document_with_colors();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut document, &plugin_info, None).unwrap();
[31m-        
(B[m[31m-        assert_eq!(document.root.attributes.get("fill"), Some(&"#f00".to_string()));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("fill"),
(B[m[32m+            Some(&"#f00".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:414:
     fn test_rgb_to_hex() {
         let mut plugin = ConvertColorsPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_document_with_colors();
[31m-        
(B[m[32m+
(B[m         // Disable shortname and shorthex conversion to keep long hex format
         let params = json!({
             "shortname": false,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:422:
             "shorthex": false
         });
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[31m-        assert_eq!(document.root.attributes.get("stroke"), Some(&"#ff00ff".to_string()));
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("stroke"),
(B[m[32m+            Some(&"#ff00ff".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:431:
     fn test_convert_rgb_to_hex_function() {
[31m-        assert_eq!(convert_rgb_to_hex("rgb(255, 0, 255)"), Some("#ff00ff".to_string()));
(B[m[31m-        assert_eq!(convert_rgb_to_hex("rgb(100%, 0%, 100%)"), Some("#ff00ff".to_string()));
(B[m[31m-        assert_eq!(convert_rgb_to_hex("rgb(50%, 100, 100%)"), Some("#7f64ff".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            convert_rgb_to_hex("rgb(255, 0, 255)"),
(B[m[32m+            Some("#ff00ff".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            convert_rgb_to_hex("rgb(100%, 0%, 100%)"),
(B[m[32m+            Some("#ff00ff".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            convert_rgb_to_hex("rgb(50%, 100, 100%)"),
(B[m[32m+            Some("#7f64ff".to_string())
(B[m[32m+        );
(B[m         assert_eq!(convert_rgb_to_hex("invalid"), None);
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:446:
     #[test]
     fn test_color_params() {
         let mut plugin = ConvertColorsPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         let mut document = create_test_document_with_colors();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "names2hex": false,
             "rgb2hex": true,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_colors.rs:455:
             "shortname": false,
             "shorthex": false
         });
[31m-        
(B[m[31m-        plugin.apply(&mut document, &plugin_info, Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &plugin_info, Some(&params))
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // names2hex is disabled, so "red" should stay as "red"
[31m-        assert_eq!(document.root.attributes.get("fill"), Some(&"red".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("fill"),
(B[m[32m+            Some(&"red".to_string())
(B[m[32m+        );
(B[m         // rgb2hex is enabled, so RGB should convert to hex
[31m-        assert_eq!(document.root.attributes.get("stroke"), Some(&"#ff00ff".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            document.root.attributes.get("stroke"),
(B[m[32m+            Some(&"#ff00ff".to_string())
(B[m[32m+        );
(B[m     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:17:
     if element.name != "ellipse" {
         return;
     }
[31m-    
(B[m[31m-    let rx = element.attributes.get("rx").map(|s| s.as_str()).unwrap_or("0");
(B[m[31m-    let ry = element.attributes.get("ry").map(|s| s.as_str()).unwrap_or("0");
(B[m[31m-    
(B[m[32m+
(B[m[32m+    let rx = element
(B[m[32m+        .attributes
(B[m[32m+        .get("rx")
(B[m[32m+        .map(|s| s.as_str())
(B[m[32m+        .unwrap_or("0");
(B[m[32m+    let ry = element
(B[m[32m+        .attributes
(B[m[32m+        .get("ry")
(B[m[32m+        .map(|s| s.as_str())
(B[m[32m+        .unwrap_or("0");
(B[m[32m+
(B[m     // Check if the ellipse can be converted to a circle
     if rx == ry || rx == "auto" || ry == "auto" {
         // Change element name to circle
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:27:
         element.name = "circle".to_string();
[31m-        
(B[m[32m+
(B[m         // Determine the radius value
         let radius = if rx == "auto" {
             ry.to_string()
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:32:
         } else {
             rx.to_string()
         };
[31m-        
(B[m[32m+
(B[m         // Remove rx and ry attributes
         element.attributes.shift_remove("rx");
         element.attributes.shift_remove("ry");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:39:
[31m-        
(B[m[32m+
(B[m         // Add r attribute
         element.attributes.insert("r".to_string(), radius);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:46:
 fn process_node(node: &mut Node) {
     if let Node::Element(ref mut element) = node {
         convert_ellipse(element);
[31m-        
(B[m[32m+
(B[m         // Process children
         for child in &mut element.children {
             process_node(child);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:58:
     fn name(&self) -> &'static str {
         "convertEllipseToCircle"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "converts non-eccentric <ellipse>s to <circle>s"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:65:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Process root element
         convert_ellipse(&mut document.root);
[31m-        
(B[m[32m+
(B[m         // Process children
         for child in &mut document.root.children {
             process_node(child);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:73:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:103:
     fn test_convert_equal_radii() {
         let mut doc = Document::default();
         doc.root = create_ellipse("50", "50", "25", "25");
[31m-        
(B[m[32m+
(B[m         let mut plugin = ConvertEllipseToCirclePlugin;
         let plugin_info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(doc.root.name, "circle");
         assert_eq!(doc.root.attributes.get("r"), Some(&"25".to_string()));
         assert_eq!(doc.root.attributes.get("rx"), None);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:121:
     fn test_keep_unequal_radii() {
         let mut doc = Document::default();
         doc.root = create_ellipse("50", "50", "30", "20");
[31m-        
(B[m[32m+
(B[m         let mut plugin = ConvertEllipseToCirclePlugin;
         let plugin_info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(doc.root.name, "ellipse");
         assert_eq!(doc.root.attributes.get("rx"), Some(&"30".to_string()));
         assert_eq!(doc.root.attributes.get("ry"), Some(&"20".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:137:
     fn test_convert_rx_auto() {
         let mut doc = Document::default();
         doc.root = create_ellipse("50", "50", "auto", "25");
[31m-        
(B[m[32m+
(B[m         let mut plugin = ConvertEllipseToCirclePlugin;
         let plugin_info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(doc.root.name, "circle");
         assert_eq!(doc.root.attributes.get("r"), Some(&"25".to_string()));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:151:
     fn test_convert_ry_auto() {
         let mut doc = Document::default();
         doc.root = create_ellipse("50", "50", "30", "auto");
[31m-        
(B[m[32m+
(B[m         let mut plugin = ConvertEllipseToCirclePlugin;
         let plugin_info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(doc.root.name, "circle");
         assert_eq!(doc.root.attributes.get("r"), Some(&"30".to_string()));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:170:
             attributes: IndexMap::new(),
             children: vec![],
         };
[31m-        ellipse.attributes.insert("cx".to_string(), "50".to_string());
(B[m[31m-        ellipse.attributes.insert("cy".to_string(), "50".to_string());
(B[m[32m+        ellipse
(B[m[32m+            .attributes
(B[m[32m+            .insert("cx".to_string(), "50".to_string());
(B[m[32m+        ellipse
(B[m[32m+            .attributes
(B[m[32m+            .insert("cy".to_string(), "50".to_string());
(B[m         // No rx/ry attributes - should default to "0"
[31m-        
(B[m[32m+
(B[m         doc.root = ellipse;
[31m-        
(B[m[32m+
(B[m         let mut plugin = ConvertEllipseToCirclePlugin;
         let plugin_info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(doc.root.name, "circle");
         assert_eq!(doc.root.attributes.get("r"), Some(&"0".to_string()));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:188:
     #[test]
     fn test_nested_ellipses() {
         let mut doc = Document::default();
[31m-        
(B[m[32m+
(B[m         let mut svg = Element {
             name: "svg".to_string(),
             namespaces: HashMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:195:
             attributes: IndexMap::new(),
             children: vec![],
         };
[31m-        
(B[m[31m-        svg.children.push(Node::Element(create_ellipse("25", "25", "10", "10")));
(B[m[31m-        svg.children.push(Node::Element(create_ellipse("75", "75", "20", "15")));
(B[m[31m-        
(B[m[32m+
(B[m[32m+        svg.children
(B[m[32m+            .push(Node::Element(create_ellipse("25", "25", "10", "10")));
(B[m[32m+        svg.children
(B[m[32m+            .push(Node::Element(create_ellipse("75", "75", "20", "15")));
(B[m[32m+
(B[m         doc.root = svg;
[31m-        
(B[m[32m+
(B[m         let mut plugin = ConvertEllipseToCirclePlugin;
         let plugin_info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // First ellipse should be converted
         if let Some(Node::Element(ref first)) = doc.root.children.get(0) {
             assert_eq!(first.name, "circle");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:212:
             assert_eq!(first.attributes.get("r"), Some(&"10".to_string()));
         }
[31m-        
(B[m[32m+
(B[m         // Second ellipse should remain
         if let Some(Node::Element(ref second)) = doc.root.children.get(1) {
             assert_eq!(second.name, "ellipse");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_ellipse_to_circle.rs:220:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:69:
                 // Only process gradients with exactly one stop
                 if stops.len() == 1 {
                     let stop = stops[0];
[31m-                    
(B[m[32m+
(B[m                     // Get the stop color
                     let stop_color = stop
                         .attributes
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:207:
             if element.attributes.contains_key("xlink:href") {
                 return true;
             }
[31m-            
(B[m[32m+
(B[m             for child in &element.children {
                 if let Node::Element(ref elem) = child {
                     if check_xlink(elem) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:237:
         "converts one-stop (single color) gradients to a plain color"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let mut gradients_to_remove = HashMap::new();
         let mut affected_defs = HashSet::new();
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:244:
         // First pass: identify gradients with only one stop
[31m-        self.process_element(&mut document.root, &mut gradients_to_remove, false, &mut affected_defs);
(B[m[32m+        self.process_element(
(B[m[32m+            &mut document.root,
(B[m[32m+            &mut gradients_to_remove,
(B[m[32m+            false,
(B[m[32m+            &mut affected_defs,
(B[m[32m+        );
(B[m 
         // Second pass: replace gradient references with solid colors
         if !gradients_to_remove.is_empty() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:293:
     fn test_plugin_creation() {
         let plugin = ConvertOneStopGradientsPlugin::new();
         assert_eq!(plugin.name(), "convertOneStopGradients");
[31m-        assert_eq!(plugin.description(), "converts one-stop (single color) gradients to a plain color");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "converts one-stop (single color) gradients to a plain color"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:300:
     fn test_extract_gradient_id() {
         let plugin = ConvertOneStopGradientsPlugin::new();
[31m-        
(B[m[32m+
(B[m         // Test valid gradient ID extraction
[31m-        assert_eq!(plugin.extract_gradient_id("url(#myGradient)"), Some("myGradient".to_string()));
(B[m[31m-        assert_eq!(plugin.extract_gradient_id("url(#grad1)"), Some("grad1".to_string()));
(B[m[31m-        
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.extract_gradient_id("url(#myGradient)"),
(B[m[32m+            Some("myGradient".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.extract_gradient_id("url(#grad1)"),
(B[m[32m+            Some("grad1".to_string())
(B[m[32m+        );
(B[m[32m+
(B[m         // Test invalid formats
         assert_eq!(plugin.extract_gradient_id("red"), None);
         assert_eq!(plugin.extract_gradient_id("url(myGradient)"), None);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:315:
         let mut plugin = ConvertOneStopGradientsPlugin::new();
         let mut doc = create_test_document();
         let info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         // Should not panic with empty document
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:325:
     fn test_apply_with_no_gradients() {
         let mut plugin = ConvertOneStopGradientsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add a simple rect element
         let mut rect_attrs = IndexMap::new();
         rect_attrs.insert("fill".to_string(), "red".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:332:
         rect_attrs.insert("width".to_string(), "100".to_string());
         rect_attrs.insert("height".to_string(), "100".to_string());
[31m-        
(B[m[32m+
(B[m         doc.root.children.push(Node::Element(Element {
             name: "rect".to_string(),
             attributes: rect_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:338:
             namespaces: std::collections::HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:345:
[31m-        
(B[m[32m+
(B[m         // Document should remain unchanged
         assert_eq!(doc.root.children.len(), 1);
         if let Node::Element(rect) = &doc.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_one_stop_gradients.rs:351:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_path_data.rs:6:
 //! It is currently only implemented as a stub. Full functionality to come.
 
 use crate::ast::Document;
[31m-use crate::plugin::{Plugin, PluginInfo, PluginResult, PluginError};
(B[m[32m+use crate::plugin::{Plugin, PluginError, PluginInfo, PluginResult};
(B[m use serde_json::Value;
 
 /// Plugin for `convertPathData` (not yet implemented)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_path_data.rs:21:
         "(stub) Converts path data to relative or absolute, optimizes segments, simplifies curves â€“ Not yet implemented"
     }
 
[31m-    fn apply(&mut self, _document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        _document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         Err(PluginError::ProcessingError(
             "convertPathData plugin not yet implemented in svgn. You may disable it to proceed, or watch for updates.".to_string()
         ))
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_path_data.rs:28:
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:5:
 //! This plugin converts rect, line, polyline, polygon, circle and ellipse elements
 //! to path elements for better optimization potential.
 
[31m-use crate::ast::{Document, Node, Element};
(B[m[32m+use crate::ast::{Document, Element, Node};
(B[m use crate::plugin::{Plugin, PluginInfo, PluginResult};
 use regex::Regex;
 use serde_json::Value;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:12:
 use std::sync::LazyLock;
 
[31m-static NUMBER_REGEX: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?").unwrap()
(B[m[31m-});
(B[m[32m+static NUMBER_REGEX: LazyLock<Regex> =
(B[m[32m+    LazyLock::new(|| Regex::new(r"[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?").unwrap());
(B[m 
 /// Plugin that converts basic shapes to path elements
 pub struct ConvertShapeToPathPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:22:
     fn name(&self) -> &'static str {
         "convertShapeToPath"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Converts basic shapes to more compact path form"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:29:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Parse parameters
         let convert_arcs = params
             .and_then(|v| v.get("convertArcs"))
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:34:
             .and_then(|v| v.as_bool())
             .unwrap_or(false);
[31m-        
(B[m[32m+
(B[m         let float_precision = params
             .and_then(|v| v.get("floatPrecision"))
             .and_then(|v| v.as_u64())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:40:
             .map(|p| p as u8);
[31m-        
(B[m[32m+
(B[m         // Process root element
         convert_shapes_in_element(&mut document.root, convert_arcs, float_precision);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:48:
 
 /// Recursively convert shapes in an element and its children
[31m-fn convert_shapes_in_element(element: &mut Element, convert_arcs: bool, float_precision: Option<u8>) {
(B[m[32m+fn convert_shapes_in_element(
(B[m[32m+    element: &mut Element,
(B[m[32m+    convert_arcs: bool,
(B[m[32m+    float_precision: Option<u8>,
(B[m[32m+) {
(B[m     // Process child elements
     for child in &mut element.children {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:54:
             convert_shapes_in_element(child_element, convert_arcs, float_precision);
         }
     }
[31m-    
(B[m[32m+
(B[m     // Convert current element if it's a shape
     convert_shape_element(element, convert_arcs, float_precision);
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:97:
         Some(h) => h,
         None => return,
     };
[31m-    
(B[m[32m+
(B[m     let x = match parse_coord(element.attr("x").map_or("0", |v| v)) {
         Some(x) => x,
         None => return,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:187:
         Some(p) => p,
         None => return,
     };
[31m-    
(B[m[32m+
(B[m     // Extract all numbers from the points string
     let coords: Vec<f64> = NUMBER_REGEX
         .find_iter(points_str)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:205:
 
     // Build path data
     let mut path_data = String::new();
[31m-    
(B[m[32m+
(B[m     for (i, chunk) in coords.chunks(2).enumerate() {
         if chunk.len() == 2 {
             if i == 0 {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:352:
         for (key, value) in attrs {
             attributes.insert(key.to_string(), value.to_string());
         }
[31m-        
(B[m[32m+
(B[m         Element {
             name: name.to_string(),
             attributes,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:363:
 
     #[test]
     fn test_convert_rect_basic() {
[31m-        let mut element = create_element("rect", vec![
(B[m[31m-            ("width", "32"),
(B[m[31m-            ("height", "32"),
(B[m[31m-        ]);
(B[m[32m+        let mut element = create_element("rect", vec![("width", "32"), ("height", "32")]);
(B[m 
         convert_rect(&mut element, None);
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:378:
 
     #[test]
     fn test_convert_rect_with_position() {
[31m-        let mut element = create_element("rect", vec![
(B[m[31m-            ("x", "20"),
(B[m[31m-            ("y", "10"),
(B[m[31m-            ("width", "50"),
(B[m[31m-            ("height", "40"),
(B[m[31m-        ]);
(B[m[32m+        let mut element = create_element(
(B[m[32m+            "rect",
(B[m[32m+            vec![("x", "20"), ("y", "10"), ("width", "50"), ("height", "40")],
(B[m[32m+        );
(B[m 
         convert_rect(&mut element, None);
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:393:
 
     #[test]
     fn test_rect_with_rounded_corners_not_converted() {
[31m-        let mut element = create_element("rect", vec![
(B[m[31m-            ("x", "10"),
(B[m[31m-            ("y", "10"),
(B[m[31m-            ("width", "50"),
(B[m[31m-            ("height", "50"),
(B[m[31m-            ("rx", "4"),
(B[m[31m-        ]);
(B[m[32m+        let mut element = create_element(
(B[m[32m+            "rect",
(B[m[32m+            vec![
(B[m[32m+                ("x", "10"),
(B[m[32m+                ("y", "10"),
(B[m[32m+                ("width", "50"),
(B[m[32m+                ("height", "50"),
(B[m[32m+                ("rx", "4"),
(B[m[32m+            ],
(B[m[32m+        );
(B[m 
         convert_rect(&mut element, None);
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:410:
 
     #[test]
     fn test_convert_line() {
[31m-        let mut element = create_element("line", vec![
(B[m[31m-            ("x1", "10"),
(B[m[31m-            ("y1", "10"),
(B[m[31m-            ("x2", "50"),
(B[m[31m-            ("y2", "20"),
(B[m[31m-        ]);
(B[m[32m+        let mut element = create_element(
(B[m[32m+            "line",
(B[m[32m+            vec![("x1", "10"), ("y1", "10"), ("x2", "50"), ("y2", "20")],
(B[m[32m+        );
(B[m 
         convert_line(&mut element, None);
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:429:
 
     #[test]
     fn test_convert_polyline() {
[31m-        let mut element = create_element("polyline", vec![
(B[m[31m-            ("points", "10,80 20,50 50,20 80,10"),
(B[m[31m-        ]);
(B[m[32m+        let mut element = create_element("polyline", vec![("points", "10,80 20,50 50,20 80,10")]);
(B[m 
         convert_polyline(&mut element, None);
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:442:
 
     #[test]
     fn test_convert_polygon() {
[31m-        let mut element = create_element("polygon", vec![
(B[m[31m-            ("points", "20 10 50 40 30 20"),
(B[m[31m-        ]);
(B[m[32m+        let mut element = create_element("polygon", vec![("points", "20 10 50 40 30 20")]);
(B[m 
         convert_polygon(&mut element, None);
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:455:
 
     #[test]
     fn test_convert_circle() {
[31m-        let mut element = create_element("circle", vec![
(B[m[31m-            ("cx", "50"),
(B[m[31m-            ("cy", "50"),
(B[m[31m-            ("r", "25"),
(B[m[31m-        ]);
(B[m[32m+        let mut element = create_element("circle", vec![("cx", "50"), ("cy", "50"), ("r", "25")]);
(B[m 
         convert_circle(&mut element, None);
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:466:
         assert_eq!(element.name, "path");
[31m-        assert_eq!(element.attr("d").unwrap(), "M50 25A25 25 0 1 0 50 75A25 25 0 1 0 50 25z");
(B[m[32m+        assert_eq!(
(B[m[32m+            element.attr("d").unwrap(),
(B[m[32m+            "M50 25A25 25 0 1 0 50 75A25 25 0 1 0 50 25z"
(B[m[32m+        );
(B[m         assert!(!element.has_attr("cx"));
         assert!(!element.has_attr("cy"));
         assert!(!element.has_attr("r"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_shape_to_path.rs:479:
         assert_eq!(format_number(50.0, None), "50");
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:42:
             )
             \s*(?:;|$)  # declaration end
         )
[31m-        "#
(B[m[32m+        "#,
(B[m     )
     .unwrap()
 });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:51:
     fn name(&self) -> &'static str {
         "convertStyleToAttrs"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Convert inline styles to SVG presentation attributes"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:58:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Process the root element and all its descendants
         convert_styles(&mut document.root);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:70:
     if let Some(style_value) = element.attributes.get("style").cloned() {
         let mut remaining_styles = Vec::new();
         let mut new_attributes = Vec::new();
[31m-        
(B[m[32m+
(B[m         // Parse CSS declarations
         for cap in CSS_DECLARATION_RE.captures_iter(&style_value) {
             if let (Some(prop_match), Some(value_match)) = (cap.get(1), cap.get(2)) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:77:
                 let property = prop_match.as_str().trim();
                 let value = strip_css_comments(value_match.as_str()).trim().to_string();
[31m-                
(B[m[32m+
(B[m                 // Check if this is a presentation attribute
                 if PRESENTATION_ATTRS.contains(property) {
                     // Don't override existing attributes
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:92:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         // Add new attributes
         for (name, value) in new_attributes {
             element.attributes.insert(name, value);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:99:
         }
[31m-        
(B[m[32m+
(B[m         // Update or remove style attribute
         if remaining_styles.is_empty() {
             element.attributes.shift_remove("style");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:104:
         } else {
[31m-            element.attributes.insert("style".to_string(), remaining_styles.join("; "));
(B[m[32m+            element
(B[m[32m+                .attributes
(B[m[32m+                .insert("style".to_string(), remaining_styles.join("; "));
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     // Recursively process child elements
     for child in &mut element.children {
         if let Node::Element(ref mut child_elem) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:126:
 mod tests {
     use super::*;
     use crate::parser::Parser;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_convert_style_to_attrs() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:133:
             <rect style="fill: red; stroke: blue; opacity: 0.5" width="100" height="100"/>
             <circle style="fill: green; custom-prop: value" r="50"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = ConvertStyleToAttrsPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         plugin.apply(&mut document, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // Find rect element
[31m-        let rect = document.root.child_elements().find(|e| e.name == "rect").unwrap();
(B[m[32m+        let rect = document
(B[m[32m+            .root
(B[m[32m+            .child_elements()
(B[m[32m+            .find(|e| e.name == "rect")
(B[m[32m+            .unwrap();
(B[m         assert_eq!(rect.attributes.get("fill"), Some(&"red".to_string()));
         assert_eq!(rect.attributes.get("stroke"), Some(&"blue".to_string()));
         assert_eq!(rect.attributes.get("opacity"), Some(&"0.5".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:149:
         assert!(!rect.attributes.contains_key("style"));
[31m-        
(B[m[32m+
(B[m         // Find circle element - custom-prop should remain in style
[31m-        let circle = document.root.child_elements().find(|e| e.name == "circle").unwrap();
(B[m[32m+        let circle = document
(B[m[32m+            .root
(B[m[32m+            .child_elements()
(B[m[32m+            .find(|e| e.name == "circle")
(B[m[32m+            .unwrap();
(B[m         assert_eq!(circle.attributes.get("fill"), Some(&"green".to_string()));
[31m-        assert_eq!(circle.attributes.get("style"), Some(&"custom-prop: value".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            circle.attributes.get("style"),
(B[m[32m+            Some(&"custom-prop: value".to_string())
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_preserve_existing_attributes() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:160:
             <rect style="fill: red; stroke: blue" fill="green" width="100"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = ConvertStyleToAttrsPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         plugin.apply(&mut document, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // Check that existing fill attribute is preserved
[31m-        let rect = document.root.child_elements().find(|e| e.name == "rect").unwrap();
(B[m[32m+        let rect = document
(B[m[32m+            .root
(B[m[32m+            .child_elements()
(B[m[32m+            .find(|e| e.name == "rect")
(B[m[32m+            .unwrap();
(B[m         assert_eq!(rect.attributes.get("fill"), Some(&"green".to_string()));
         assert_eq!(rect.attributes.get("stroke"), Some(&"blue".to_string()));
         assert_eq!(rect.attributes.get("style"), Some(&"fill: red".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:175:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_complex_css_parsing() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:180:
             <rect style="/* comment */ fill: url(#grad); stroke: /* inline */ blue; font-family: 'Arial', sans-serif"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = ConvertStyleToAttrsPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         plugin.apply(&mut document, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // Check parsing of complex CSS
[31m-        let rect = document.root.child_elements().find(|e| e.name == "rect").unwrap();
(B[m[32m+        let rect = document
(B[m[32m+            .root
(B[m[32m+            .child_elements()
(B[m[32m+            .find(|e| e.name == "rect")
(B[m[32m+            .unwrap();
(B[m         assert_eq!(rect.attributes.get("fill"), Some(&"url(#grad)".to_string()));
         assert_eq!(rect.attributes.get("stroke"), Some(&"blue".to_string()));
[31m-        assert_eq!(rect.attributes.get("font-family"), Some(&"'Arial', sans-serif".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            rect.attributes.get("font-family"),
(B[m[32m+            Some(&"'Arial', sans-serif".to_string())
(B[m[32m+        );
(B[m         assert!(!rect.attributes.contains_key("style"));
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/convert_style_to_attrs.rs:198:
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:16:
     fn name(&self) -> &'static str {
         "mergeStyles"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Merge multiple <style> elements into one"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:23:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Process the root element
         merge_styles(&mut document.root);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:33:
 fn merge_styles(element: &mut Element) {
     let mut style_contents: Vec<(Option<String>, String)> = Vec::new();
     let mut first_style_index: Option<usize> = None;
[31m-    
(B[m[32m+
(B[m     // First pass: collect all style elements
     for (index, child) in element.children.iter().enumerate() {
         if let Node::Element(ref elem) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:42:
                 if first_style_index.is_none() {
                     first_style_index = Some(index);
                 }
[31m-                
(B[m[32m+
(B[m                 // Get media attribute if present
                 let media = elem.attributes.get("media").cloned();
[31m-                
(B[m[32m+
(B[m                 // Extract text content from style element
                 let mut content = String::new();
                 for child in &elem.children {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:55:
                         content.push_str(cdata);
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 if !content.trim().is_empty() {
                     style_contents.push((media, content));
                 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:62:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // If we have multiple style elements, merge them
     if style_contents.len() > 1 {
         // Create merged content
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:69:
         let mut merged_content = String::new();
         let mut needs_cdata = false;
[31m-        
(B[m[32m+
(B[m         for (media, content) in &style_contents {
             // Check if we need CDATA wrapper
             if content.contains('<') || content.contains('&') {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:75:
                 needs_cdata = true;
             }
[31m-            
(B[m[32m+
(B[m             if let Some(media_value) = media {
                 // Wrap content with @media if media attribute exists
[31m-                merged_content.push_str(&format!("@media {} {{\n{}\n}}\n", media_value, content.trim()));
(B[m[32m+                merged_content.push_str(&format!(
(B[m[32m+                    "@media {} {{\n{}\n}}\n",
(B[m[32m+                    media_value,
(B[m[32m+                    content.trim()
(B[m[32m+                ));
(B[m             } else {
                 merged_content.push_str(content);
                 merged_content.push('\n');
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:84:
             }
         }
[31m-        
(B[m[32m+
(B[m         // Create the merged style element
         if let Some(first_index) = first_style_index {
             let mut merged_style = Element::new("style");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:90:
[31m-            
(B[m[32m+
(B[m             // Add the merged content
             if needs_cdata {
                 merged_style.children.push(Node::CData(merged_content));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:94:
             } else {
                 merged_style.children.push(Node::Text(merged_content));
             }
[31m-            
(B[m[32m+
(B[m             // Replace the first style element with the merged one
             element.children[first_index] = Node::Element(merged_style);
[31m-            
(B[m[32m+
(B[m             // Mark indices of style elements to remove (all except the first one)
             let mut indices_to_remove = Vec::new();
             for (index, child) in element.children.iter().enumerate() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:107:
                     }
                 }
             }
[31m-            
(B[m[32m+
(B[m             // Remove style elements in reverse order to maintain correct indices
             for &index in indices_to_remove.iter().rev() {
                 element.children.remove(index);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:114:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Remove empty style elements
     element.children.retain(|child| {
         if let Node::Element(ref elem) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:135:
             true
         }
     });
[31m-    
(B[m[32m+
(B[m     // Recursively process child elements
     for child in &mut element.children {
         if let Node::Element(ref mut elem) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:149:
 mod tests {
     use super::*;
     use crate::parser::Parser;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_merge_styles() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:158:
             <rect class="a"/>
             <rect class="b"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = MergeStylesPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         plugin.apply(&mut document, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // Check that only one style element remains
         assert_eq!(count_style_elements(&document.root), 1);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:172:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_merge_styles_with_media() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:177:
             <style>.b{fill:blue}</style>
             <style media="screen">.c{fill:green}</style>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = MergeStylesPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         plugin.apply(&mut document, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // Check that only one style element remains
         assert_eq!(count_style_elements(&document.root), 1);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:191:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_empty_styles() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:199:
             
             </style>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = MergeStylesPlugin;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         plugin.apply(&mut document, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // Check that only one style element remains (the non-empty one)
         assert_eq!(count_style_elements(&document.root), 1);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:213:
[31m-    
(B[m[32m+
(B[m     fn count_style_elements(element: &Element) -> usize {
         let mut count = 0;
         for child in &element.children {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/merge_styles.rs:224:
         count
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:5:
 //! This plugin performs basic CSS minification by removing whitespace,
 //! comments, and unnecessary semicolons from CSS content.
 
[31m-use crate::ast::{Document, Node, Element};
(B[m[32m+use crate::ast::{Document, Element, Node};
(B[m use crate::plugin::{Plugin, PluginInfo, PluginResult};
 use regex::Regex;
 use serde_json::Value;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:12:
 use std::sync::LazyLock;
 
 // Regular expressions for CSS minification
[31m-static CSS_COMMENT_REGEX: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/").unwrap()
(B[m[31m-});
(B[m[32m+static CSS_COMMENT_REGEX: LazyLock<Regex> =
(B[m[32m+    LazyLock::new(|| Regex::new(r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/").unwrap());
(B[m 
[31m-static CSS_WHITESPACE_REGEX: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"\s+").unwrap()
(B[m[31m-});
(B[m[32m+static CSS_WHITESPACE_REGEX: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"\s+").unwrap());
(B[m 
[31m-static CSS_SEMICOLON_REGEX: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r";\s*}").unwrap()
(B[m[31m-});
(B[m[32m+static CSS_SEMICOLON_REGEX: LazyLock<Regex> = LazyLock::new(|| Regex::new(r";\s*}").unwrap());
(B[m 
[31m-static CSS_TRAILING_SEMICOLON_REGEX: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r";\s*$").unwrap()
(B[m[31m-});
(B[m[32m+static CSS_TRAILING_SEMICOLON_REGEX: LazyLock<Regex> =
(B[m[32m+    LazyLock::new(|| Regex::new(r";\s*$").unwrap());
(B[m 
[31m-static CSS_COLON_SPACE_REGEX: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r":\s+").unwrap()
(B[m[31m-});
(B[m[32m+static CSS_COLON_SPACE_REGEX: LazyLock<Regex> = LazyLock::new(|| Regex::new(r":\s+").unwrap());
(B[m 
[31m-static CSS_BRACKET_SPACE_REGEX: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"\s*([{}:;,>+~])\s*").unwrap()
(B[m[31m-});
(B[m[32m+static CSS_BRACKET_SPACE_REGEX: LazyLock<Regex> =
(B[m[32m+    LazyLock::new(|| Regex::new(r"\s*([{}:;,>+~])\s*").unwrap());
(B[m 
 /// Plugin that minifies CSS in style elements and style attributes
 pub struct MinifyStylesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:43:
     fn name(&self) -> &'static str {
         "minifyStyles"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Minifies CSS in style elements and style attributes"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:50:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Parse parameters
         let remove_comments = params
             .and_then(|v| v.get("comments"))
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:55:
             .and_then(|v| v.as_bool())
             .unwrap_or(true);
[31m-        
(B[m[32m+
(B[m         // Process root element
         minify_styles_in_element(&mut document.root, remove_comments);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:70:
             minify_styles_in_element(child_element, remove_comments);
         }
     }
[31m-    
(B[m[32m+
(B[m     // Minify style elements
     if element.name == "style" {
         minify_style_element_content(element, remove_comments);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:77:
     }
[31m-    
(B[m[32m+
(B[m     // Minify style attributes
     if element.has_attr("style") {
         if let Some(style_value) = element.attr("style") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:88:
 /// Minify CSS content in a style element
 fn minify_style_element_content(element: &mut Element, remove_comments: bool) {
     let mut modified = false;
[31m-    
(B[m[32m+
(B[m     for child in &mut element.children {
         match child {
             Node::Text(text) => {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:108:
             _ => {}
         }
     }
[31m-    
(B[m[32m+
(B[m     // If all CSS content is empty after minification, mark for removal
     if modified {
[31m-        let all_empty = element.children.iter().all(|child| {
(B[m[31m-            match child {
(B[m[31m-                Node::Text(text) => text.trim().is_empty(),
(B[m[31m-                Node::CData(cdata) => cdata.trim().is_empty(),
(B[m[31m-                _ => true,
(B[m[31m-            }
(B[m[32m+        let all_empty = element.children.iter().all(|child| match child {
(B[m[32m+            Node::Text(text) => text.trim().is_empty(),
(B[m[32m+            Node::CData(cdata) => cdata.trim().is_empty(),
(B[m[32m+            _ => true,
(B[m         });
[31m-        
(B[m[32m+
(B[m         if all_empty {
             // Clear the element by removing all children
             element.clear_children();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:129:
 /// Perform basic CSS minification
 fn minify_css(css: &str, remove_comments: bool) -> String {
     let mut result = css.to_string();
[31m-    
(B[m[32m+
(B[m     // Remove comments if requested
     if remove_comments {
         result = CSS_COMMENT_REGEX.replace_all(&result, "").to_string();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:136:
     }
[31m-    
(B[m[32m+
(B[m     // Normalize whitespace
     result = CSS_WHITESPACE_REGEX.replace_all(&result, " ").to_string();
[31m-    
(B[m[32m+
(B[m     // Remove space around special characters
[31m-    result = CSS_BRACKET_SPACE_REGEX.replace_all(&result, "$1").to_string();
(B[m[31m-    
(B[m[32m+    result = CSS_BRACKET_SPACE_REGEX
(B[m[32m+        .replace_all(&result, "$1")
(B[m[32m+        .to_string();
(B[m[32m+
(B[m     // Remove space after colons
     result = CSS_COLON_SPACE_REGEX.replace_all(&result, ":").to_string();
[31m-    
(B[m[32m+
(B[m     // Remove unnecessary semicolons before closing braces
     result = CSS_SEMICOLON_REGEX.replace_all(&result, "}").to_string();
[31m-    
(B[m[32m+
(B[m     // Remove trailing semicolons
[31m-    result = CSS_TRAILING_SEMICOLON_REGEX.replace_all(&result, "").to_string();
(B[m[31m-    
(B[m[32m+    result = CSS_TRAILING_SEMICOLON_REGEX
(B[m[32m+        .replace_all(&result, "")
(B[m[32m+        .to_string();
(B[m[32m+
(B[m     // Trim leading and trailing whitespace
     result.trim().to_string()
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:157:
 /// Minify a CSS block (for style attributes)
 fn minify_css_block(css: &str, remove_comments: bool) -> String {
     let mut result = minify_css(css, remove_comments);
[31m-    
(B[m[32m+
(B[m     // For style attributes, ensure there's no trailing semicolon
     if result.ends_with(';') {
         result.pop();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:164:
     }
[31m-    
(B[m[32m+
(B[m     result
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:178:
         for (key, value) in attrs {
             attributes.insert(key.to_string(), value.to_string());
         }
[31m-        
(B[m[32m+
(B[m         Element {
             name: name.to_string(),
             attributes,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:233:
     fn test_minify_style_element() {
         let mut element = create_style_element("  body  {  margin : 0 ;  }  ");
         minify_style_element_content(&mut element, true);
[31m-        
(B[m[32m+
(B[m         if let Some(Node::Text(text)) = element.children.first() {
             assert_eq!(text, "body{margin:0}");
         } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:245:
     fn test_empty_style_element_removal() {
         let mut element = create_style_element("/* only comments */");
         minify_style_element_content(&mut element, true);
[31m-        
(B[m[32m+
(B[m         // Should be empty after removing comments
         assert!(element.children.is_empty());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:252:
 
     #[test]
     fn test_style_attribute_minification() {
[31m-        let mut element = create_element("rect", vec![
(B[m[31m-            ("style", "margin: 10px; padding: 5px;"),
(B[m[31m-        ]);
(B[m[31m-        
(B[m[32m+        let mut element = create_element("rect", vec![("style", "margin: 10px; padding: 5px;")]);
(B[m[32m+
(B[m         minify_styles_in_element(&mut element, true);
[31m-        
(B[m[32m+
(B[m         assert_eq!(element.attr("style").unwrap(), "margin:10px;padding:5px");
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/minify_styles.rs:286:
         assert_eq!(result, "color:red !important;margin:0");
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/mod.rs:6:
 // This module contains all the built-in plugins that can be used to optimize
 // SVG documents. Each plugin implements the `Plugin` trait.
 
[32m+pub mod add_attributes_to_svg_element;
(B[m[32m+pub mod add_classes_to_svg_element;
(B[m pub mod cleanup_attrs;
 pub mod cleanup_enable_background;
 pub mod cleanup_ids;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/mod.rs:12:
 pub mod cleanup_list_of_values;
 pub mod cleanup_numeric_values;
[32m+pub mod convert_colors;
(B[m[32m+pub mod convert_style_to_attrs;
(B[m[32m+pub mod merge_styles;
(B[m[32m+pub mod remove_attrs;
(B[m pub mod remove_comments;
 pub mod remove_desc;
 pub mod remove_doctype;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/mod.rs:17:
 pub mod remove_empty_attrs;
 pub mod remove_empty_containers;
 pub mod remove_empty_text;
[31m-pub mod remove_attrs;
(B[m pub mod remove_metadata;
[32m+pub mod remove_style_element;
(B[m pub mod remove_title;
 pub mod remove_unknowns_and_defaults;
 pub mod remove_xml_proc_inst;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/mod.rs:25:
 pub mod sort_attrs;
[31m-pub mod remove_style_element;
(B[m[31m-pub mod merge_styles;
(B[m[31m-pub mod convert_style_to_attrs;
(B[m[31m-pub mod convert_colors;
(B[m[31m-pub mod add_attributes_to_svg_element;
(B[m[31m-pub mod add_classes_to_svg_element;
(B[m // pub mod remove_attributes_by_selector; // TODO: Fix CSS selector parsing
[31m-pub mod remove_deprecated_attrs;
(B[m[31m-pub mod convert_ellipse_to_circle;
(B[m pub mod collapse_groups;
[32m+pub mod convert_ellipse_to_circle;
(B[m pub mod convert_one_stop_gradients;
[32m+pub mod convert_path_data;
(B[m[32m+pub mod convert_shape_to_path;
(B[m[32m+pub mod minify_styles;
(B[m pub mod prefix_ids;
[32m+pub mod remove_deprecated_attrs;
(B[m[32m+pub mod remove_dimensions;
(B[m pub mod remove_editors_ns_data;
 pub mod remove_elements_by_attr;
[31m-pub mod remove_dimensions;
(B[m[31m-pub mod convert_path_data;
(B[m[32m+pub mod remove_hidden_elems;
(B[m[32m+pub mod remove_non_inheritable_group_attrs;
(B[m[32m+pub mod remove_off_canvas_paths;
(B[m[32m+pub mod remove_raster_images;
(B[m pub mod remove_scripts;
[31m-pub mod remove_useless_defs;
(B[m pub mod remove_unused_ns;
[32m+pub mod remove_useless_defs;
(B[m pub mod remove_view_box;
 pub mod remove_xlink;
 pub mod remove_xmlns;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/mod.rs:48:
[31m-pub mod remove_raster_images;
(B[m pub mod sort_defs_children;
[31m-pub mod remove_hidden_elems;
(B[m[31m-pub mod remove_non_inheritable_group_attrs;
(B[m[31m-pub mod remove_off_canvas_paths;
(B[m[31m-pub mod convert_shape_to_path;
(B[m[31m-pub mod minify_styles;
(B[m 
 // Re-export plugins
[32m+pub use add_attributes_to_svg_element::AddAttributesToSVGElementPlugin;
(B[m[32m+pub use add_classes_to_svg_element::AddClassesToSVGElementPlugin;
(B[m pub use cleanup_attrs::CleanupAttrsPlugin;
 pub use cleanup_enable_background::CleanupEnableBackgroundPlugin;
 pub use cleanup_ids::CleanupIdsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/mod.rs:60:
 pub use cleanup_list_of_values::CleanupListOfValuesPlugin;
 pub use cleanup_numeric_values::CleanupNumericValuesPlugin;
[32m+pub use convert_colors::ConvertColorsPlugin;
(B[m[32m+pub use convert_style_to_attrs::ConvertStyleToAttrsPlugin;
(B[m[32m+pub use merge_styles::MergeStylesPlugin;
(B[m[32m+pub use remove_attrs::RemoveAttrsPlugin;
(B[m pub use remove_comments::RemoveCommentsPlugin;
 pub use remove_desc::RemoveDescPlugin;
 pub use remove_doctype::RemoveDoctypePlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/mod.rs:65:
 pub use remove_empty_attrs::RemoveEmptyAttrsPlugin;
 pub use remove_empty_containers::RemoveEmptyContainersPlugin;
 pub use remove_empty_text::RemoveEmptyTextPlugin;
[31m-pub use remove_attrs::RemoveAttrsPlugin;
(B[m pub use remove_metadata::RemoveMetadataPlugin;
[32m+pub use remove_style_element::RemoveStyleElement;
(B[m pub use remove_title::RemoveTitlePlugin;
 pub use remove_unknowns_and_defaults::RemoveUnknownsAndDefaultsPlugin;
 pub use remove_xml_proc_inst::RemoveXMLProcInstPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/mod.rs:73:
 pub use sort_attrs::SortAttrsPlugin;
[31m-pub use remove_style_element::RemoveStyleElement;
(B[m[31m-pub use merge_styles::MergeStylesPlugin;
(B[m[31m-pub use convert_style_to_attrs::ConvertStyleToAttrsPlugin;
(B[m[31m-pub use convert_colors::ConvertColorsPlugin;
(B[m[31m-pub use add_attributes_to_svg_element::AddAttributesToSVGElementPlugin;
(B[m[31m-pub use add_classes_to_svg_element::AddClassesToSVGElementPlugin;
(B[m // pub use remove_attributes_by_selector::RemoveAttributesBySelectorPlugin; // TODO: Fix CSS selector parsing
[31m-pub use remove_deprecated_attrs::RemoveDeprecatedAttrsPlugin;
(B[m[31m-pub use convert_path_data::ConvertPathDataPlugin;
(B[m[31m-pub use convert_ellipse_to_circle::ConvertEllipseToCirclePlugin;
(B[m pub use collapse_groups::CollapseGroupsPlugin;
[32m+pub use convert_ellipse_to_circle::ConvertEllipseToCirclePlugin;
(B[m pub use convert_one_stop_gradients::ConvertOneStopGradientsPlugin;
[32m+pub use convert_path_data::ConvertPathDataPlugin;
(B[m[32m+pub use convert_shape_to_path::ConvertShapeToPathPlugin;
(B[m[32m+pub use minify_styles::MinifyStylesPlugin;
(B[m pub use prefix_ids::PrefixIdsPlugin;
[32m+pub use remove_deprecated_attrs::RemoveDeprecatedAttrsPlugin;
(B[m[32m+pub use remove_dimensions::RemoveDimensionsPlugin;
(B[m pub use remove_editors_ns_data::RemoveEditorsNSDataPlugin;
 pub use remove_elements_by_attr::RemoveElementsByAttrPlugin;
[31m-pub use remove_dimensions::RemoveDimensionsPlugin;
(B[m[32m+pub use remove_hidden_elems::RemoveHiddenElemsPlugin;
(B[m[32m+pub use remove_non_inheritable_group_attrs::RemoveNonInheritableGroupAttrsPlugin;
(B[m[32m+pub use remove_off_canvas_paths::RemoveOffCanvasPathsPlugin;
(B[m[32m+pub use remove_raster_images::RemoveRasterImagesPlugin;
(B[m pub use remove_scripts::RemoveScriptsPlugin;
[31m-pub use remove_useless_defs::RemoveUselessDefsPlugin;
(B[m pub use remove_unused_ns::RemoveUnusedNSPlugin;
[32m+pub use remove_useless_defs::RemoveUselessDefsPlugin;
(B[m[32m+pub use remove_useless_transforms::RemoveUselessTransformsPlugin;
(B[m pub use remove_view_box::RemoveViewBoxPlugin;
 pub use remove_xlink::RemoveXlinkPlugin;
 pub use remove_xmlns::RemoveXMLNSPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/mod.rs:96:
[31m-pub use remove_raster_images::RemoveRasterImagesPlugin;
(B[m pub use sort_defs_children::SortDefsChildrenPlugin;
[31m-pub use remove_hidden_elems::RemoveHiddenElemsPlugin;
(B[m[31m-pub use remove_non_inheritable_group_attrs::RemoveNonInheritableGroupAttrsPlugin;
(B[m[31m-pub use remove_off_canvas_paths::RemoveOffCanvasPathsPlugin;
(B[m[31m-pub use convert_shape_to_path::ConvertShapeToPathPlugin;
(B[m[31m-pub use minify_styles::MinifyStylesPlugin;
(B[m[31m-pub use remove_useless_transforms::RemoveUselessTransformsPlugin;
(B[m[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:44:
 
     fn parse_config(&self, params: Option<&Value>) -> PrefixIdsConfig {
         let mut config = PrefixIdsConfig::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(obj)) = params {
             if let Some(Value::String(prefix)) = obj.get("prefix") {
                 config.prefix = Some(prefix.clone());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:51:
             }
[31m-            
(B[m[32m+
(B[m             if let Some(Value::String(delim)) = obj.get("delim") {
                 config.delim = delim.clone();
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:56:
[31m-            
(B[m[32m+
(B[m             if let Some(Value::Bool(prefix_ids)) = obj.get("prefixIds") {
                 config.prefix_ids = *prefix_ids;
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:60:
[31m-            
(B[m[32m+
(B[m             if let Some(Value::Bool(prefix_class_names)) = obj.get("prefixClassNames") {
                 config.prefix_class_names = *prefix_class_names;
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:64:
         }
[31m-        
(B[m[32m+
(B[m         config
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:84:
         if let Some(prefix) = &config.prefix {
             return format!("{}{}", prefix, config.delim);
         }
[31m-        
(B[m[32m+
(B[m         if let Some(path) = &info.path {
             let basename = Self::get_basename(path);
             if !basename.is_empty() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:91:
[31m-                return format!("{}{}", Self::escape_identifier_name(&basename), config.delim);
(B[m[32m+                return format!(
(B[m[32m+                    "{}{}",
(B[m[32m+                    Self::escape_identifier_name(&basename),
(B[m[32m+                    config.delim
(B[m[32m+                );
(B[m             }
         }
[31m-        
(B[m[32m+
(B[m         format!("prefix{}", config.delim)
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:104:
     }
 
     fn prefix_reference(&self, prefix: &str, reference: &str) -> Option<String> {
[31m-        reference.strip_prefix('#').map(|id| format!("#{}", self.prefix_id(prefix, id)))
(B[m[32m+        reference
(B[m[32m+            .strip_prefix('#')
(B[m[32m+            .map(|id| format!("#{}", self.prefix_id(prefix, id)))
(B[m     }
 
     fn process_element(&self, element: &mut Element, prefix: &str, config: &PrefixIdsConfig) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:181:
         let url_double_quote = Regex::new(r#"\burl\("(#[^"]+)"\)"#).unwrap();
         let url_single_quote = Regex::new(r#"\burl\('(#[^']+)'\)"#).unwrap();
         let url_no_quote = Regex::new(r#"\burl\((#[^)]+)\)"#).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut result = value.to_string();
[31m-        
(B[m[32m+
(B[m         // Process double-quoted URLs
[31m-        result = url_double_quote.replace_all(&result, |caps: &regex::Captures| {
(B[m[31m-            let url = caps.get(1).unwrap().as_str();
(B[m[31m-            if let Some(prefixed) = self.prefix_reference(prefix, url) {
(B[m[31m-                format!(r#"url("{}")"#, prefixed)
(B[m[31m-            } else {
(B[m[31m-                caps.get(0).unwrap().as_str().to_string()
(B[m[31m-            }
(B[m[31m-        }).to_string();
(B[m[31m-        
(B[m[32m+        result = url_double_quote
(B[m[32m+            .replace_all(&result, |caps: &regex::Captures| {
(B[m[32m+                let url = caps.get(1).unwrap().as_str();
(B[m[32m+                if let Some(prefixed) = self.prefix_reference(prefix, url) {
(B[m[32m+                    format!(r#"url("{}")"#, prefixed)
(B[m[32m+                } else {
(B[m[32m+                    caps.get(0).unwrap().as_str().to_string()
(B[m[32m+                }
(B[m[32m+            })
(B[m[32m+            .to_string();
(B[m[32m+
(B[m         // Process single-quoted URLs
[31m-        result = url_single_quote.replace_all(&result, |caps: &regex::Captures| {
(B[m[31m-            let url = caps.get(1).unwrap().as_str();
(B[m[31m-            if let Some(prefixed) = self.prefix_reference(prefix, url) {
(B[m[31m-                format!(r#"url('{}')"#, prefixed)
(B[m[31m-            } else {
(B[m[31m-                caps.get(0).unwrap().as_str().to_string()
(B[m[31m-            }
(B[m[31m-        }).to_string();
(B[m[31m-        
(B[m[32m+        result = url_single_quote
(B[m[32m+            .replace_all(&result, |caps: &regex::Captures| {
(B[m[32m+                let url = caps.get(1).unwrap().as_str();
(B[m[32m+                if let Some(prefixed) = self.prefix_reference(prefix, url) {
(B[m[32m+                    format!(r#"url('{}')"#, prefixed)
(B[m[32m+                } else {
(B[m[32m+                    caps.get(0).unwrap().as_str().to_string()
(B[m[32m+                }
(B[m[32m+            })
(B[m[32m+            .to_string();
(B[m[32m+
(B[m         // Process unquoted URLs
[31m-        result = url_no_quote.replace_all(&result, |caps: &regex::Captures| {
(B[m[31m-            let url = caps.get(1).unwrap().as_str();
(B[m[31m-            if let Some(prefixed) = self.prefix_reference(prefix, url) {
(B[m[31m-                format!("url({})", prefixed)
(B[m[31m-            } else {
(B[m[31m-                caps.get(0).unwrap().as_str().to_string()
(B[m[31m-            }
(B[m[31m-        }).to_string();
(B[m[31m-        
(B[m[32m+        result = url_no_quote
(B[m[32m+            .replace_all(&result, |caps: &regex::Captures| {
(B[m[32m+                let url = caps.get(1).unwrap().as_str();
(B[m[32m+                if let Some(prefixed) = self.prefix_reference(prefix, url) {
(B[m[32m+                    format!("url({})", prefixed)
(B[m[32m+                } else {
(B[m[32m+                    caps.get(0).unwrap().as_str().to_string()
(B[m[32m+                }
(B[m[32m+            })
(B[m[32m+            .to_string();
(B[m[32m+
(B[m         result
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:235:
                 }
             })
             .collect();
[31m-        
(B[m[32m+
(B[m         parts.join("; ")
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:242:
[31m-    fn process_style_content(&self, content: &str, prefix: &str, config: &PrefixIdsConfig) -> String {
(B[m[32m+    fn process_style_content(
(B[m[32m+        &self,
(B[m[32m+        content: &str,
(B[m[32m+        prefix: &str,
(B[m[32m+        config: &PrefixIdsConfig,
(B[m[32m+    ) -> String {
(B[m         let mut result = content.to_string();
[31m-        
(B[m[32m+
(B[m         // Simple patterns for ID and class selectors (without full CSS parsing)
         if config.prefix_ids {
             // Match #id selectors
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:248:
             let id_regex = Regex::new(r"#([a-zA-Z][\w-]*)").unwrap();
[31m-            result = id_regex.replace_all(&result, |caps: &regex::Captures| {
(B[m[31m-                let id = caps.get(1).unwrap().as_str();
(B[m[31m-                format!("#{}", self.prefix_id(prefix, id))
(B[m[31m-            }).to_string();
(B[m[32m+            result = id_regex
(B[m[32m+                .replace_all(&result, |caps: &regex::Captures| {
(B[m[32m+                    let id = caps.get(1).unwrap().as_str();
(B[m[32m+                    format!("#{}", self.prefix_id(prefix, id))
(B[m[32m+                })
(B[m[32m+                .to_string();
(B[m         }
[31m-        
(B[m[32m+
(B[m         if config.prefix_class_names {
             // Match .class selectors
             let class_regex = Regex::new(r"\.([a-zA-Z][\w-]*)").unwrap();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:258:
[31m-            result = class_regex.replace_all(&result, |caps: &regex::Captures| {
(B[m[31m-                let class = caps.get(1).unwrap().as_str();
(B[m[31m-                format!(".{}", self.prefix_id(prefix, class))
(B[m[31m-            }).to_string();
(B[m[32m+            result = class_regex
(B[m[32m+                .replace_all(&result, |caps: &regex::Captures| {
(B[m[32m+                    let class = caps.get(1).unwrap().as_str();
(B[m[32m+                    format!(".{}", self.prefix_id(prefix, class))
(B[m[32m+                })
(B[m[32m+                .to_string();
(B[m         }
[31m-        
(B[m[32m+
(B[m         // Also handle url() references in CSS
         result = self.process_url_references(&result, prefix);
[31m-        
(B[m[32m+
(B[m         result
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:277:
         "prefix IDs"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = self.parse_config(params);
         let prefix = self.generate_prefix(&config, info);
[31m-        
(B[m[32m+
(B[m         self.process_element(&mut document.root, &prefix, &config);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:323:
 
     #[test]
     fn test_get_basename() {
[31m-        assert_eq!(PrefixIdsPlugin::get_basename("/path/to/file.svg"), "file.svg");
(B[m[31m-        assert_eq!(PrefixIdsPlugin::get_basename("C:\\path\\to\\file.svg"), "file.svg");
(B[m[32m+        assert_eq!(
(B[m[32m+            PrefixIdsPlugin::get_basename("/path/to/file.svg"),
(B[m[32m+            "file.svg"
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            PrefixIdsPlugin::get_basename("C:\\path\\to\\file.svg"),
(B[m[32m+            "file.svg"
(B[m[32m+        );
(B[m         assert_eq!(PrefixIdsPlugin::get_basename("file.svg"), "file.svg");
         assert_eq!(PrefixIdsPlugin::get_basename(""), "");
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:331:
 
     #[test]
     fn test_escape_identifier_name() {
[31m-        assert_eq!(PrefixIdsPlugin::escape_identifier_name("my file.svg"), "my_file_svg");
(B[m[32m+        assert_eq!(
(B[m[32m+            PrefixIdsPlugin::escape_identifier_name("my file.svg"),
(B[m[32m+            "my_file_svg"
(B[m[32m+        );
(B[m         assert_eq!(PrefixIdsPlugin::escape_identifier_name("normal"), "normal");
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:338:
     #[test]
     fn test_generate_prefix() {
         let plugin = PrefixIdsPlugin::new();
[31m-        
(B[m[32m+
(B[m         // Test with custom prefix
         let config = PrefixIdsConfig {
             prefix: Some("custom".to_string()),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:348:
         };
         let info = PluginInfo::default();
         assert_eq!(plugin.generate_prefix(&config, &info), "custom__");
[31m-        
(B[m[32m+
(B[m         // Test with file path
         let config = PrefixIdsConfig::default();
         let mut info = PluginInfo::default();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:355:
         info.path = Some("/path/to/test.svg".to_string());
         assert_eq!(plugin.generate_prefix(&config, &info), "test_svg__");
[31m-        
(B[m[32m+
(B[m         // Test default
         let config = PrefixIdsConfig::default();
         let info = PluginInfo::default();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:364:
     #[test]
     fn test_prefix_id() {
         let plugin = PrefixIdsPlugin::new();
[31m-        
(B[m[32m+
(B[m         // Test normal prefixing
         assert_eq!(plugin.prefix_id("test__", "myid"), "test__myid");
[31m-        
(B[m[32m+
(B[m         // Test when already prefixed
         assert_eq!(plugin.prefix_id("test__", "test__myid"), "test__myid");
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:375:
     #[test]
     fn test_prefix_reference() {
         let plugin = PrefixIdsPlugin::new();
[31m-        
(B[m[32m+
(B[m         // Test valid reference
[31m-        assert_eq!(plugin.prefix_reference("test__", "#myid"), Some("#test__myid".to_string()));
(B[m[31m-        
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.prefix_reference("test__", "#myid"),
(B[m[32m+            Some("#test__myid".to_string())
(B[m[32m+        );
(B[m[32m+
(B[m         // Test invalid reference
         assert_eq!(plugin.prefix_reference("test__", "myid"), None);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:387:
     fn test_apply_with_ids() {
         let mut plugin = PrefixIdsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add element with ID
         let mut attrs = IndexMap::new();
         attrs.insert("id".to_string(), "myId".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:397:
             namespaces: HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:404:
[31m-        
(B[m[32m+
(B[m         // Check that ID was prefixed
         if let Node::Element(rect) = &doc.root.children[0] {
             assert_eq!(rect.attributes.get("id"), Some(&"prefix__myId".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:414:
     fn test_apply_with_href() {
         let mut plugin = PrefixIdsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add element with href
         let mut attrs = IndexMap::new();
         attrs.insert("href".to_string(), "#myTarget".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:424:
             namespaces: HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:431:
[31m-        
(B[m[32m+
(B[m         // Check that href was prefixed
         if let Node::Element(use_elem) = &doc.root.children[0] {
[31m-            assert_eq!(use_elem.attributes.get("href"), Some(&"#prefix__myTarget".to_string()));
(B[m[32m+            assert_eq!(
(B[m[32m+                use_elem.attributes.get("href"),
(B[m[32m+                Some(&"#prefix__myTarget".to_string())
(B[m[32m+            );
(B[m         } else {
             panic!("Expected element");
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:441:
     fn test_apply_with_custom_config() {
         let mut plugin = PrefixIdsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add element with ID
         let mut attrs = IndexMap::new();
         attrs.insert("id".to_string(), "myId".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:451:
             namespaces: HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         let config = serde_json::json!({
             "prefix": "custom",
             "delim": "_"
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:458:
         });
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, Some(&config));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:463:
[31m-        
(B[m[32m+
(B[m         // Check that ID was prefixed with custom config
         if let Node::Element(rect) = &doc.root.children[0] {
             assert_eq!(rect.attributes.get("id"), Some(&"custom_myId".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/prefix_ids.rs:469:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:6:
 //! Patterns can specify element names, attribute names, and attribute values using regex.
 
 use crate::ast::{Document, Element, Node};
[31m-use crate::plugin::{Plugin, PluginInfo, PluginResult, PluginError};
(B[m[31m-use serde_json::Value;
(B[m[32m+use crate::plugin::{Plugin, PluginError, PluginInfo, PluginResult};
(B[m use regex::Regex;
[32m+use serde_json::Value;
(B[m 
 /// Plugin to remove specified attributes
 pub struct RemoveAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:38:
     /// Parse parameters from JSON value
     pub fn from_value(value: Option<&Value>) -> PluginResult<Self> {
         let mut params = Self::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(map)) = value {
             // Parse attrs parameter (required)
             if let Some(attrs_value) = map.get("attrs") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:55:
                     }
                     _ => {
                         return Err(PluginError::InvalidConfig(
[31m-                            "attrs parameter must be a string or array of strings".to_string()
(B[m[32m+                            "attrs parameter must be a string or array of strings".to_string(),
(B[m                         ));
                     }
                 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:62:
             } else {
                 return Err(PluginError::InvalidConfig(
[31m-                    "removeAttrs plugin requires 'attrs' parameter".to_string()
(B[m[32m+                    "removeAttrs plugin requires 'attrs' parameter".to_string(),
(B[m                 ));
             }
[31m-            
(B[m[32m+
(B[m             // Parse elemSeparator
             if let Some(Value::String(separator)) = map.get("elemSeparator") {
                 params.elem_separator = separator.clone();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:71:
             }
[31m-            
(B[m[32m+
(B[m             // Parse preserveCurrentColor
             if let Some(Value::Bool(preserve)) = map.get("preserveCurrentColor") {
                 params.preserve_current_color = *preserve;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:76:
             }
         } else if value.is_some() {
             return Err(PluginError::InvalidConfig(
[31m-                "removeAttrs plugin parameters must be an object".to_string()
(B[m[32m+                "removeAttrs plugin parameters must be an object".to_string(),
(B[m             ));
         } else {
             return Err(PluginError::InvalidConfig(
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:83:
[31m-                "removeAttrs plugin requires 'attrs' parameter".to_string()
(B[m[32m+                "removeAttrs plugin requires 'attrs' parameter".to_string(),
(B[m             ));
         }
[31m-        
(B[m[32m+
(B[m         Ok(params)
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:100:
     /// Compile a pattern string into regex components
     fn compile(pattern: &str, separator: &str) -> PluginResult<Self> {
         let mut parts: Vec<String> = pattern.split(separator).map(|s| s.to_string()).collect();
[31m-        
(B[m[32m+
(B[m         // Expand pattern based on number of parts
         match parts.len() {
             1 => {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:116:
                 // Full pattern - use as is
             }
             _ => {
[31m-                return Err(PluginError::InvalidConfig(
(B[m[31m-                    format!("Invalid pattern format: {}", pattern)
(B[m[31m-                ));
(B[m[32m+                return Err(PluginError::InvalidConfig(format!(
(B[m[32m+                    "Invalid pattern format: {}",
(B[m[32m+                    pattern
(B[m[32m+                )));
(B[m             }
         }
[31m-        
(B[m[32m+
(B[m         // Convert single * to .*
         for part in &mut parts {
             if part == "*" {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:128:
                 *part = ".*".to_string();
             }
         }
[31m-        
(B[m[32m+
(B[m         // Compile regexes (case-insensitive for better compatibility)
         let element_regex = Regex::new(&format!("^{}$", parts[0]))
             .map_err(|e| PluginError::InvalidConfig(format!("Invalid element regex: {}", e)))?;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:136:
             .map_err(|e| PluginError::InvalidConfig(format!("Invalid attribute regex: {}", e)))?;
         let value_regex = Regex::new(&format!("^{}$", parts[2]))
             .map_err(|e| PluginError::InvalidConfig(format!("Invalid value regex: {}", e)))?;
[31m-        
(B[m[32m+
(B[m         Ok(Self {
             element_regex,
             attribute_regex,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:143:
             value_regex,
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Check if this pattern matches the given element, attribute, and value
     fn matches(&self, element_name: &str, attr_name: &str, attr_value: &str) -> bool {
[31m-        self.element_regex.is_match(element_name) &&
(B[m[31m-        self.attribute_regex.is_match(attr_name) &&
(B[m[31m-        self.value_regex.is_match(attr_value)
(B[m[32m+        self.element_regex.is_match(element_name)
(B[m[32m+            && self.attribute_regex.is_match(attr_name)
(B[m[32m+            && self.value_regex.is_match(attr_value)
(B[m     }
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:161:
         "removes specified attributes"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = RemoveAttrsParams::from_value(params)?;
[31m-        
(B[m[32m+
(B[m         if config.attrs.is_empty() {
             return Err(PluginError::InvalidConfig(
[31m-                "removeAttrs plugin requires non-empty 'attrs' parameter".to_string()
(B[m[32m+                "removeAttrs plugin requires non-empty 'attrs' parameter".to_string(),
(B[m             ));
         }
[31m-        
(B[m[32m+
(B[m         // Compile all patterns
         let mut compiled_patterns = Vec::new();
         for pattern in &config.attrs {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:176:
             compiled_patterns.push(CompiledPattern::compile(pattern, &config.elem_separator)?);
         }
[31m-        
(B[m[32m+
(B[m         visit_elements(&mut document.root, &compiled_patterns, &config);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:184:
 /// Visit all elements in the AST and remove matching attributes
 fn visit_elements(element: &mut Element, patterns: &[CompiledPattern], config: &RemoveAttrsParams) {
     remove_matching_attributes(element, patterns, config);
[31m-    
(B[m[32m+
(B[m     for child in &mut element.children {
         if let Node::Element(child_element) = child {
             visit_elements(child_element, patterns, config);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:193:
 }
 
 /// Remove attributes from a single element that match the patterns
[31m-fn remove_matching_attributes(element: &mut Element, patterns: &[CompiledPattern], config: &RemoveAttrsParams) {
(B[m[32m+fn remove_matching_attributes(
(B[m[32m+    element: &mut Element,
(B[m[32m+    patterns: &[CompiledPattern],
(B[m[32m+    config: &RemoveAttrsParams,
(B[m[32m+) {
(B[m     let mut attrs_to_remove = Vec::new();
[31m-    
(B[m[32m+
(B[m     for (attr_name, attr_value) in &element.attributes {
         for pattern in patterns {
             if pattern.matches(&element.name, attr_name, attr_value) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:203:
                 if config.preserve_current_color {
                     let is_current_color = attr_value.to_lowercase() == "currentcolor";
                     let is_fill_or_stroke = attr_name == "fill" || attr_name == "stroke";
[31m-                    
(B[m[32m+
(B[m                     if is_fill_or_stroke && is_current_color {
                         continue; // Skip removal
                     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:210:
                 }
[31m-                
(B[m[32m+
(B[m                 attrs_to_remove.push(attr_name.clone());
                 break; // No need to check other patterns for this attribute
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:215:
         }
     }
[31m-    
(B[m[32m+
(B[m     // Remove the attributes
     for attr_name in attrs_to_remove {
         element.attributes.shift_remove(&attr_name);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:232:
     fn test_simple_attribute_removal() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        element.attributes.insert("stroke".to_string(), "blue".to_string());
(B[m[31m-        element.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "blue".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:243:
         let params = json!({"attrs": "fill"});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         assert!(!document.root.has_attr("fill"));
         assert!(document.root.has_attr("stroke"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:252:
     fn test_multiple_attribute_removal() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        element.attributes.insert("stroke".to_string(), "blue".to_string());
(B[m[31m-        element.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "blue".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:263:
         let params = json!({"attrs": ["fill", "stroke"]});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         assert!(!document.root.has_attr("fill"));
         assert!(!document.root.has_attr("stroke"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:272:
     fn test_regex_pattern_removal() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        element.attributes.insert("stroke".to_string(), "blue".to_string());
(B[m[31m-        element.attributes.insert("stroke-width".to_string(), "2".to_string());
(B[m[31m-        element.attributes.insert("stroke-opacity".to_string(), "0.5".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "blue".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke-width".to_string(), "2".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke-opacity".to_string(), "0.5".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:284:
         let params = json!({"attrs": "stroke.*"});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         assert!(document.root.has_attr("fill"));
         assert!(!document.root.has_attr("stroke"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:295:
         let mut document = Document::new();
         let mut circle = Element::new("circle");
         let mut rect = Element::new("rect");
[31m-        
(B[m[31m-        circle.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        rect.attributes.insert("fill".to_string(), "blue".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        circle
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        rect.attributes
(B[m[32m+            .insert("fill".to_string(), "blue".to_string());
(B[m[32m+
(B[m         document.root.children.push(Node::Element(circle));
         document.root.children.push(Node::Element(rect));
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:305:
         let mut plugin = RemoveAttrsPlugin;
         let params = json!({"attrs": "circle:fill"});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         // Circle should have fill removed, rect should keep it
         if let Node::Element(circle_elem) = &document.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:319:
     fn test_value_specific_removal() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        element.attributes.insert("stroke".to_string(), "blue".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "blue".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:329:
         let params = json!({"attrs": "*:fill:red"});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         assert!(!document.root.has_attr("fill"));
         assert!(document.root.has_attr("stroke"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:337:
     fn test_preserve_current_color() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("fill".to_string(), "currentColor".to_string());
(B[m[31m-        element.attributes.insert("stroke".to_string(), "red".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "currentColor".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "red".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:348:
             "attrs": "(fill|stroke)",
             "preserveCurrentColor": true
         });
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         assert!(document.root.has_attr("fill")); // currentColor preserved
         assert!(!document.root.has_attr("stroke")); // red removed
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:358:
     fn test_preserve_current_color_case_insensitive() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("fill".to_string(), "currentcolor".to_string());
(B[m[31m-        element.attributes.insert("stroke".to_string(), "CURRENTCOLOR".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "currentcolor".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "CURRENTCOLOR".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:369:
             "attrs": "(fill|stroke)",
             "preserveCurrentColor": true
         });
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         assert!(document.root.has_attr("fill")); // currentcolor preserved
         assert!(document.root.has_attr("stroke")); // CURRENTCOLOR preserved
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:379:
     fn test_custom_separator() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        element.attributes.insert("stroke".to_string(), "blue".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "blue".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:390:
             "attrs": "rect|fill",
             "elemSeparator": "|"
         });
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         assert!(!document.root.has_attr("fill"));
         assert!(document.root.has_attr("stroke"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:400:
     fn test_no_attrs_parameter_error() {
         let mut document = Document::new();
         let mut plugin = RemoveAttrsPlugin;
[31m-        
(B[m[32m+
(B[m         let result = plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None);
         assert!(result.is_err());
[31m-        
(B[m[31m-        let result = plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&json!({})));
(B[m[32m+
(B[m[32m+        let result = plugin.apply(
(B[m[32m+            &mut document,
(B[m[32m+            &crate::plugin::PluginInfo::default(),
(B[m[32m+            Some(&json!({})),
(B[m[32m+        );
(B[m         assert!(result.is_err());
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:413:
         let mut document = Document::new();
         let mut parent = Element::new("g");
         let mut child = Element::new("rect");
[31m-        
(B[m[31m-        parent.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        child.attributes.insert("fill".to_string(), "blue".to_string());
(B[m[31m-        child.attributes.insert("stroke".to_string(), "green".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        parent
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        child
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "blue".to_string());
(B[m[32m+        child
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "green".to_string());
(B[m[32m+
(B[m         parent.children.push(Node::Element(child));
         document.root = parent;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:424:
         let mut plugin = RemoveAttrsPlugin;
         let params = json!({"attrs": "fill"});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         assert!(!document.root.has_attr("fill"));
         if let Node::Element(child_element) = &document.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_attrs.rs:439:
         assert_eq!(plugin.description(), "removes specified attributes");
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_comments.rs:15:
     fn name(&self) -> &'static str {
         "removeComments"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Remove comments from SVG document"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_comments.rs:22:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Check if we should preserve legal comments
         let preserve_patterns = params
             .and_then(|v| v.get("preservePatterns"))
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_comments.rs:27:
             .and_then(|v| v.as_bool())
             .unwrap_or(true); // Default to true, preserve legal comments
[31m-        
(B[m[32m+
(B[m         // Remove comments from prologue
[31m-        document.prologue.retain(|node| {
(B[m[31m-            match node {
(B[m[31m-                Node::Comment(comment) => preserve_patterns && is_legal_comment(comment),
(B[m[31m-                _ => true,
(B[m[31m-            }
(B[m[32m+        document.prologue.retain(|node| match node {
(B[m[32m+            Node::Comment(comment) => preserve_patterns && is_legal_comment(comment),
(B[m[32m+            _ => true,
(B[m         });
[31m-        
(B[m[32m+
(B[m         // Remove comments from the main document tree
         remove_comments_from_node(&mut document.root, preserve_patterns);
[31m-        
(B[m[32m+
(B[m         // Remove comments from epilogue
[31m-        document.epilogue.retain(|node| {
(B[m[31m-            match node {
(B[m[31m-                Node::Comment(comment) => preserve_patterns && is_legal_comment(comment),
(B[m[31m-                _ => true,
(B[m[31m-            }
(B[m[32m+        document.epilogue.retain(|node| match node {
(B[m[32m+            Node::Comment(comment) => preserve_patterns && is_legal_comment(comment),
(B[m[32m+            _ => true,
(B[m         });
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_comments.rs:58:
 /// Recursively remove comments from a node and its children
 fn remove_comments_from_node(node: &mut crate::ast::Element, preserve_patterns: bool) {
     // Filter out comment nodes (except legal comments if preservePatterns is true)
[31m-    node.children.retain(|child| {
(B[m[31m-        match child {
(B[m[31m-            Node::Comment(comment) => {
(B[m[31m-                preserve_patterns && is_legal_comment(comment)
(B[m[31m-            }
(B[m[31m-            _ => true,
(B[m[31m-        }
(B[m[32m+    node.children.retain(|child| match child {
(B[m[32m+        Node::Comment(comment) => preserve_patterns && is_legal_comment(comment),
(B[m[32m+        _ => true,
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Clean up whitespace-only text nodes if element now only has element children
     let has_element_children = node.children.iter().any(|c| c.is_element());
[31m-    let has_meaningful_text = node.children.iter().any(|c| {
(B[m[31m-        matches!(c, Node::Text(text) if !text.trim().is_empty())
(B[m[31m-    });
(B[m[31m-    
(B[m[32m+    let has_meaningful_text = node
(B[m[32m+        .children
(B[m[32m+        .iter()
(B[m[32m+        .any(|c| matches!(c, Node::Text(text) if !text.trim().is_empty()));
(B[m[32m+
(B[m     if has_element_children && !has_meaningful_text {
         // Remove whitespace-only text nodes
[31m-        node.children.retain(|child| {
(B[m[31m-            !matches!(child, Node::Text(text) if text.trim().is_empty())
(B[m[31m-        });
(B[m[32m+        node.children
(B[m[32m+            .retain(|child| !matches!(child, Node::Text(text) if text.trim().is_empty()));
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Recursively process child elements
     for child in &mut node.children {
         if let Node::Element(element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_comments.rs:94:
     use super::*;
     use crate::ast::Element;
     use crate::parser::Parser;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_comments() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_comments.rs:104:
                 <rect/>
             </g>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveCommentsPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that comments are removed (we pass None for params, so legal comments would be preserved)
         assert!(!has_comments(&document.root));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_comments.rs:117:
[31m-    
(B[m[32m+
(B[m     fn has_comments(element: &Element) -> bool {
         for child in &element.children {
             match child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_comments.rs:130:
         false
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:7:
 //! removes additional deprecated attributes that might affect rendering.
 
 use crate::ast::{Document, Element, Node};
[31m-use crate::plugin::{Plugin, PluginInfo, PluginResult, PluginError};
(B[m[32m+use crate::plugin::{Plugin, PluginError, PluginInfo, PluginResult};
(B[m[32m+use once_cell::sync::Lazy;
(B[m use serde_json::Value;
 use std::collections::{HashMap, HashSet};
[31m-use once_cell::sync::Lazy;
(B[m 
 /// Plugin to remove deprecated attributes
 pub struct RemoveDeprecatedAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:17:
 
 /// Configuration parameters for the plugin
[31m-#[derive(Debug, Clone)]
(B[m[31m-#[derive(Default)]
(B[m[32m+#[derive(Debug, Clone, Default)]
(B[m pub struct RemoveDeprecatedAttrsParams {
     /// Whether to remove unsafe deprecated attributes
     pub remove_unsafe: bool,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:24:
 }
 
[31m-
(B[m impl RemoveDeprecatedAttrsParams {
     /// Parse parameters from JSON value
     pub fn from_value(value: Option<&Value>) -> PluginResult<Self> {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:30:
         let mut params = Self::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(map)) = value {
             if let Some(remove_unsafe) = map.get("removeUnsafe") {
[31m-                params.remove_unsafe = remove_unsafe.as_bool()
(B[m[31m-                    .ok_or_else(|| PluginError::InvalidConfig("removeUnsafe must be a boolean".to_string()))?;
(B[m[32m+                params.remove_unsafe = remove_unsafe.as_bool().ok_or_else(|| {
(B[m[32m+                    PluginError::InvalidConfig("removeUnsafe must be a boolean".to_string())
(B[m[32m+                })?;
(B[m             }
         }
[31m-        
(B[m[32m+
(B[m         Ok(params)
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:43:
 /// Deprecated attributes grouped by attribute group
 static ATTRS_GROUPS_DEPRECATED: Lazy<HashMap<&'static str, DeprecatedAttrs>> = Lazy::new(|| {
     let mut map = HashMap::new();
[31m-    
(B[m[31m-    map.insert("animationAttributeTarget", DeprecatedAttrs {
(B[m[31m-        safe: HashSet::new(),
(B[m[31m-        unsafe_attrs: vec!["attributeType"].into_iter().map(String::from).collect(),
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("conditionalProcessing", DeprecatedAttrs {
(B[m[31m-        safe: HashSet::new(),
(B[m[31m-        unsafe_attrs: vec!["requiredFeatures"].into_iter().map(String::from).collect(),
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("core", DeprecatedAttrs {
(B[m[31m-        safe: HashSet::new(),
(B[m[31m-        unsafe_attrs: vec!["xml:base", "xml:lang", "xml:space"].into_iter().map(String::from).collect(),
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("presentation", DeprecatedAttrs {
(B[m[31m-        safe: HashSet::new(),
(B[m[31m-        unsafe_attrs: vec![
(B[m[31m-            "clip",
(B[m[31m-            "color-profile",
(B[m[31m-            "enable-background",
(B[m[31m-            "glyph-orientation-horizontal",
(B[m[31m-            "glyph-orientation-vertical",
(B[m[31m-            "kerning",
(B[m[31m-        ].into_iter().map(String::from).collect(),
(B[m[31m-    });
(B[m[31m-    
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "animationAttributeTarget",
(B[m[32m+        DeprecatedAttrs {
(B[m[32m+            safe: HashSet::new(),
(B[m[32m+            unsafe_attrs: vec!["attributeType"]
(B[m[32m+                .into_iter()
(B[m[32m+                .map(String::from)
(B[m[32m+                .collect(),
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "conditionalProcessing",
(B[m[32m+        DeprecatedAttrs {
(B[m[32m+            safe: HashSet::new(),
(B[m[32m+            unsafe_attrs: vec!["requiredFeatures"]
(B[m[32m+                .into_iter()
(B[m[32m+                .map(String::from)
(B[m[32m+                .collect(),
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "core",
(B[m[32m+        DeprecatedAttrs {
(B[m[32m+            safe: HashSet::new(),
(B[m[32m+            unsafe_attrs: vec!["xml:base", "xml:lang", "xml:space"]
(B[m[32m+                .into_iter()
(B[m[32m+                .map(String::from)
(B[m[32m+                .collect(),
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "presentation",
(B[m[32m+        DeprecatedAttrs {
(B[m[32m+            safe: HashSet::new(),
(B[m[32m+            unsafe_attrs: vec![
(B[m[32m+                "clip",
(B[m[32m+                "color-profile",
(B[m[32m+                "enable-background",
(B[m[32m+                "glyph-orientation-horizontal",
(B[m[32m+                "glyph-orientation-vertical",
(B[m[32m+                "kerning",
(B[m[32m+            ]
(B[m[32m+            .into_iter()
(B[m[32m+            .map(String::from)
(B[m[32m+            .collect(),
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m     map
 });
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:77:
 /// Element configurations with their attribute groups
 static ELEMENT_CONFIGS: Lazy<HashMap<&'static str, ElementConfig>> = Lazy::new(|| {
     let mut map = HashMap::new();
[31m-    
(B[m[32m+
(B[m     // Common attribute groups
[31m-    let common_groups = vec!["conditionalProcessing", "core", "graphicalEvent", "presentation"];
(B[m[31m-    
(B[m[32m+    let common_groups = vec![
(B[m[32m+        "conditionalProcessing",
(B[m[32m+        "core",
(B[m[32m+        "graphicalEvent",
(B[m[32m+        "presentation",
(B[m[32m+    ];
(B[m[32m+
(B[m     // Define configurations for various elements
[31m-    map.insert("a", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.iter().copied().chain(vec!["xlink"]).collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("circle", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("ellipse", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("g", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("image", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.iter().copied().chain(vec!["xlink"]).collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("line", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("path", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("polygon", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("polyline", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("rect", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("svg", ElementConfig {
(B[m[31m-        attrs_groups: vec!["conditionalProcessing", "core", "documentEvent", "graphicalEvent", "presentation"].into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("text", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("use", ElementConfig {
(B[m[31m-        attrs_groups: common_groups.iter().copied().chain(vec!["xlink"]).collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[32m+    map.insert(
(B[m[32m+        "a",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.iter().copied().chain(vec!["xlink"]).collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "circle",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "ellipse",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "g",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "image",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.iter().copied().chain(vec!["xlink"]).collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "line",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "path",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "polygon",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "polyline",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "rect",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "svg",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: vec![
(B[m[32m+                "conditionalProcessing",
(B[m[32m+                "core",
(B[m[32m+                "documentEvent",
(B[m[32m+                "graphicalEvent",
(B[m[32m+                "presentation",
(B[m[32m+            ]
(B[m[32m+            .into_iter()
(B[m[32m+            .collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "text",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.clone().into_iter().collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "use",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: common_groups.iter().copied().chain(vec!["xlink"]).collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m     // Animation elements
[31m-    map.insert("animate", ElementConfig {
(B[m[31m-        attrs_groups: vec!["conditionalProcessing", "core", "animationEvent", "xlink", "animationAttributeTarget", "animationTiming", "animationValue", "animationAddition", "presentation"].into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    map.insert("animateTransform", ElementConfig {
(B[m[31m-        attrs_groups: vec!["conditionalProcessing", "core", "animationEvent", "xlink", "animationAttributeTarget", "animationTiming", "animationValue", "animationAddition"].into_iter().collect(),
(B[m[31m-        deprecated: None,
(B[m[31m-    });
(B[m[31m-    
(B[m[32m+    map.insert(
(B[m[32m+        "animate",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: vec![
(B[m[32m+                "conditionalProcessing",
(B[m[32m+                "core",
(B[m[32m+                "animationEvent",
(B[m[32m+                "xlink",
(B[m[32m+                "animationAttributeTarget",
(B[m[32m+                "animationTiming",
(B[m[32m+                "animationValue",
(B[m[32m+                "animationAddition",
(B[m[32m+                "presentation",
(B[m[32m+            ]
(B[m[32m+            .into_iter()
(B[m[32m+            .collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    map.insert(
(B[m[32m+        "animateTransform",
(B[m[32m+        ElementConfig {
(B[m[32m+            attrs_groups: vec![
(B[m[32m+                "conditionalProcessing",
(B[m[32m+                "core",
(B[m[32m+                "animationEvent",
(B[m[32m+                "xlink",
(B[m[32m+                "animationAttributeTarget",
(B[m[32m+                "animationTiming",
(B[m[32m+                "animationValue",
(B[m[32m+                "animationAddition",
(B[m[32m+            ]
(B[m[32m+            .into_iter()
(B[m[32m+            .collect(),
(B[m[32m+            deprecated: None,
(B[m[32m+        },
(B[m[32m+    );
(B[m[32m+
(B[m     // Add more elements as needed
     map
 });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:186:
     for attr_name in &deprecated_attrs.safe {
         element.attributes.shift_remove(attr_name);
     }
[31m-    
(B[m[32m+
(B[m     // Remove unsafe deprecated attributes if requested
     if params.remove_unsafe {
         for attr_name in &deprecated_attrs.unsafe_attrs {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:200:
     // Get element configuration
     if let Some(elem_config) = ELEMENT_CONFIGS.get(element.name.as_str()) {
         // Special case: Remove xml:lang if lang attribute exists
[31m-        if elem_config.attrs_groups.contains("core") &&
(B[m[31m-           element.attributes.contains_key("xml:lang") &&
(B[m[31m-           element.attributes.contains_key("lang") {
(B[m[32m+        if elem_config.attrs_groups.contains("core")
(B[m[32m+            && element.attributes.contains_key("xml:lang")
(B[m[32m+            && element.attributes.contains_key("lang")
(B[m[32m+        {
(B[m             element.attributes.shift_remove("xml:lang");
         }
[31m-        
(B[m[32m+
(B[m         // Process deprecated attributes from attribute groups
         for attrs_group in &elem_config.attrs_groups {
             if let Some(deprecated_attrs) = ATTRS_GROUPS_DEPRECATED.get(attrs_group) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:212:
                 process_attributes(element, deprecated_attrs, params);
             }
         }
[31m-        
(B[m[32m+
(B[m         // Process element-specific deprecated attributes
         if let Some(ref deprecated) = elem_config.deprecated {
             process_attributes(element, deprecated, params);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:224:
 fn process_node(node: &mut Node, params: &RemoveDeprecatedAttrsParams) {
     if let Node::Element(ref mut element) = node {
         process_element(element, params);
[31m-        
(B[m[32m+
(B[m         // Process children
         for child in &mut element.children {
             process_node(child, params);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:236:
     fn name(&self) -> &'static str {
         "removeDeprecatedAttrs"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "removes deprecated attributes"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:243:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let params = RemoveDeprecatedAttrsParams::from_value(params)?;
[31m-        
(B[m[32m+
(B[m         // Process root element
         process_element(&mut document.root, &params);
[31m-        
(B[m[32m+
(B[m         // Process children
         for child in &mut document.root.children {
             process_node(child, &params);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:253:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     fn validate_params(&self, params: Option<&Value>) -> PluginResult<()> {
         RemoveDeprecatedAttrsParams::from_value(params)?;
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:272:
 
     fn create_test_document() -> Document {
         let mut doc = Document::default();
[31m-        
(B[m[32m+
(B[m         let mut svg = Element {
             name: "svg".to_string(),
             namespaces: HashMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:279:
             attributes: IndexMap::new(),
             children: vec![],
         };
[31m-        svg.attributes.insert("xml:lang".to_string(), "en".to_string());
(B[m[32m+        svg.attributes
(B[m[32m+            .insert("xml:lang".to_string(), "en".to_string());
(B[m         svg.attributes.insert("lang".to_string(), "en".to_string());
[31m-        svg.attributes.insert("xml:space".to_string(), "preserve".to_string());
(B[m[31m-        
(B[m[32m+        svg.attributes
(B[m[32m+            .insert("xml:space".to_string(), "preserve".to_string());
(B[m[32m+
(B[m         let mut rect = Element {
             name: "rect".to_string(),
             namespaces: HashMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:291:
         };
         rect.attributes.insert("x".to_string(), "0".to_string());
         rect.attributes.insert("y".to_string(), "0".to_string());
[31m-        rect.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        rect.attributes.insert("height".to_string(), "100".to_string());
(B[m[31m-        rect.attributes.insert("enable-background".to_string(), "new".to_string());
(B[m[31m-        rect.attributes.insert("clip".to_string(), "rect(0 0 100 100)".to_string());
(B[m[31m-        
(B[m[32m+        rect.attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        rect.attributes
(B[m[32m+            .insert("height".to_string(), "100".to_string());
(B[m[32m+        rect.attributes
(B[m[32m+            .insert("enable-background".to_string(), "new".to_string());
(B[m[32m+        rect.attributes
(B[m[32m+            .insert("clip".to_string(), "rect(0 0 100 100)".to_string());
(B[m[32m+
(B[m         svg.children.push(Node::Element(rect));
         doc.root = svg;
         doc
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:306:
         let mut doc = create_test_document();
         let mut plugin = RemoveDeprecatedAttrsPlugin;
         let plugin_info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // xml:lang should be removed because lang exists
         assert_eq!(doc.root.attributes.get("xml:lang"), None);
         assert_eq!(doc.root.attributes.get("lang"), Some(&"en".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:315:
         // xml:space should still exist (unsafe attribute)
[31m-        assert_eq!(doc.root.attributes.get("xml:space"), Some(&"preserve".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            doc.root.attributes.get("xml:space"),
(B[m[32m+            Some(&"preserve".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:321:
         let mut doc = create_test_document();
         let mut plugin = RemoveDeprecatedAttrsPlugin;
         let plugin_info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "removeUnsafe": true
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:328:
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &plugin_info, Some(&params)).unwrap();
[31m-        
(B[m[32m+
(B[m         // xml:space should be removed with removeUnsafe
         assert_eq!(doc.root.attributes.get("xml:space"), None);
[31m-        
(B[m[32m+
(B[m         // Check rect element - unsafe presentation attributes should be removed
         if let Some(Node::Element(ref rect)) = doc.root.children.first() {
             assert_eq!(rect.attributes.get("enable-background"), None);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:343:
     #[test]
     fn test_keep_xml_lang_without_lang() {
         let mut doc = Document::default();
[31m-        
(B[m[32m+
(B[m         let mut svg = Element {
             name: "svg".to_string(),
             namespaces: HashMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:350:
             attributes: IndexMap::new(),
             children: vec![],
         };
[31m-        svg.attributes.insert("xml:lang".to_string(), "en".to_string());
(B[m[32m+        svg.attributes
(B[m[32m+            .insert("xml:lang".to_string(), "en".to_string());
(B[m         // No lang attribute
[31m-        
(B[m[32m+
(B[m         doc.root = svg;
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveDeprecatedAttrsPlugin;
         let plugin_info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // xml:lang should be kept because lang doesn't exist
         assert_eq!(doc.root.attributes.get("xml:lang"), Some(&"en".to_string()));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:367:
     #[test]
     fn test_animation_attribute_target() {
         let mut doc = Document::default();
[31m-        
(B[m[32m+
(B[m         let mut svg = Element {
             name: "svg".to_string(),
             namespaces: HashMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:374:
             attributes: IndexMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         let mut animate = Element {
             name: "animate".to_string(),
             namespaces: HashMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:381:
             attributes: IndexMap::new(),
             children: vec![],
         };
[31m-        animate.attributes.insert("attributeType".to_string(), "XML".to_string());
(B[m[31m-        animate.attributes.insert("attributeName".to_string(), "x".to_string());
(B[m[31m-        
(B[m[32m+        animate
(B[m[32m+            .attributes
(B[m[32m+            .insert("attributeType".to_string(), "XML".to_string());
(B[m[32m+        animate
(B[m[32m+            .attributes
(B[m[32m+            .insert("attributeName".to_string(), "x".to_string());
(B[m[32m+
(B[m         svg.children.push(Node::Element(animate));
         doc.root = svg;
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveDeprecatedAttrsPlugin;
         let plugin_info = PluginInfo::default();
[31m-        
(B[m[32m+
(B[m         let params = json!({
             "removeUnsafe": true
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:396:
[31m-        
(B[m[32m+
(B[m         plugin.apply(&mut doc, &plugin_info, Some(&params)).unwrap();
[31m-        
(B[m[32m+
(B[m         // attributeType is an unsafe deprecated attribute
         if let Some(Node::Element(ref animate)) = doc.root.children.first() {
             assert_eq!(animate.attributes.get("attributeType"), None);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:402:
[31m-            assert_eq!(animate.attributes.get("attributeName"), Some(&"x".to_string()));
(B[m[32m+            assert_eq!(
(B[m[32m+                animate.attributes.get("attributeName"),
(B[m[32m+                Some(&"x".to_string())
(B[m[32m+            );
(B[m         }
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_deprecated_attrs.rs:406:
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:18:
 pub struct RemoveDescPlugin;
 
 // Regex pattern for standard editor descriptions
[31m-static STANDARD_DESCS: LazyLock<Regex> = LazyLock::new(|| {
(B[m[31m-    Regex::new(r"^(Created with|Created using)").unwrap()
(B[m[31m-});
(B[m[32m+static STANDARD_DESCS: LazyLock<Regex> =
(B[m[32m+    LazyLock::new(|| Regex::new(r"^(Created with|Created using)").unwrap());
(B[m 
 impl Plugin for RemoveDescPlugin {
     fn name(&self) -> &'static str {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:27:
         "removeDesc"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Remove <desc> elements"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:33:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Parse parameters
         let remove_any = params
             .and_then(|v| v.get("removeAny"))
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:38:
             .and_then(|v| v.as_bool())
             .unwrap_or(false);
[31m-        
(B[m[32m+
(B[m         // Process the document
         remove_desc_from_element(&mut document.root, remove_any);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:57:
             _ => true,
         }
     });
[31m-    
(B[m[32m+
(B[m     // Process remaining child elements
     for child in &mut element.children {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:71:
     if remove_any {
         return true;
     }
[31m-    
(B[m[32m+
(B[m     // Remove if empty
     if desc_element.children.is_empty() {
         return true;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:78:
     }
[31m-    
(B[m[32m+
(B[m     // Check if it contains only standard editor text
     if desc_element.children.len() == 1 {
         if let Some(Node::Text(text)) = desc_element.children.first() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:85:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     false
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:95:
     use super::*;
     use crate::parser::Parser;
     use serde_json::json;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_empty_desc() {
         let svg = r#"<svg xmlns="http://www.w3.org/2000/svg">
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:102:
             <desc></desc>
             <rect width="100" height="100"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveDescPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that empty desc is removed
         assert!(!has_desc_element(&document.root));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:115:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_standard_desc() {
         let svg = r#"<svg xmlns="http://www.w3.org/2000/svg">
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:119:
             <desc>Created with Sketch.</desc>
             <rect width="100" height="100"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveDescPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that standard desc is removed
         assert!(!has_desc_element(&document.root));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:132:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_preserve_custom_desc() {
         let svg = r#"<svg xmlns="http://www.w3.org/2000/svg">
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:136:
             <desc>This is a custom description for accessibility</desc>
             <rect width="100" height="100"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveDescPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that custom desc is preserved
         assert!(has_desc_element(&document.root));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:149:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_any() {
         let svg = r#"<svg xmlns="http://www.w3.org/2000/svg">
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:153:
             <desc>This is a custom description for accessibility</desc>
             <rect width="100" height="100"/>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveDescPlugin;
         let params = json!({"removeAny": true});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that all desc elements are removed
         assert!(!has_desc_element(&document.root));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:167:
[31m-    
(B[m[32m+
(B[m     fn has_desc_element(element: &Element) -> bool {
         for child in &element.children {
             if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_desc.rs:179:
         false
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:33:
 
             if let (Some(width_str), Some(height_str)) = (width_str, height_str) {
                 // Try to parse width and height as numbers
[31m-                if let (Ok(width), Ok(height)) = (width_str.parse::<f64>(), height_str.parse::<f64>()) {
(B[m[32m+                if let (Ok(width), Ok(height)) =
(B[m[32m+                    (width_str.parse::<f64>(), height_str.parse::<f64>())
(B[m[32m+                {
(B[m                     // Only proceed if both are valid numbers (not NaN)
                     if !width.is_nan() && !height.is_nan() {
                         // Create viewBox and remove width/height
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:69:
         "removes width and height in presence of viewBox (opposite to removeViewBox)"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         self.process_element(&mut document.root);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:106:
     fn test_plugin_creation() {
         let plugin = RemoveDimensionsPlugin::new();
         assert_eq!(plugin.name(), "removeDimensions");
[31m-        assert_eq!(plugin.description(), "removes width and height in presence of viewBox (opposite to removeViewBox)");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes width and height in presence of viewBox (opposite to removeViewBox)"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:113:
     fn test_remove_dimensions_with_existing_viewbox() {
         let mut plugin = RemoveDimensionsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Set up SVG with width, height, and viewBox
[31m-        doc.root.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        doc.root.attributes.insert("height".to_string(), "50".to_string());
(B[m[31m-        doc.root.attributes.insert("viewBox".to_string(), "0 0 200 100".to_string());
(B[m[31m-        
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50".to_string());
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("viewBox".to_string(), "0 0 200 100".to_string());
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:125:
[31m-        
(B[m[32m+
(B[m         // Width and height should be removed, viewBox should remain unchanged
         assert!(!doc.root.attributes.contains_key("width"));
         assert!(!doc.root.attributes.contains_key("height"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:129:
[31m-        assert_eq!(doc.root.attributes.get("viewBox"), Some(&"0 0 200 100".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            doc.root.attributes.get("viewBox"),
(B[m[32m+            Some(&"0 0 200 100".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:133:
     fn test_create_viewbox_from_dimensions() {
         let mut plugin = RemoveDimensionsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Set up SVG with only width and height
[31m-        doc.root.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        doc.root.attributes.insert("height".to_string(), "50".to_string());
(B[m[31m-        
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50".to_string());
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:144:
[31m-        
(B[m[32m+
(B[m         // Width and height should be removed, viewBox should be created
         assert!(!doc.root.attributes.contains_key("width"));
         assert!(!doc.root.attributes.contains_key("height"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:148:
[31m-        assert_eq!(doc.root.attributes.get("viewBox"), Some(&"0 0 100 50".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            doc.root.attributes.get("viewBox"),
(B[m[32m+            Some(&"0 0 100 50".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:152:
     fn test_decimal_dimensions() {
         let mut plugin = RemoveDimensionsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Set up SVG with decimal dimensions
[31m-        doc.root.attributes.insert("width".to_string(), "100.5".to_string());
(B[m[31m-        doc.root.attributes.insert("height".to_string(), "50.25".to_string());
(B[m[31m-        
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100.5".to_string());
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50.25".to_string());
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:163:
[31m-        
(B[m[32m+
(B[m         // Width and height should be removed, viewBox should be created with decimals
         assert!(!doc.root.attributes.contains_key("width"));
         assert!(!doc.root.attributes.contains_key("height"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:167:
[31m-        assert_eq!(doc.root.attributes.get("viewBox"), Some(&"0 0 100.5 50.25".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            doc.root.attributes.get("viewBox"),
(B[m[32m+            Some(&"0 0 100.5 50.25".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:171:
     fn test_invalid_dimensions_ignored() {
         let mut plugin = RemoveDimensionsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Set up SVG with invalid dimensions
[31m-        doc.root.attributes.insert("width".to_string(), "invalid".to_string());
(B[m[31m-        doc.root.attributes.insert("height".to_string(), "50".to_string());
(B[m[31m-        
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "invalid".to_string());
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50".to_string());
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:182:
[31m-        
(B[m[32m+
(B[m         // Width and height should remain since they're not both valid numbers
[31m-        assert_eq!(doc.root.attributes.get("width"), Some(&"invalid".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            doc.root.attributes.get("width"),
(B[m[32m+            Some(&"invalid".to_string())
(B[m[32m+        );
(B[m         assert_eq!(doc.root.attributes.get("height"), Some(&"50".to_string()));
         assert!(!doc.root.attributes.contains_key("viewBox"));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:190:
     fn test_missing_dimension_ignored() {
         let mut plugin = RemoveDimensionsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Set up SVG with only width
[31m-        doc.root.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:200:
[31m-        
(B[m[32m+
(B[m         // Width should remain since height is missing
         assert_eq!(doc.root.attributes.get("width"), Some(&"100".to_string()));
         assert!(!doc.root.attributes.contains_key("viewBox"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:207:
     fn test_only_processes_svg_elements() {
         let mut plugin = RemoveDimensionsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add a rect element with width and height (should not be processed)
         let mut rect_attrs = IndexMap::new();
         rect_attrs.insert("width".to_string(), "100".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:214:
         rect_attrs.insert("height".to_string(), "50".to_string());
         rect_attrs.insert("x".to_string(), "10".to_string());
         rect_attrs.insert("y".to_string(), "10".to_string());
[31m-        
(B[m[32m+
(B[m         doc.root.children.push(Node::Element(Element {
             name: "rect".to_string(),
             attributes: rect_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:221:
             namespaces: HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:228:
[31m-        
(B[m[32m+
(B[m         // Rect dimensions should remain unchanged
         if let Node::Element(rect) = &doc.root.children[0] {
             assert_eq!(rect.attributes.get("width"), Some(&"100".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:240:
     fn test_nested_svg_elements() {
         let mut plugin = RemoveDimensionsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Set up root SVG
[31m-        doc.root.attributes.insert("width".to_string(), "200".to_string());
(B[m[31m-        doc.root.attributes.insert("height".to_string(), "100".to_string());
(B[m[31m-        
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "200".to_string());
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "100".to_string());
(B[m[32m+
(B[m         // Add nested SVG element
         let mut nested_svg_attrs = IndexMap::new();
         nested_svg_attrs.insert("width".to_string(), "100".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:251:
         nested_svg_attrs.insert("height".to_string(), "50".to_string());
[31m-        
(B[m[32m+
(B[m         doc.root.children.push(Node::Element(Element {
             name: "svg".to_string(),
             attributes: nested_svg_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:256:
             namespaces: HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:263:
[31m-        
(B[m[32m+
(B[m         // Root SVG should have viewBox and no dimensions
         assert!(!doc.root.attributes.contains_key("width"));
         assert!(!doc.root.attributes.contains_key("height"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:267:
[31m-        assert_eq!(doc.root.attributes.get("viewBox"), Some(&"0 0 200 100".to_string()));
(B[m[31m-        
(B[m[32m+        assert_eq!(
(B[m[32m+            doc.root.attributes.get("viewBox"),
(B[m[32m+            Some(&"0 0 200 100".to_string())
(B[m[32m+        );
(B[m[32m+
(B[m         // Nested SVG should also be processed
         if let Node::Element(nested_svg) = &doc.root.children[0] {
             assert!(!nested_svg.attributes.contains_key("width"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:272:
             assert!(!nested_svg.attributes.contains_key("height"));
[31m-            assert_eq!(nested_svg.attributes.get("viewBox"), Some(&"0 0 100 50".to_string()));
(B[m[32m+            assert_eq!(
(B[m[32m+                nested_svg.attributes.get("viewBox"),
(B[m[32m+                Some(&"0 0 100 50".to_string())
(B[m[32m+            );
(B[m         } else {
             panic!("Expected nested SVG element");
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:280:
     fn test_zero_dimensions() {
         let mut plugin = RemoveDimensionsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Set up SVG with zero dimensions
[31m-        doc.root.attributes.insert("width".to_string(), "0".to_string());
(B[m[31m-        doc.root.attributes.insert("height".to_string(), "0".to_string());
(B[m[31m-        
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "0".to_string());
(B[m[32m+        doc.root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "0".to_string());
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:291:
[31m-        
(B[m[32m+
(B[m         // Should still create viewBox even with zero dimensions
         assert!(!doc.root.attributes.contains_key("width"));
         assert!(!doc.root.attributes.contains_key("height"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:295:
[31m-        assert_eq!(doc.root.attributes.get("viewBox"), Some(&"0 0 0 0".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            doc.root.attributes.get("viewBox"),
(B[m[32m+            Some(&"0 0 0 0".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:299:
     fn test_no_dimensions_no_change() {
         let mut plugin = RemoveDimensionsPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // SVG with no width, height, or viewBox
         let original_count = doc.root.attributes.len();
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:309:
[31m-        
(B[m[32m+
(B[m         // Should not add any attributes
         assert_eq!(doc.root.attributes.len(), original_count);
         assert!(!doc.root.attributes.contains_key("width"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_dimensions.rs:314:
         assert!(!doc.root.attributes.contains_key("viewBox"));
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_doctype.rs:18:
     fn name(&self) -> &'static str {
         "removeDoctype"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Remove DOCTYPE declaration"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_doctype.rs:25:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Remove DOCTYPE from prologue
         document.prologue.retain(|node| !node.is_doctype());
[31m-        
(B[m[32m+
(B[m         // DOCTYPE shouldn't appear in epilogue, but check anyway
         document.epilogue.retain(|node| !node.is_doctype());
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_doctype.rs:39:
 mod tests {
     use super::*;
     use crate::parser::Parser;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_doctype() {
         let svg = r#"<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_doctype.rs:46:
 <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
     <rect x="10" y="10" width="80" height="80"/>
 </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         // Verify DOCTYPE is present
         assert!(document.prologue.iter().any(|n| n.is_doctype()));
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveDoctypePlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Verify DOCTYPE is removed
         assert!(!document.prologue.iter().any(|n| n.is_doctype()));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_doctype.rs:62:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_empty_document() {
         let svg = r#"<svg xmlns="http://www.w3.org/2000/svg"/>"#;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_doctype.rs:66:
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveDoctypePlugin;
         // Should not fail on documents without DOCTYPE
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:6:
 use serde_json::Value;
 use std::collections::HashSet;
 
[31m-#[derive(Debug, Clone)]
(B[m[31m-#[derive(Default)]
(B[m[32m+#[derive(Debug, Clone, Default)]
(B[m pub struct RemoveEditorsNSDataConfig {
     /// Additional namespaces to remove besides the default editor namespaces
     pub additional_namespaces: Vec<String>,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:14:
 }
 
[31m-
(B[m pub struct RemoveEditorsNSDataPlugin;
 
 impl Default for RemoveEditorsNSDataPlugin {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:29:
 
     fn parse_config(&self, params: Option<&Value>) -> RemoveEditorsNSDataConfig {
         let mut config = RemoveEditorsNSDataConfig::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(obj)) = params {
             if let Some(Value::Array(additional)) = obj.get("additionalNamespaces") {
                 config.additional_namespaces = additional
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:38:
                     .collect();
             }
         }
[31m-        
(B[m[32m+
(B[m         config
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:45:
[31m-    fn collect_editor_prefixes(&self, element: &mut Element, config: &RemoveEditorsNSDataConfig) -> Vec<String> {
(B[m[32m+    fn collect_editor_prefixes(
(B[m[32m+        &self,
(B[m[32m+        element: &mut Element,
(B[m[32m+        config: &RemoveEditorsNSDataConfig,
(B[m[32m+    ) -> Vec<String> {
(B[m         let mut prefixes = Vec::new();
[31m-        
(B[m[32m+
(B[m         if element.name == "svg" {
             // Create a combined set of namespaces to check
             let mut namespaces_to_remove = HashSet::new();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:54:
             for ns in &config.additional_namespaces {
                 namespaces_to_remove.insert(ns.as_str());
             }
[31m-            
(B[m[32m+
(B[m             // Collect namespace prefixes and remove xmlns declarations
             let mut attrs_to_remove = Vec::new();
[31m-            
(B[m[32m+
(B[m             for (name, value) in &element.attributes {
                 if name.starts_with("xmlns:") && namespaces_to_remove.contains(value.as_str()) {
                     let prefix = &name[6..]; // Remove "xmlns:" prefix
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:65:
                     attrs_to_remove.push(name.clone());
                 }
             }
[31m-            
(B[m[32m+
(B[m             // Remove the xmlns declarations
             for attr in attrs_to_remove {
                 element.attributes.shift_remove(&attr);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:72:
             }
         }
[31m-        
(B[m[32m+
(B[m         prefixes
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:78:
     fn remove_editor_attributes(&self, element: &mut Element, prefixes: &[String]) {
         let mut attrs_to_remove = Vec::new();
[31m-        
(B[m[32m+
(B[m         for name in element.attributes.keys() {
             if name.contains(':') {
                 if let Some(colon_pos) = name.find(':') {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:88:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         // Remove the editor attributes
         for attr in attrs_to_remove {
             element.attributes.shift_remove(&attr);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:105:
         false
     }
 
[31m-    fn process_element(&self, element: &mut Element, prefixes: &mut Vec<String>, config: &RemoveEditorsNSDataConfig) {
(B[m[32m+    fn process_element(
(B[m[32m+        &self,
(B[m[32m+        element: &mut Element,
(B[m[32m+        prefixes: &mut Vec<String>,
(B[m[32m+        config: &RemoveEditorsNSDataConfig,
(B[m[32m+    ) {
(B[m         // If this is the SVG root element, collect editor prefixes
         if element.name == "svg" && prefixes.is_empty() {
             *prefixes = self.collect_editor_prefixes(element, config);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:122:
                     if self.should_remove_element(child_elem, prefixes) {
                         return false; // Remove this element
                     }
[31m-                    
(B[m[32m+
(B[m                     // Recursively process this child element
                     self.process_element(child_elem, prefixes, config);
                     true // Keep this element
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:142:
         "removes editors namespaces, elements and attributes"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = self.parse_config(params);
         let mut prefixes = Vec::new();
[31m-        
(B[m[32m+
(B[m         self.process_element(&mut document.root, &mut prefixes, &config);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:183:
     fn test_plugin_creation() {
         let plugin = RemoveEditorsNSDataPlugin::new();
         assert_eq!(plugin.name(), "removeEditorsNSData");
[31m-        assert_eq!(plugin.description(), "removes editors namespaces, elements and attributes");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes editors namespaces, elements and attributes"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:190:
     fn test_collect_editor_prefixes() {
         let plugin = RemoveEditorsNSDataPlugin::new();
         let config = RemoveEditorsNSDataConfig::default();
[31m-        
(B[m[32m+
(B[m         let mut svg_element = Element {
             name: "svg".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:197:
             namespaces: HashMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         // Add some editor namespace declarations
[31m-        svg_element.attributes.insert("xmlns:sodipodi".to_string(), "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd".to_string());
(B[m[31m-        svg_element.attributes.insert("xmlns:inkscape".to_string(), "http://www.inkscape.org/namespaces/inkscape".to_string());
(B[m[31m-        svg_element.attributes.insert("xmlns:normal".to_string(), "http://normal.namespace".to_string());
(B[m[31m-        
(B[m[32m+        svg_element.attributes.insert(
(B[m[32m+            "xmlns:sodipodi".to_string(),
(B[m[32m+            "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd".to_string(),
(B[m[32m+        );
(B[m[32m+        svg_element.attributes.insert(
(B[m[32m+            "xmlns:inkscape".to_string(),
(B[m[32m+            "http://www.inkscape.org/namespaces/inkscape".to_string(),
(B[m[32m+        );
(B[m[32m+        svg_element.attributes.insert(
(B[m[32m+            "xmlns:normal".to_string(),
(B[m[32m+            "http://normal.namespace".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         let prefixes = plugin.collect_editor_prefixes(&mut svg_element, &config);
[31m-        
(B[m[32m+
(B[m         // Should have collected the editor prefixes and removed xmlns declarations
         assert!(prefixes.contains(&"sodipodi".to_string()));
         assert!(prefixes.contains(&"inkscape".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:211:
         assert!(!prefixes.contains(&"normal".to_string()));
[31m-        
(B[m[32m+
(B[m         // Editor xmlns declarations should be removed
         assert!(!svg_element.attributes.contains_key("xmlns:sodipodi"));
         assert!(!svg_element.attributes.contains_key("xmlns:inkscape"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:216:
[31m-        
(B[m[32m+
(B[m         // Normal xmlns should remain
         assert!(svg_element.attributes.contains_key("xmlns:normal"));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:222:
     fn test_remove_editor_attributes() {
         let plugin = RemoveEditorsNSDataPlugin::new();
         let prefixes = vec!["sodipodi".to_string(), "inkscape".to_string()];
[31m-        
(B[m[32m+
(B[m         let mut element = Element {
             name: "path".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:229:
             namespaces: HashMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         // Add various attributes
[31m-        element.attributes.insert("d".to_string(), "M0,0 L10,10".to_string());
(B[m[31m-        element.attributes.insert("sodipodi:nodetypes".to_string(), "cc".to_string());
(B[m[31m-        element.attributes.insert("inkscape:connector-curvature".to_string(), "0".to_string());
(B[m[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("d".to_string(), "M0,0 L10,10".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("sodipodi:nodetypes".to_string(), "cc".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("inkscape:connector-curvature".to_string(), "0".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+
(B[m         plugin.remove_editor_attributes(&mut element, &prefixes);
[31m-        
(B[m[32m+
(B[m         // Editor attributes should be removed
         assert!(!element.attributes.contains_key("sodipodi:nodetypes"));
[31m-        assert!(!element.attributes.contains_key("inkscape:connector-curvature"));
(B[m[31m-        
(B[m[32m+        assert!(!element
(B[m[32m+            .attributes
(B[m[32m+            .contains_key("inkscape:connector-curvature"));
(B[m[32m+
(B[m         // Normal attributes should remain
         assert!(element.attributes.contains_key("d"));
         assert!(element.attributes.contains_key("fill"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:251:
     fn test_should_remove_element() {
         let plugin = RemoveEditorsNSDataPlugin::new();
         let prefixes = vec!["sodipodi".to_string()];
[31m-        
(B[m[32m+
(B[m         let editor_element = Element {
             name: "sodipodi:namedview".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:258:
             namespaces: HashMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         let normal_element = Element {
             name: "path".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:265:
             namespaces: HashMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         assert!(plugin.should_remove_element(&editor_element, &prefixes));
         assert!(!plugin.should_remove_element(&normal_element, &prefixes));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:274:
     fn test_apply_removes_editor_content() {
         let mut plugin = RemoveEditorsNSDataPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Set up SVG root with editor namespace
[31m-        doc.root.attributes.insert("xmlns:sodipodi".to_string(), "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd".to_string());
(B[m[31m-        
(B[m[32m+        doc.root.attributes.insert(
(B[m[32m+            "xmlns:sodipodi".to_string(),
(B[m[32m+            "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         // Add editor element
         let sodipodi_element = Element {
             name: "sodipodi:namedview".to_string(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:286:
             children: vec![],
         };
         doc.root.children.push(Node::Element(sodipodi_element));
[31m-        
(B[m[32m+
(B[m         // Add normal element with editor attribute
         let mut path_attrs = IndexMap::new();
         path_attrs.insert("d".to_string(), "M0,0 L10,10".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:298:
             children: vec![],
         };
         doc.root.children.push(Node::Element(path_element));
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:305:
[31m-        
(B[m[32m+
(B[m         // Editor namespace should be removed
         assert!(!doc.root.attributes.contains_key("xmlns:sodipodi"));
[31m-        
(B[m[32m+
(B[m         // Should have only one child (path element, sodipodi:namedview removed)
         assert_eq!(doc.root.children.len(), 1);
[31m-        
(B[m[32m+
(B[m         // Path element should have editor attribute removed
         if let Node::Element(path) = &doc.root.children[0] {
             assert_eq!(path.name, "path");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:323:
     fn test_apply_with_additional_namespaces() {
         let mut plugin = RemoveEditorsNSDataPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Set up SVG root with custom namespace
[31m-        doc.root.attributes.insert("xmlns:custom".to_string(), "http://custom.editor/ns".to_string());
(B[m[31m-        
(B[m[32m+        doc.root.attributes.insert(
(B[m[32m+            "xmlns:custom".to_string(),
(B[m[32m+            "http://custom.editor/ns".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         // Add custom editor element
         let custom_element = Element {
             name: "custom:element".to_string(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:335:
             children: vec![],
         };
         doc.root.children.push(Node::Element(custom_element));
[31m-        
(B[m[32m+
(B[m         let config = serde_json::json!({
             "additionalNamespaces": ["http://custom.editor/ns"]
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:342:
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, Some(&config));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:346:
[31m-        
(B[m[32m+
(B[m         // Custom namespace should be removed
         assert!(!doc.root.attributes.contains_key("xmlns:custom"));
[31m-        
(B[m[32m+
(B[m         // Custom element should be removed
         assert_eq!(doc.root.children.len(), 0);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:355:
     fn test_apply_preserves_normal_content() {
         let mut plugin = RemoveEditorsNSDataPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add normal element
         let mut rect_attrs = IndexMap::new();
         rect_attrs.insert("x".to_string(), "10".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:369:
             children: vec![],
         };
         doc.root.children.push(Node::Element(rect_element));
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:376:
[31m-        
(B[m[32m+
(B[m         // Normal element should be preserved
         assert_eq!(doc.root.children.len(), 1);
         if let Node::Element(rect) = &doc.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_editors_ns_data.rs:384:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:5:
 use serde_json::Value;
 use std::collections::HashSet;
 
[31m-#[derive(Debug, Clone)]
(B[m[31m-#[derive(Default)]
(B[m[32m+#[derive(Debug, Clone, Default)]
(B[m pub struct RemoveElementsByAttrConfig {
     /// IDs of elements to remove
     pub ids: Vec<String>,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:14:
     pub classes: Vec<String>,
 }
 
[31m-
(B[m pub struct RemoveElementsByAttrPlugin;
 
 impl Default for RemoveElementsByAttrPlugin {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:30:
 
     fn parse_config(&self, params: Option<&Value>) -> RemoveElementsByAttrConfig {
         let mut config = RemoveElementsByAttrConfig::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(obj)) = params {
             // Parse IDs
             if let Some(id_value) = obj.get("id") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:46:
                     _ => {}
                 }
             }
[31m-            
(B[m[32m+
(B[m             // Parse classes
             if let Some(class_value) = obj.get("class") {
                 match class_value {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:62:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         config
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:69:
[31m-    fn should_remove_element(&self, element: &Element, config: &RemoveElementsByAttrConfig) -> bool {
(B[m[32m+    fn should_remove_element(
(B[m[32m+        &self,
(B[m[32m+        element: &Element,
(B[m[32m+        config: &RemoveElementsByAttrConfig,
(B[m[32m+    ) -> bool {
(B[m         // Check if element ID matches any configured IDs
         if !config.ids.is_empty() {
             if let Some(id) = element.attributes.get("id") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:75:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         // Check if element class contains any of the configured classes
         if !config.classes.is_empty() {
             if let Some(class_attr) = element.attributes.get("class") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:87:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         false
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:100:
                     if self.should_remove_element(child_elem, config) {
                         return false; // Remove this element
                     }
[31m-                    
(B[m[32m+
(B[m                     // Recursively process this child element
                     self.process_element(child_elem, config);
                     true // Keep this element
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:120:
         "removes arbitrary elements by ID or className (disabled by default)"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = self.parse_config(params);
[31m-        
(B[m[32m+
(B[m         // Only proceed if we have something to remove
         if config.ids.is_empty() && config.classes.is_empty() {
             return Ok(());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:129:
         }
[31m-        
(B[m[32m+
(B[m         self.process_element(&mut document.root, &config);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:165:
     fn test_plugin_creation() {
         let plugin = RemoveElementsByAttrPlugin::new();
         assert_eq!(plugin.name(), "removeElementsByAttr");
[31m-        assert_eq!(plugin.description(), "removes arbitrary elements by ID or className (disabled by default)");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes arbitrary elements by ID or className (disabled by default)"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:174:
         let config_json = serde_json::json!({
             "id": "elementToRemove"
         });
[31m-        
(B[m[32m+
(B[m         let config = plugin.parse_config(Some(&config_json));
         assert_eq!(config.ids, vec!["elementToRemove"]);
         assert!(config.classes.is_empty());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:186:
         let config_json = serde_json::json!({
             "id": ["elementToRemove1", "elementToRemove2"]
         });
[31m-        
(B[m[32m+
(B[m         let config = plugin.parse_config(Some(&config_json));
         assert_eq!(config.ids, vec!["elementToRemove1", "elementToRemove2"]);
         assert!(config.classes.is_empty());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:198:
         let config_json = serde_json::json!({
             "class": "classToRemove"
         });
[31m-        
(B[m[32m+
(B[m         let config = plugin.parse_config(Some(&config_json));
         assert!(config.ids.is_empty());
         assert_eq!(config.classes, vec!["classToRemove"]);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:210:
         let config_json = serde_json::json!({
             "class": ["classToRemove1", "classToRemove2"]
         });
[31m-        
(B[m[32m+
(B[m         let config = plugin.parse_config(Some(&config_json));
         assert!(config.ids.is_empty());
         assert_eq!(config.classes, vec!["classToRemove1", "classToRemove2"]);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:223:
             "id": "elementToRemove",
             "class": ["classToRemove1", "classToRemove2"]
         });
[31m-        
(B[m[32m+
(B[m         let config = plugin.parse_config(Some(&config_json));
         assert_eq!(config.ids, vec!["elementToRemove"]);
         assert_eq!(config.classes, vec!["classToRemove1", "classToRemove2"]);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:236:
             ids: vec!["removeMe".to_string()],
             classes: vec![],
         };
[31m-        
(B[m[32m+
(B[m         let mut element_attrs = IndexMap::new();
         element_attrs.insert("id".to_string(), "removeMe".to_string());
         let element = Element {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:245:
             namespaces: HashMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         assert!(plugin.should_remove_element(&element, &config));
[31m-        
(B[m[32m+
(B[m         // Test element that shouldn't be removed
         let mut element_attrs2 = IndexMap::new();
         element_attrs2.insert("id".to_string(), "keepMe".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:257:
             namespaces: HashMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         assert!(!plugin.should_remove_element(&element2, &config));
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:268:
             ids: vec![],
             classes: vec!["removeMe".to_string()],
         };
[31m-        
(B[m[32m+
(B[m         // Test element with matching class
         let mut element_attrs = IndexMap::new();
[31m-        element_attrs.insert("class".to_string(), "someClass removeMe anotherClass".to_string());
(B[m[32m+        element_attrs.insert(
(B[m[32m+            "class".to_string(),
(B[m[32m+            "someClass removeMe anotherClass".to_string(),
(B[m[32m+        );
(B[m         let element = Element {
             name: "rect".to_string(),
             attributes: element_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:278:
             namespaces: HashMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         assert!(plugin.should_remove_element(&element, &config));
[31m-        
(B[m[32m+
(B[m         // Test element that shouldn't be removed
         let mut element_attrs2 = IndexMap::new();
[31m-        element_attrs2.insert("class".to_string(), "someClass keepMe anotherClass".to_string());
(B[m[32m+        element_attrs2.insert(
(B[m[32m+            "class".to_string(),
(B[m[32m+            "someClass keepMe anotherClass".to_string(),
(B[m[32m+        );
(B[m         let element2 = Element {
             name: "rect".to_string(),
             attributes: element_attrs2,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:290:
             namespaces: HashMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         assert!(!plugin.should_remove_element(&element2, &config));
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:298:
     fn test_apply_removes_by_id() {
         let mut plugin = RemoveElementsByAttrPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add element to remove
         let mut attrs_remove = IndexMap::new();
         attrs_remove.insert("id".to_string(), "elementToRemove".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:308:
             namespaces: HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         // Add element to keep
         let mut attrs_keep = IndexMap::new();
         attrs_keep.insert("id".to_string(), "elementToKeep".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:318:
             namespaces: HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         let config = serde_json::json!({
             "id": "elementToRemove"
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:325:
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, Some(&config));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:329:
[31m-        
(B[m[32m+
(B[m         // Should have only one element remaining
         assert_eq!(doc.root.children.len(), 1);
         if let Node::Element(element) = &doc.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:333:
             assert_eq!(element.name, "circle");
[31m-            assert_eq!(element.attributes.get("id"), Some(&"elementToKeep".to_string()));
(B[m[32m+            assert_eq!(
(B[m[32m+                element.attributes.get("id"),
(B[m[32m+                Some(&"elementToKeep".to_string())
(B[m[32m+            );
(B[m         } else {
             panic!("Expected element");
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:341:
     fn test_apply_removes_by_class() {
         let mut plugin = RemoveElementsByAttrPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add element to remove
         let mut attrs_remove = IndexMap::new();
[31m-        attrs_remove.insert("class".to_string(), "some-class removeMe another-class".to_string());
(B[m[32m+        attrs_remove.insert(
(B[m[32m+            "class".to_string(),
(B[m[32m+            "some-class removeMe another-class".to_string(),
(B[m[32m+        );
(B[m         doc.root.children.push(Node::Element(Element {
             name: "rect".to_string(),
             attributes: attrs_remove,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:351:
             namespaces: HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         // Add element to keep
         let mut attrs_keep = IndexMap::new();
[31m-        attrs_keep.insert("class".to_string(), "some-class keep-me another-class".to_string());
(B[m[32m+        attrs_keep.insert(
(B[m[32m+            "class".to_string(),
(B[m[32m+            "some-class keep-me another-class".to_string(),
(B[m[32m+        );
(B[m         doc.root.children.push(Node::Element(Element {
             name: "circle".to_string(),
             attributes: attrs_keep,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:361:
             namespaces: HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         let config = serde_json::json!({
             "class": "removeMe"
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:368:
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, Some(&config));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:372:
[31m-        
(B[m[32m+
(B[m         // Should have only one element remaining
         assert_eq!(doc.root.children.len(), 1);
         if let Node::Element(element) = &doc.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:376:
             assert_eq!(element.name, "circle");
[31m-            assert_eq!(element.attributes.get("class"), Some(&"some-class keep-me another-class".to_string()));
(B[m[32m+            assert_eq!(
(B[m[32m+                element.attributes.get("class"),
(B[m[32m+                Some(&"some-class keep-me another-class".to_string())
(B[m[32m+            );
(B[m         } else {
             panic!("Expected element");
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:384:
     fn test_apply_no_config_does_nothing() {
         let mut plugin = RemoveElementsByAttrPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add some elements
         let mut attrs = IndexMap::new();
         attrs.insert("id".to_string(), "someId".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:394:
             namespaces: HashMap::new(),
             children: vec![],
         }));
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:401:
[31m-        
(B[m[32m+
(B[m         // Should still have the element
         assert_eq!(doc.root.children.len(), 1);
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:407:
     fn test_apply_recursive() {
         let mut plugin = RemoveElementsByAttrPlugin::new();
         let mut doc = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Create nested structure
         let mut nested_attrs = IndexMap::new();
         nested_attrs.insert("id".to_string(), "removeMe".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:417:
             namespaces: HashMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         let mut group_attrs = IndexMap::new();
         group_attrs.insert("id".to_string(), "group".to_string());
         let group = Element {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:426:
             namespaces: HashMap::new(),
             children: vec![Node::Element(nested_element)],
         };
[31m-        
(B[m[32m+
(B[m         doc.root.children.push(Node::Element(group));
[31m-        
(B[m[32m+
(B[m         let config = serde_json::json!({
             "id": "removeMe"
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:435:
[31m-        
(B[m[32m+
(B[m         let info = PluginInfo::default();
         let result = plugin.apply(&mut doc, &info, Some(&config));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:439:
[31m-        
(B[m[32m+
(B[m         // Group should remain but nested element should be removed
         assert_eq!(doc.root.children.len(), 1);
         if let Node::Element(group) = &doc.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_elements_by_attr.rs:447:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:15:
 /// Set of conditional processing attributes that should be preserved even when empty
 /// as they have semantic meaning for element rendering
 static CONDITIONAL_PROCESSING_ATTRS: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {
[31m-    [
(B[m[31m-        "requiredExtensions",
(B[m[31m-        "requiredFeatures", 
(B[m[31m-        "systemLanguage",
(B[m[31m-    ]
(B[m[31m-    .into_iter()
(B[m[31m-    .collect()
(B[m[32m+    ["requiredExtensions", "requiredFeatures", "systemLanguage"]
(B[m[32m+        .into_iter()
(B[m[32m+        .collect()
(B[m });
 
 /// Plugin to remove attributes with empty values
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:36:
         "removes empty attributes"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         visit_elements(&mut document.root, remove_empty_attrs);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:45:
 /// Visit all elements in the AST and apply the transformation function
 fn visit_elements(element: &mut Element, transform: fn(&mut Element)) {
     transform(element);
[31m-    
(B[m[32m+
(B[m     for child in &mut element.children {
         if let Node::Element(child_element) = child {
             visit_elements(child_element, transform);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:60:
         if CONDITIONAL_PROCESSING_ATTRS.contains(name.as_str()) {
             return true;
         }
[31m-        
(B[m[32m+
(B[m         // Remove attributes with empty values
         !value.is_empty()
     });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:76:
     fn test_removes_empty_attributes() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[32m+
(B[m         // Add some attributes, including empty ones
[31m-        element.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        element.attributes.insert("height".to_string(), "".to_string()); // empty
(B[m[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        element.attributes.insert("stroke".to_string(), "".to_string()); // empty
(B[m[31m-        
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "".to_string()); // empty
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "".to_string()); // empty
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveEmptyAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:89:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Should keep non-empty attributes
         assert!(document.root.attributes.contains_key("width"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:93:
         assert!(document.root.attributes.contains_key("fill"));
[31m-        
(B[m[32m+
(B[m         // Should remove empty attributes
         assert!(!document.root.attributes.contains_key("height"));
         assert!(!document.root.attributes.contains_key("stroke"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:101:
     fn test_preserves_conditional_processing_attrs() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[32m+
(B[m         // Add conditional processing attributes with empty values
[31m-        element.attributes.insert("requiredExtensions".to_string(), "".to_string());
(B[m[31m-        element.attributes.insert("requiredFeatures".to_string(), "".to_string());
(B[m[31m-        element.attributes.insert("systemLanguage".to_string(), "".to_string());
(B[m[31m-        element.attributes.insert("width".to_string(), "".to_string()); // regular empty attr
(B[m[31m-        
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("requiredExtensions".to_string(), "".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("requiredFeatures".to_string(), "".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("systemLanguage".to_string(), "".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "".to_string()); // regular empty attr
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveEmptyAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:114:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Should preserve conditional processing attributes even when empty
         assert!(document.root.attributes.contains_key("requiredExtensions"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:118:
         assert!(document.root.attributes.contains_key("requiredFeatures"));
         assert!(document.root.attributes.contains_key("systemLanguage"));
[31m-        
(B[m[32m+
(B[m         // Should remove regular empty attributes
         assert!(!document.root.attributes.contains_key("width"));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:127:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let mut child = Element::new("g");
[31m-        
(B[m[32m+
(B[m         // Add empty attributes to both elements
[31m-        root.attributes.insert("width".to_string(), "100".to_string());
(B[m[32m+        root.attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m         root.attributes.insert("height".to_string(), "".to_string()); // empty
[31m-        
(B[m[31m-        child.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        child.attributes.insert("stroke".to_string(), "".to_string()); // empty
(B[m[31m-        
(B[m[32m+
(B[m[32m+        child
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        child
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "".to_string()); // empty
(B[m[32m+
(B[m         root.children.push(Node::Element(child));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:141:
         let mut plugin = RemoveEmptyAttrsPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Check root element
         assert!(document.root.attributes.contains_key("width"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:146:
         assert!(!document.root.attributes.contains_key("height"));
[31m-        
(B[m[32m+
(B[m         // Check child element
         if let Node::Element(child_element) = &document.root.children[0] {
             assert!(child_element.attributes.contains_key("fill"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:162:
 
         let mut plugin = RemoveEmptyAttrsPlugin;
         let result = plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None);
[31m-        
(B[m[32m+
(B[m         assert!(result.is_ok());
         assert!(document.root.attributes.is_empty());
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_attrs.rs:174:
         assert_eq!(plugin.description(), "removes empty attributes");
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:16:
 static CONTAINER_ELEMENTS: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {
     [
         "a",
[31m-        "defs", 
(B[m[32m+        "defs",
(B[m         "foreignObject",
         "g",
         "marker",
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:43:
         "removes empty container elements"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Process the tree bottom-up to handle nested containers correctly
         remove_empty_containers(&mut document.root, None);
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:58:
             remove_empty_containers(child_element, Some(&element.name));
         }
     }
[31m-    
(B[m[32m+
(B[m     // Then remove empty container children from this element
     element.children.retain(|child| {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:75:
     if !CONTAINER_ELEMENTS.contains(element.name.as_str()) {
         return false;
     }
[31m-    
(B[m[32m+
(B[m     // Must be empty (no children)
     if !element.children.is_empty() {
         return false;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:82:
     }
[31m-    
(B[m[32m+
(B[m     // Don't remove root SVG elements
     if element.name == "svg" {
         return false;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:87:
     }
[31m-    
(B[m[32m+
(B[m     // Empty patterns may contain reusable configuration
     if element.name == "pattern" && !element.attributes.is_empty() {
         return false;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:92:
     }
[31m-    
(B[m[32m+
(B[m     // Empty <mask> with ID hides masked element
     if element.name == "mask" && element.attributes.contains_key("id") {
         return false;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:97:
     }
[31m-    
(B[m[32m+
(B[m     // Don't remove elements that are direct children of <switch>
     if parent_name == Some("switch") {
         return false;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:102:
     }
[31m-    
(B[m[32m+
(B[m     // The <g> may not have content, but the filter may cause a rectangle
     // to be created and filled with pattern
     if element.name == "g" && element.attributes.contains_key("filter") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:107:
         return false;
     }
[31m-    
(B[m[32m+
(B[m     // If we get here, it's safe to remove this empty container
     true
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:122:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let empty_defs = Element::new("defs");
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(empty_defs));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:129:
         let mut plugin = RemoveEmptyContainersPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Empty defs should be removed
         assert!(document.root.children.is_empty());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:138:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let empty_g = Element::new("g");
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(empty_g));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:145:
         let mut plugin = RemoveEmptyContainersPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Empty g should be removed
         assert!(document.root.children.is_empty());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:156:
         document.root = root;
 
         let mut plugin = RemoveEmptyContainersPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // SVG root should never be removed even if empty
         assert_eq!(document.root.name, "svg");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:167:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let mut pattern = Element::new("pattern");
[31m-        pattern.attributes.insert("id".to_string(), "mypattern".to_string());
(B[m[31m-        
(B[m[32m+        pattern
(B[m[32m+            .attributes
(B[m[32m+            .insert("id".to_string(), "mypattern".to_string());
(B[m[32m+
(B[m         root.children.push(Node::Element(pattern));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:175:
         let mut plugin = RemoveEmptyContainersPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Pattern with attributes should be preserved
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:187:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let mut mask = Element::new("mask");
[31m-        mask.attributes.insert("id".to_string(), "mymask".to_string());
(B[m[31m-        
(B[m[32m+        mask.attributes
(B[m[32m+            .insert("id".to_string(), "mymask".to_string());
(B[m[32m+
(B[m         root.children.push(Node::Element(mask));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:195:
         let mut plugin = RemoveEmptyContainersPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Mask with ID should be preserved
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:207:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let mut g = Element::new("g");
[31m-        g.attributes.insert("filter".to_string(), "url(#myfilter)".to_string());
(B[m[31m-        
(B[m[32m+        g.attributes
(B[m[32m+            .insert("filter".to_string(), "url(#myfilter)".to_string());
(B[m[32m+
(B[m         root.children.push(Node::Element(g));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:215:
         let mut plugin = RemoveEmptyContainersPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Group with filter should be preserved
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:228:
         let mut root = Element::new("svg");
         let mut switch = Element::new("switch");
         let empty_g = Element::new("g");
[31m-        
(B[m[32m+
(B[m         switch.children.push(Node::Element(empty_g));
         root.children.push(Node::Element(switch));
         document.root = root;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:235:
 
         let mut plugin = RemoveEmptyContainersPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Elements in switch should be preserved
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:250:
         let mut root = Element::new("svg");
         let mut outer_g = Element::new("g");
         let inner_g = Element::new("g");
[31m-        
(B[m[32m+
(B[m         outer_g.children.push(Node::Element(inner_g));
         root.children.push(Node::Element(outer_g));
         document.root = root;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:257:
 
         let mut plugin = RemoveEmptyContainersPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Both nested empty containers should be removed
         assert!(document.root.children.is_empty());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:268:
         let mut root = Element::new("svg");
         let rect = Element::new("rect");
         let empty_g = Element::new("g");
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(rect));
         root.children.push(Node::Element(empty_g));
         document.root = root;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:275:
 
         let mut plugin = RemoveEmptyContainersPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Should keep rect and remove empty g
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_containers.rs:290:
         assert_eq!(plugin.description(), "removes empty container elements");
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:37:
     /// Parse parameters from JSON value
     pub fn from_value(value: Option<&Value>) -> Self {
         let mut params = Self::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(map)) = value {
             if let Some(Value::Bool(text)) = map.get("text") {
                 params.text = *text;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:49:
                 params.tref = *tref;
             }
         }
[31m-        
(B[m[32m+
(B[m         params
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:63:
         "removes empty <text> elements"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = RemoveEmptyTextParams::from_value(params);
         remove_empty_text(&mut document.root, &config);
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:78:
             remove_empty_text(child_element, config);
         }
     }
[31m-    
(B[m[32m+
(B[m     // Then remove empty text elements from this element's children
     element.children.retain(|child| {
         if let Node::Element(child_element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:120:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let empty_text = Element::new("text");
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(empty_text));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:127:
         let mut plugin = RemoveEmptyTextPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Empty text should be removed
         assert!(document.root.children.is_empty());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:136:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let empty_tspan = Element::new("tspan");
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(empty_tspan));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:143:
         let mut plugin = RemoveEmptyTextPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Empty tspan should be removed
         assert!(document.root.children.is_empty());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:152:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let tref = Element::new("tref");
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(tref));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:159:
         let mut plugin = RemoveEmptyTextPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // tref without xlink:href should be removed
         assert!(document.root.children.is_empty());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:168:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let mut tref = Element::new("tref");
[31m-        tref.attributes.insert("xlink:href".to_string(), "#someref".to_string());
(B[m[31m-        
(B[m[32m+        tref.attributes
(B[m[32m+            .insert("xlink:href".to_string(), "#someref".to_string());
(B[m[32m+
(B[m         root.children.push(Node::Element(tref));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:176:
         let mut plugin = RemoveEmptyTextPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // tref with xlink:href should be preserved
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:189:
         let mut root = Element::new("svg");
         let mut text = Element::new("text");
         text.children.push(Node::Text("Hello".to_string()));
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(text));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:196:
         let mut plugin = RemoveEmptyTextPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Text with content should be preserved
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:209:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let empty_text = Element::new("text");
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(empty_text));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:216:
         let mut plugin = RemoveEmptyTextPlugin;
         let params = json!({"text": false});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         // Empty text should be preserved when text=false
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:226:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let empty_tspan = Element::new("tspan");
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(empty_tspan));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:233:
         let mut plugin = RemoveEmptyTextPlugin;
         let params = json!({"tspan": false});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         // Empty tspan should be preserved when tspan=false
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:243:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let tref = Element::new("tref");
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(tref));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:250:
         let mut plugin = RemoveEmptyTextPlugin;
         let params = json!({"tref": false});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         // tref without href should be preserved when tref=false
         assert_eq!(document.root.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:259:
     fn test_mixed_text_elements() {
         let mut document = Document::new();
         let mut root = Element::new("svg");
[31m-        
(B[m[32m+
(B[m         // Empty text (should be removed)
         let empty_text = Element::new("text");
         root.children.push(Node::Element(empty_text));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:266:
[31m-        
(B[m[32m+
(B[m         // Non-empty tspan (should be preserved)
         let mut tspan_with_content = Element::new("tspan");
[31m-        tspan_with_content.children.push(Node::Text("Content".to_string()));
(B[m[32m+        tspan_with_content
(B[m[32m+            .children
(B[m[32m+            .push(Node::Text("Content".to_string()));
(B[m         root.children.push(Node::Element(tspan_with_content));
[31m-        
(B[m[32m+
(B[m         // tref without href (should be removed)
         let tref_no_href = Element::new("tref");
         root.children.push(Node::Element(tref_no_href));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:275:
[31m-        
(B[m[32m+
(B[m         // tref with href (should be preserved)
         let mut tref_with_href = Element::new("tref");
[31m-        tref_with_href.attributes.insert("xlink:href".to_string(), "#ref".to_string());
(B[m[32m+        tref_with_href
(B[m[32m+            .attributes
(B[m[32m+            .insert("xlink:href".to_string(), "#ref".to_string());
(B[m         root.children.push(Node::Element(tref_with_href));
[31m-        
(B[m[32m+
(B[m         document.root = root;
 
         let mut plugin = RemoveEmptyTextPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:284:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Should have 2 elements remaining: tspan with content and tref with href
         assert_eq!(document.root.children.len(), 2);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:288:
[31m-        
(B[m[32m+
(B[m         if let Node::Element(child1) = &document.root.children[0] {
             assert_eq!(child1.name, "tspan");
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_empty_text.rs:301:
         assert_eq!(plugin.description(), "removes empty <text> elements");
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:3:
 //! Plugin to remove hidden elements
 //!
 //! This plugin removes elements that are hidden through various means:
[31m-//! - display="none" 
(B[m[32m+//! - display="none"
(B[m //! - visibility="hidden" or visibility="collapse"
 //! - opacity="0" (optional)
 //! - Zero width/height rectangles, ellipses, images
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:49:
         "removes hidden elements (disabled by default)"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = self.parse_config(params);
         self.process_element(&mut document.root, &config);
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:59:
 impl RemoveHiddenElemsPlugin {
     fn parse_config(&self, params: Option<&Value>) -> RemoveHiddenElemsConfig {
         let mut config = RemoveHiddenElemsConfig::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(obj)) = params {
             if let Some(Value::Bool(v)) = obj.get("displayNone") {
                 config.display_none = *v;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:74:
                 config.zero_size = *v;
             }
         }
[31m-        
(B[m[32m+
(B[m         config
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:110:
         if config.zero_size {
             match element.name.as_str() {
                 "rect" | "image" | "pattern" => {
[31m-                    if self.is_zero_dimension(element, "width") || self.is_zero_dimension(element, "height") {
(B[m[32m+                    if self.is_zero_dimension(element, "width")
(B[m[32m+                        || self.is_zero_dimension(element, "height")
(B[m[32m+                    {
(B[m                         return true;
                     }
                 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:120:
                     }
                 }
                 "ellipse" => {
[31m-                    if self.is_zero_dimension(element, "rx") || self.is_zero_dimension(element, "ry") {
(B[m[32m+                    if self.is_zero_dimension(element, "rx")
(B[m[32m+                        || self.is_zero_dimension(element, "ry")
(B[m[32m+                    {
(B[m                         return true;
                     }
                 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:183:
             if let Node::Element(ref mut child_elem) = child {
                 // First process the child's children
                 self.process_element(child_elem, config);
[31m-                
(B[m[32m+
(B[m                 // Then check if the child itself should be removed
                 !self.is_hidden(child_elem, config)
             } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:198:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document() -> Document {
         Document {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:230:
     fn test_plugin_name_and_description() {
         let plugin = RemoveHiddenElemsPlugin;
         assert_eq!(plugin.name(), "removeHiddenElems");
[31m-        assert_eq!(plugin.description(), "removes hidden elements (disabled by default)");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes hidden elements (disabled by default)"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:237:
     fn test_remove_display_none() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
[31m-            Node::Element(create_element("rect", vec![("display", "none"), ("width", "100"), ("height", "100")])),
(B[m[31m-            Node::Element(create_element("circle", vec![("display", "block"), ("r", "50")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("display", "none"), ("width", "100"), ("height", "100")],
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "circle",
(B[m[32m+                vec![("display", "block"), ("r", "50")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveHiddenElemsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:256:
     #[test]
     fn test_remove_visibility_hidden() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
[31m-            Node::Element(create_element("rect", vec![("visibility", "hidden"), ("width", "100")])),
(B[m[31m-            Node::Element(create_element("rect", vec![("visibility", "collapse"), ("width", "100")])),
(B[m[31m-            Node::Element(create_element("rect", vec![("visibility", "visible"), ("width", "100")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("visibility", "hidden"), ("width", "100")],
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("visibility", "collapse"), ("width", "100")],
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("visibility", "visible"), ("width", "100")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveHiddenElemsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:270:
         // Elements with visibility="hidden" or "collapse" should be removed
         assert_eq!(document.root.children.len(), 1);
         if let Node::Element(elem) = &document.root.children[0] {
[31m-            assert_eq!(elem.attributes.get("visibility"), Some(&"visible".to_string()));
(B[m[32m+            assert_eq!(
(B[m[32m+                elem.attributes.get("visibility"),
(B[m[32m+                Some(&"visible".to_string())
(B[m[32m+            );
(B[m         }
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:277:
     #[test]
     fn test_remove_opacity_zero() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
[31m-            Node::Element(create_element("rect", vec![("opacity", "0"), ("width", "100")])),
(B[m[31m-            Node::Element(create_element("rect", vec![("opacity", "0.0"), ("width", "100")])),
(B[m[31m-            Node::Element(create_element("rect", vec![("opacity", "0.5"), ("width", "100")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("opacity", "0"), ("width", "100")],
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("opacity", "0.0"), ("width", "100")],
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("opacity", "0.5"), ("width", "100")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveHiddenElemsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:298:
     #[test]
     fn test_remove_zero_width_rect() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
[31m-            Node::Element(create_element("rect", vec![("width", "0"), ("height", "100")])),
(B[m[31m-            Node::Element(create_element("rect", vec![("width", "100"), ("height", "0")])),
(B[m[31m-            Node::Element(create_element("rect", vec![("width", "100"), ("height", "100")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("width", "0"), ("height", "100")],
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("width", "100"), ("height", "0")],
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("width", "100"), ("height", "100")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveHiddenElemsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:316:
     #[test]
     fn test_remove_zero_radius_circle() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
[31m-            Node::Element(create_element("circle", vec![("r", "0"), ("cx", "50"), ("cy", "50")])),
(B[m[31m-            Node::Element(create_element("circle", vec![("r", "50"), ("cx", "50"), ("cy", "50")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "circle",
(B[m[32m+                vec![("r", "0"), ("cx", "50"), ("cy", "50")],
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "circle",
(B[m[32m+                vec![("r", "50"), ("cx", "50"), ("cy", "50")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveHiddenElemsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:336:
     #[test]
     fn test_remove_zero_radius_ellipse() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             Node::Element(create_element("ellipse", vec![("rx", "0"), ("ry", "50")])),
             Node::Element(create_element("ellipse", vec![("rx", "50"), ("ry", "0")])),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:354:
     #[test]
     fn test_remove_empty_path() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             Node::Element(create_element("path", vec![("d", "")])),
             Node::Element(create_element("path", vec![("d", "  ")])),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:376:
     #[test]
     fn test_remove_empty_groups() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let empty_group = Element {
             name: "g".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:388:
             name: "g".to_string(),
             attributes: IndexMap::new(),
             namespaces: HashMap::new(),
[31m-            children: vec![Node::Element(create_element("rect", vec![("width", "100"), ("height", "100")]))],
(B[m[32m+            children: vec![Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("width", "100"), ("height", "100")],
(B[m[32m+            ))],
(B[m         };
 
[31m-        document.root.children = vec![
(B[m[31m-            Node::Element(empty_group),
(B[m[31m-            Node::Element(filled_group),
(B[m[31m-        ];
(B[m[32m+        document.root.children = vec![Node::Element(empty_group), Node::Element(filled_group)];
(B[m 
         let mut plugin = RemoveHiddenElemsPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), None);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:410:
     #[test]
     fn test_config_display_none_disabled() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.children = vec![
(B[m[31m-            Node::Element(create_element("rect", vec![("display", "none"), ("width", "100")])),
(B[m[31m-        ];
(B[m 
[32m+        document.root.children = vec![Node::Element(create_element(
(B[m[32m+            "rect",
(B[m[32m+            vec![("display", "none"), ("width", "100")],
(B[m[32m+        ))];
(B[m[32m+
(B[m         let config = serde_json::json!({
             "displayNone": false
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:430:
     #[test]
     fn test_nested_hidden_elements() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let group = Element {
             name: "g".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:437:
             namespaces: HashMap::new(),
             children: vec![
[31m-                Node::Element(create_element("rect", vec![("display", "none"), ("width", "100")])),
(B[m[32m+                Node::Element(create_element(
(B[m[32m+                    "rect",
(B[m[32m+                    vec![("display", "none"), ("width", "100")],
(B[m[32m+                )),
(B[m                 Node::Element(create_element("circle", vec![("r", "50")])),
[31m-                Node::Element(create_element("rect", vec![("visibility", "hidden"), ("width", "100")])),
(B[m[32m+                Node::Element(create_element(
(B[m[32m+                    "rect",
(B[m[32m+                    vec![("visibility", "hidden"), ("width", "100")],
(B[m[32m+                )),
(B[m             ],
         };
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:460:
     #[test]
     fn test_zero_line() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
[31m-            Node::Element(create_element("line", vec![("x1", "10"), ("y1", "10"), ("x2", "10"), ("y2", "10")])),
(B[m[31m-            Node::Element(create_element("line", vec![("x1", "10"), ("y1", "10"), ("x2", "20"), ("y2", "20")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "line",
(B[m[32m+                vec![("x1", "10"), ("y1", "10"), ("x2", "10"), ("y2", "10")],
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "line",
(B[m[32m+                vec![("x1", "10"), ("y1", "10"), ("x2", "20"), ("y2", "20")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveHiddenElemsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_hidden_elems.rs:474:
         assert_eq!(document.root.children.len(), 1);
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_metadata.rs:15:
     fn name(&self) -> &'static str {
         "removeMetadata"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Remove <metadata> elements from SVG document"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_metadata.rs:22:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Remove metadata elements from the document
         remove_metadata_from_node(&mut document.root);
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_metadata.rs:37:
             true
         }
     });
[31m-    
(B[m[32m+
(B[m     // Clean up whitespace-only text nodes if element now only has element children
     let has_element_children = node.children.iter().any(|c| c.is_element());
[31m-    let has_meaningful_text = node.children.iter().any(|c| {
(B[m[31m-        matches!(c, Node::Text(text) if !text.trim().is_empty())
(B[m[31m-    });
(B[m[31m-    
(B[m[32m+    let has_meaningful_text = node
(B[m[32m+        .children
(B[m[32m+        .iter()
(B[m[32m+        .any(|c| matches!(c, Node::Text(text) if !text.trim().is_empty()));
(B[m[32m+
(B[m     if has_element_children && !has_meaningful_text {
         // Remove whitespace-only text nodes
[31m-        node.children.retain(|child| {
(B[m[31m-            !matches!(child, Node::Text(text) if text.trim().is_empty())
(B[m[31m-        });
(B[m[32m+        node.children
(B[m[32m+            .retain(|child| !matches!(child, Node::Text(text) if text.trim().is_empty()));
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Recursively process child elements
     for child in &mut node.children {
         if let Node::Element(element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_metadata.rs:65:
     use super::*;
     use crate::ast::Element;
     use crate::parser::Parser;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_metadata() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_metadata.rs:79:
                 <rect/>
             </g>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveMetadataPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that metadata elements are removed
         assert!(!has_metadata(&document.root));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_metadata.rs:92:
[31m-    
(B[m[32m+
(B[m     fn has_metadata(element: &Element) -> bool {
         if element.name == "metadata" {
             return true;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_metadata.rs:96:
         }
[31m-        
(B[m[32m+
(B[m         for child in &element.children {
             if let Node::Element(el) = child {
                 if has_metadata(el) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_metadata.rs:105:
         false
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:23:
         "removes non-inheritable group's presentation attributes"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         self.process_element(&mut document.root);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:49:
 
         for attr_name in element.attributes.keys() {
             // Check if this is a presentation attribute that is NOT inheritable
[31m-            if PRESENTATION_ATTRS.contains(attr_name.as_str()) 
(B[m[31m-                && !INHERITABLE_ATTRS.contains(attr_name.as_str()) {
(B[m[32m+            if PRESENTATION_ATTRS.contains(attr_name.as_str())
(B[m[32m+                && !INHERITABLE_ATTRS.contains(attr_name.as_str())
(B[m[32m+            {
(B[m                 attrs_to_remove.push(attr_name.clone());
             }
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:67:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document() -> Document {
         Document {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:99:
     fn test_plugin_name_and_description() {
         let plugin = RemoveNonInheritableGroupAttrsPlugin;
         assert_eq!(plugin.name(), "removeNonInheritableGroupAttrs");
[31m-        assert_eq!(plugin.description(), "removes non-inheritable group's presentation attributes");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes non-inheritable group's presentation attributes"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:106:
     fn test_remove_non_inheritable_attrs() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Create a group with both inheritable and non-inheritable presentation attributes
         let group = create_group_with_attrs(vec![
             // Non-inheritable presentation attributes (should be removed)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:123:
             ("id", "myGroup"),
             ("class", "important"),
         ]);
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![Node::Element(group)];
 
         let mut plugin = RemoveNonInheritableGroupAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:138:
             assert!(!elem.attributes.contains_key("filter"));
             assert!(!elem.attributes.contains_key("opacity"));
             assert!(!elem.attributes.contains_key("overflow"));
[31m-            
(B[m[32m+
(B[m             // Inheritable should be kept
             assert_eq!(elem.attributes.get("fill"), Some(&"red".to_string()));
             assert_eq!(elem.attributes.get("stroke"), Some(&"blue".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:145:
             assert_eq!(elem.attributes.get("font-size"), Some(&"14px".to_string()));
[31m-            assert_eq!(elem.attributes.get("transform"), Some(&"translate(10,10)".to_string()));
(B[m[31m-            
(B[m[32m+            assert_eq!(
(B[m[32m+                elem.attributes.get("transform"),
(B[m[32m+                Some(&"translate(10,10)".to_string())
(B[m[32m+            );
(B[m[32m+
(B[m             // Non-presentation should be kept
             assert_eq!(elem.attributes.get("id"), Some(&"myGroup".to_string()));
             assert_eq!(elem.attributes.get("class"), Some(&"important".to_string()));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:156:
     #[test]
     fn test_nested_groups() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Create nested groups with non-inheritable attrs
[31m-        let inner_group = create_group_with_attrs(vec![
(B[m[31m-            ("opacity", "0.8"),
(B[m[31m-            ("fill", "green"),
(B[m[31m-        ]);
(B[m[31m-        
(B[m[31m-        let mut outer_group = create_group_with_attrs(vec![
(B[m[31m-            ("filter", "url(#blur)"),
(B[m[31m-            ("stroke", "black"),
(B[m[31m-        ]);
(B[m[32m+        let inner_group = create_group_with_attrs(vec![("opacity", "0.8"), ("fill", "green")]);
(B[m[32m+
(B[m[32m+        let mut outer_group =
(B[m[32m+            create_group_with_attrs(vec![("filter", "url(#blur)"), ("stroke", "black")]);
(B[m         outer_group.children = vec![Node::Element(inner_group)];
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![Node::Element(outer_group)];
 
         let mut plugin = RemoveNonInheritableGroupAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:179:
         if let Node::Element(outer) = &document.root.children[0] {
             assert!(!outer.attributes.contains_key("filter"));
             assert_eq!(outer.attributes.get("stroke"), Some(&"black".to_string()));
[31m-            
(B[m[32m+
(B[m             // Check inner group
             if let Node::Element(inner) = &outer.children[0] {
                 assert!(!inner.attributes.contains_key("opacity"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:195:
     #[test]
     fn test_only_affects_groups() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Create a rect with non-inheritable attrs (should not be affected)
         let mut rect_attrs = IndexMap::new();
         rect_attrs.insert("opacity".to_string(), "0.5".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:203:
         rect_attrs.insert("fill".to_string(), "red".to_string());
         rect_attrs.insert("width".to_string(), "100".to_string());
         rect_attrs.insert("height".to_string(), "100".to_string());
[31m-        
(B[m[32m+
(B[m         let rect = Element {
             name: "rect".to_string(),
             attributes: rect_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:210:
             namespaces: HashMap::new(),
             children: vec![],
         };
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![Node::Element(rect)];
 
         let mut plugin = RemoveNonInheritableGroupAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:220:
         // Rect should keep all attributes since plugin only affects groups
         if let Node::Element(elem) = &document.root.children[0] {
             assert_eq!(elem.attributes.get("opacity"), Some(&"0.5".to_string()));
[31m-            assert_eq!(elem.attributes.get("filter"), Some(&"url(#blur)".to_string()));
(B[m[32m+            assert_eq!(
(B[m[32m+                elem.attributes.get("filter"),
(B[m[32m+                Some(&"url(#blur)".to_string())
(B[m[32m+            );
(B[m             assert_eq!(elem.attributes.get("fill"), Some(&"red".to_string()));
             assert_eq!(elem.attributes.len(), 5);
         } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:231:
     #[test]
     fn test_empty_group() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Create an empty group with non-inheritable attrs
[31m-        let group = create_group_with_attrs(vec![
(B[m[31m-            ("mask", "url(#mask)"),
(B[m[31m-            ("id", "emptyGroup"),
(B[m[31m-        ]);
(B[m[31m-        
(B[m[32m+        let group = create_group_with_attrs(vec![("mask", "url(#mask)"), ("id", "emptyGroup")]);
(B[m[32m+
(B[m         document.root.children = vec![Node::Element(group)];
 
         let mut plugin = RemoveNonInheritableGroupAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:255:
     #[test]
     fn test_all_non_inheritable_attrs() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Create a group with various non-inheritable presentation attributes
         let group = create_group_with_attrs(vec![
             ("alignment-baseline", "middle"),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:277:
             // Add one inheritable to verify it's kept
             ("fill", "red"),
         ]);
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![Node::Element(group)];
 
         let mut plugin = RemoveNonInheritableGroupAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:302:
             assert!(!elem.attributes.contains_key("stop-opacity"));
             assert!(!elem.attributes.contains_key("text-decoration"));
             assert!(!elem.attributes.contains_key("unicode-bidi"));
[31m-            
(B[m[32m+
(B[m             // Inheritable should be kept
             assert_eq!(elem.attributes.get("fill"), Some(&"red".to_string()));
             assert_eq!(elem.attributes.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_non_inheritable_group_attrs.rs:311:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:29:
         "removes elements that are drawn outside of the viewBox (disabled by default)"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // First, find the viewBox from the root SVG element
         if let Some(viewbox) = self.get_viewbox(&document.root) {
             self.process_element(&mut document.root, &viewbox);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:70:
                 if self.is_outside_viewbox(child_elem, viewbox) {
                     return false; // Remove this element
                 }
[31m-                
(B[m[32m+
(B[m                 // Recursively process children
                 self.process_element(child_elem, viewbox);
                 true
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:99:
         let height = self.get_numeric_attr(element, "height").unwrap_or(0.0);
 
         // Check if rect is completely outside viewBox
[31m-        x + width < viewbox.x || 
(B[m[31m-        x > viewbox.x + viewbox.width ||
(B[m[31m-        y + height < viewbox.y || 
(B[m[31m-        y > viewbox.y + viewbox.height
(B[m[32m+        x + width < viewbox.x
(B[m[32m+            || x > viewbox.x + viewbox.width
(B[m[32m+            || y + height < viewbox.y
(B[m[32m+            || y > viewbox.y + viewbox.height
(B[m     }
 
     fn is_circle_outside(&self, element: &Element, viewbox: &ViewBox) -> bool {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:111:
         let r = self.get_numeric_attr(element, "r").unwrap_or(0.0);
 
         // Check if circle is completely outside viewBox
[31m-        cx + r < viewbox.x || 
(B[m[31m-        cx - r > viewbox.x + viewbox.width ||
(B[m[31m-        cy + r < viewbox.y || 
(B[m[31m-        cy - r > viewbox.y + viewbox.height
(B[m[32m+        cx + r < viewbox.x
(B[m[32m+            || cx - r > viewbox.x + viewbox.width
(B[m[32m+            || cy + r < viewbox.y
(B[m[32m+            || cy - r > viewbox.y + viewbox.height
(B[m     }
 
     fn is_ellipse_outside(&self, element: &Element, viewbox: &ViewBox) -> bool {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:124:
         let ry = self.get_numeric_attr(element, "ry").unwrap_or(0.0);
 
         // Check if ellipse is completely outside viewBox
[31m-        cx + rx < viewbox.x || 
(B[m[31m-        cx - rx > viewbox.x + viewbox.width ||
(B[m[31m-        cy + ry < viewbox.y || 
(B[m[31m-        cy - ry > viewbox.y + viewbox.height
(B[m[32m+        cx + rx < viewbox.x
(B[m[32m+            || cx - rx > viewbox.x + viewbox.width
(B[m[32m+            || cy + ry < viewbox.y
(B[m[32m+            || cy - ry > viewbox.y + viewbox.height
(B[m     }
 
     fn is_line_outside(&self, element: &Element, viewbox: &ViewBox) -> bool {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:137:
         let y2 = self.get_numeric_attr(element, "y2").unwrap_or(0.0);
 
         // Check if both endpoints are outside the same edge of viewBox
[31m-        (x1 < viewbox.x && x2 < viewbox.x) ||
(B[m[31m-        (x1 > viewbox.x + viewbox.width && x2 > viewbox.x + viewbox.width) ||
(B[m[31m-        (y1 < viewbox.y && y2 < viewbox.y) ||
(B[m[31m-        (y1 > viewbox.y + viewbox.height && y2 > viewbox.y + viewbox.height)
(B[m[32m+        (x1 < viewbox.x && x2 < viewbox.x)
(B[m[32m+            || (x1 > viewbox.x + viewbox.width && x2 > viewbox.x + viewbox.width)
(B[m[32m+            || (y1 < viewbox.y && y2 < viewbox.y)
(B[m[32m+            || (y1 > viewbox.y + viewbox.height && y2 > viewbox.y + viewbox.height)
(B[m     }
 
     fn is_polygon_outside(&self, element: &Element, viewbox: &ViewBox) -> bool {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:168:
             // This is a simplified check - a full implementation would parse the path
             let bounds = self.get_path_bounds(d);
             if let Some((min_x, min_y, max_x, max_y)) = bounds {
[31m-                max_x < viewbox.x || 
(B[m[31m-                min_x > viewbox.x + viewbox.width ||
(B[m[31m-                max_y < viewbox.y || 
(B[m[31m-                min_y > viewbox.y + viewbox.height
(B[m[32m+                max_x < viewbox.x
(B[m[32m+                    || min_x > viewbox.x + viewbox.width
(B[m[32m+                    || max_y < viewbox.y
(B[m[32m+                    || min_y > viewbox.y + viewbox.height
(B[m             } else {
                 false
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:241:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document_with_viewbox(viewbox: &str) -> Document {
         let mut root_attrs = IndexMap::new();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:249:
         root_attrs.insert("viewBox".to_string(), viewbox.to_string());
[31m-        
(B[m[32m+
(B[m         Document {
             root: Element {
                 name: "svg".to_string(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:276:
     fn test_plugin_name_and_description() {
         let plugin = RemoveOffCanvasPathsPlugin;
         assert_eq!(plugin.name(), "removeOffCanvasPaths");
[31m-        assert_eq!(plugin.description(), "removes elements that are drawn outside of the viewBox (disabled by default)");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes elements that are drawn outside of the viewBox (disabled by default)"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:283:
     fn test_remove_rect_outside_viewbox() {
         let mut document = create_test_document_with_viewbox("0 0 100 100");
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             // Rect completely outside (left)
[31m-            Node::Element(create_element("rect", vec![("x", "-50"), ("y", "10"), ("width", "40"), ("height", "40")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("x", "-50"), ("y", "10"), ("width", "40"), ("height", "40")],
(B[m[32m+            )),
(B[m             // Rect completely outside (right)
[31m-            Node::Element(create_element("rect", vec![("x", "110"), ("y", "10"), ("width", "40"), ("height", "40")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("x", "110"), ("y", "10"), ("width", "40"), ("height", "40")],
(B[m[32m+            )),
(B[m             // Rect inside viewBox
[31m-            Node::Element(create_element("rect", vec![("x", "10"), ("y", "10"), ("width", "40"), ("height", "40")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("x", "10"), ("y", "10"), ("width", "40"), ("height", "40")],
(B[m[32m+            )),
(B[m             // Rect partially outside (should keep)
[31m-            Node::Element(create_element("rect", vec![("x", "90"), ("y", "10"), ("width", "20"), ("height", "40")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("x", "90"), ("y", "10"), ("width", "20"), ("height", "40")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveOffCanvasPathsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:305:
     #[test]
     fn test_remove_circle_outside_viewbox() {
         let mut document = create_test_document_with_viewbox("0 0 100 100");
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             // Circle completely outside
[31m-            Node::Element(create_element("circle", vec![("cx", "-20"), ("cy", "50"), ("r", "10")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "circle",
(B[m[32m+                vec![("cx", "-20"), ("cy", "50"), ("r", "10")],
(B[m[32m+            )),
(B[m             // Circle inside
[31m-            Node::Element(create_element("circle", vec![("cx", "50"), ("cy", "50"), ("r", "30")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "circle",
(B[m[32m+                vec![("cx", "50"), ("cy", "50"), ("r", "30")],
(B[m[32m+            )),
(B[m             // Circle touching edge (should keep)
[31m-            Node::Element(create_element("circle", vec![("cx", "95"), ("cy", "50"), ("r", "10")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "circle",
(B[m[32m+                vec![("cx", "95"), ("cy", "50"), ("r", "10")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveOffCanvasPathsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:325:
     #[test]
     fn test_remove_line_outside_viewbox() {
         let mut document = create_test_document_with_viewbox("0 0 100 100");
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             // Line completely outside (both points left)
[31m-            Node::Element(create_element("line", vec![("x1", "-20"), ("y1", "10"), ("x2", "-10"), ("y2", "20")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "line",
(B[m[32m+                vec![("x1", "-20"), ("y1", "10"), ("x2", "-10"), ("y2", "20")],
(B[m[32m+            )),
(B[m             // Line crossing viewBox (should keep)
[31m-            Node::Element(create_element("line", vec![("x1", "-10"), ("y1", "50"), ("x2", "110"), ("y2", "50")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "line",
(B[m[32m+                vec![("x1", "-10"), ("y1", "50"), ("x2", "110"), ("y2", "50")],
(B[m[32m+            )),
(B[m             // Line inside
[31m-            Node::Element(create_element("line", vec![("x1", "10"), ("y1", "10"), ("x2", "90"), ("y2", "90")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "line",
(B[m[32m+                vec![("x1", "10"), ("y1", "10"), ("x2", "90"), ("y2", "90")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveOffCanvasPathsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:345:
     #[test]
     fn test_remove_polygon_outside_viewbox() {
         let mut document = create_test_document_with_viewbox("0 0 100 100");
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             // Polygon completely outside
[31m-            Node::Element(create_element("polygon", vec![("points", "110,10 120,20 115,30")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "polygon",
(B[m[32m+                vec![("points", "110,10 120,20 115,30")],
(B[m[32m+            )),
(B[m             // Polygon inside
[31m-            Node::Element(create_element("polygon", vec![("points", "10,10 50,10 30,50")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "polygon",
(B[m[32m+                vec![("points", "10,10 50,10 30,50")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveOffCanvasPathsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:371:
             },
             ..Default::default()
         };
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
[31m-            Node::Element(create_element("rect", vec![("x", "-50"), ("y", "10"), ("width", "40"), ("height", "40")])),
(B[m[31m-            Node::Element(create_element("circle", vec![("cx", "1000"), ("cy", "1000"), ("r", "50")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("x", "-50"), ("y", "10"), ("width", "40"), ("height", "40")],
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "circle",
(B[m[32m+                vec![("cx", "1000"), ("cy", "1000"), ("r", "50")],
(B[m[32m+            )),
(B[m         ];
 
         let initial_count = document.root.children.len();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:381:
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveOffCanvasPathsPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), None);
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:390:
     #[test]
     fn test_nested_elements() {
         let mut document = create_test_document_with_viewbox("0 0 100 100");
[31m-        
(B[m[32m+
(B[m         let group = Element {
             name: "g".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:397:
             namespaces: HashMap::new(),
             children: vec![
                 // Rect outside
[31m-                Node::Element(create_element("rect", vec![("x", "-50"), ("y", "10"), ("width", "40"), ("height", "40")])),
(B[m[32m+                Node::Element(create_element(
(B[m[32m+                    "rect",
(B[m[32m+                    vec![("x", "-50"), ("y", "10"), ("width", "40"), ("height", "40")],
(B[m[32m+                )),
(B[m                 // Rect inside
[31m-                Node::Element(create_element("rect", vec![("x", "10"), ("y", "10"), ("width", "40"), ("height", "40")])),
(B[m[32m+                Node::Element(create_element(
(B[m[32m+                    "rect",
(B[m[32m+                    vec![("x", "10"), ("y", "10"), ("width", "40"), ("height", "40")],
(B[m[32m+                )),
(B[m             ],
         };
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![Node::Element(group)];
 
         let mut plugin = RemoveOffCanvasPathsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:418:
     #[test]
     fn test_viewbox_with_offset() {
         let mut document = create_test_document_with_viewbox("50 50 100 100");
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             // Rect outside the offset viewBox
[31m-            Node::Element(create_element("rect", vec![("x", "0"), ("y", "0"), ("width", "40"), ("height", "40")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("x", "0"), ("y", "0"), ("width", "40"), ("height", "40")],
(B[m[32m+            )),
(B[m             // Rect inside the offset viewBox
[31m-            Node::Element(create_element("rect", vec![("x", "60"), ("y", "60"), ("width", "40"), ("height", "40")])),
(B[m[32m+            Node::Element(create_element(
(B[m[32m+                "rect",
(B[m[32m+                vec![("x", "60"), ("y", "60"), ("width", "40"), ("height", "40")],
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveOffCanvasPathsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_off_canvas_paths.rs:436:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:7:
 
 use crate::ast::{Document, Element, Node};
 use crate::plugin::{Plugin, PluginInfo, PluginResult};
[31m-use serde_json::Value;
(B[m[31m-use regex::Regex;
(B[m use once_cell::sync::Lazy;
[32m+use regex::Regex;
(B[m[32m+use serde_json::Value;
(B[m 
 /// Regex to detect raster image references
[31m-static RASTER_IMAGE_REGEX: Lazy<Regex> = Lazy::new(|| {
(B[m[31m-    Regex::new(r"(\.|image/)(jpe?g|png|gif)").unwrap()
(B[m[31m-});
(B[m[32m+static RASTER_IMAGE_REGEX: Lazy<Regex> =
(B[m[32m+    Lazy::new(|| Regex::new(r"(\.|image/)(jpe?g|png|gif)").unwrap());
(B[m 
 /// Plugin to remove raster image references (disabled by default)
 pub struct RemoveRasterImagesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:28:
         "removes raster images (disabled by default)"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         self.process_element(&mut document.root);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:76:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document() -> Document {
         Document {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:96:
         attributes.insert(href_attr.to_string(), href_value.to_string());
         attributes.insert("width".to_string(), "100".to_string());
         attributes.insert("height".to_string(), "100".to_string());
[31m-        
(B[m[32m+
(B[m         Element {
             name: "image".to_string(),
             attributes,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:109:
     fn test_plugin_name_and_description() {
         let plugin = RemoveRasterImagesPlugin;
         assert_eq!(plugin.name(), "removeRasterImages");
[31m-        assert_eq!(plugin.description(), "removes raster images (disabled by default)");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes raster images (disabled by default)"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:116:
     fn test_remove_jpeg_image() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             Node::Element(create_image_element("xlink:href", "photo.jpg")),
             Node::Element(create_image_element("xlink:href", "image.jpeg")),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:132:
     #[test]
     fn test_remove_png_image() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             Node::Element(create_image_element("xlink:href", "icon.png")),
             Node::Element(create_image_element("href", "logo.png")),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:149:
     #[test]
     fn test_remove_gif_image() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.children = vec![
(B[m[31m-            Node::Element(create_image_element("xlink:href", "animation.gif")),
(B[m[31m-        ];
(B[m 
[32m+        document.root.children = vec![Node::Element(create_image_element(
(B[m[32m+            "xlink:href",
(B[m[32m+            "animation.gif",
(B[m[32m+        ))];
(B[m[32m+
(B[m         let mut plugin = RemoveRasterImagesPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:165:
     #[test]
     fn test_remove_data_uri_images() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
[31m-            Node::Element(create_image_element("xlink:href", "data:image/jpeg;base64,/9j/4AAQ...")),
(B[m[31m-            Node::Element(create_image_element("href", "data:image/png;base64,iVBORw0KGgo...")),
(B[m[32m+            Node::Element(create_image_element(
(B[m[32m+                "xlink:href",
(B[m[32m+                "data:image/jpeg;base64,/9j/4AAQ...",
(B[m[32m+            )),
(B[m[32m+            Node::Element(create_image_element(
(B[m[32m+                "href",
(B[m[32m+                "data:image/png;base64,iVBORw0KGgo...",
(B[m[32m+            )),
(B[m         ];
 
         let mut plugin = RemoveRasterImagesPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:182:
     #[test]
     fn test_preserve_svg_images() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             Node::Element(create_image_element("xlink:href", "icon.svg")),
             Node::Element(create_image_element("href", "#symbol1")),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:200:
     #[test]
     fn test_preserve_non_image_elements() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let mut rect_attrs = IndexMap::new();
         rect_attrs.insert("xlink:href".to_string(), "photo.jpg".to_string());
[31m-        
(B[m[32m+
(B[m         let rect_element = Element {
             name: "rect".to_string(),
             attributes: rect_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:227:
     #[test]
     fn test_case_sensitivity() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             Node::Element(create_image_element("xlink:href", "photo.JPG")),
             Node::Element(create_image_element("xlink:href", "image.JPEG")),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:246:
     #[test]
     fn test_nested_images() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let g_element = Element {
             name: "g".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:280:
     #[test]
     fn test_url_with_path() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         document.root.children = vec![
             Node::Element(create_image_element("xlink:href", "/images/photo.jpg")),
[31m-            Node::Element(create_image_element("href", "https://example.com/image.png")),
(B[m[32m+            Node::Element(create_image_element(
(B[m[32m+                "href",
(B[m[32m+                "https://example.com/image.png",
(B[m[32m+            )),
(B[m             Node::Element(create_image_element("xlink:href", "../assets/banner.gif")),
         ];
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_raster_images.rs:295:
         assert_eq!(document.root.children.len(), 0);
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:7:
 
 use crate::ast::{Document, Element, Node};
 use crate::collections::{
[31m-    ANIMATION_EVENT_ATTRS, DOCUMENT_EVENT_ATTRS, DOCUMENT_ELEMENT_EVENT_ATTRS,
(B[m[31m-    GLOBAL_EVENT_ATTRS, GRAPHICAL_EVENT_ATTRS,
(B[m[32m+    ANIMATION_EVENT_ATTRS, DOCUMENT_ELEMENT_EVENT_ATTRS, DOCUMENT_EVENT_ATTRS, GLOBAL_EVENT_ATTRS,
(B[m[32m+    GRAPHICAL_EVENT_ATTRS,
(B[m };
 use crate::plugin::{Plugin, PluginInfo, PluginResult};
[31m-use std::collections::HashMap;
(B[m use indexmap::IndexMap;
 use serde_json::Value;
[32m+use std::collections::HashMap;
(B[m 
 /// Plugin to remove scripts and script-related attributes
 pub struct RemoveScriptsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:27:
         "removes scripts (disabled by default)"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         self.process_element(&mut document.root);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:78:
 
     fn process_anchor_element(&self, element: &mut Element) {
         // Check for javascript: URLs in href attributes
[31m-        let has_javascript_url = element
(B[m[31m-            .attributes
(B[m[31m-            .iter()
(B[m[31m-            .any(|(attr, value)| {
(B[m[31m-                (attr == "href" || attr.ends_with(":href"))
(B[m[31m-                    && value.trim_start().starts_with("javascript:")
(B[m[31m-            });
(B[m[32m+        let has_javascript_url = element.attributes.iter().any(|(attr, value)| {
(B[m[32m+            (attr == "href" || attr.ends_with(":href"))
(B[m[32m+                && value.trim_start().starts_with("javascript:")
(B[m[32m+        });
(B[m 
         if has_javascript_url {
             // Replace the anchor element with its non-text children
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:107:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document() -> Document {
         Document {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:126:
     fn test_plugin_name_and_description() {
         let plugin = RemoveScriptsPlugin;
         assert_eq!(plugin.name(), "removeScripts");
[31m-        assert_eq!(plugin.description(), "removes scripts (disabled by default)");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes scripts (disabled by default)"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:133:
     fn test_remove_script_elements() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let script_element = Element {
             name: "script".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:168:
     #[test]
     fn test_remove_event_attributes() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let mut attributes = IndexMap::new();
         attributes.insert("onclick".to_string(), "alert('click')".to_string());
         attributes.insert("onload".to_string(), "doSomething()".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:201:
     #[test]
     fn test_javascript_url_in_anchor() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let mut attributes = IndexMap::new();
         attributes.insert("href".to_string(), "javascript:alert('test')".to_string());
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:245:
     #[test]
     fn test_normal_anchor_preserved() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let mut attributes = IndexMap::new();
         attributes.insert("href".to_string(), "https://example.com".to_string());
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:276:
     #[test]
     fn test_xlink_href_with_javascript() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let mut attributes = IndexMap::new();
         attributes.insert("xlink:href".to_string(), "javascript:void(0)".to_string());
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_scripts.rs:311:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs:5:
 //! This plugin removes all `<style>` elements from the SVG document.
 //! It's useful when you want to completely strip CSS styling from SVGs.
 
[31m-use crate::ast::{Document, Node, Element};
(B[m[31m-use crate::plugin::{Plugin, PluginResult, PluginInfo};
(B[m[32m+use crate::ast::{Document, Element, Node};
(B[m[32m+use crate::plugin::{Plugin, PluginInfo, PluginResult};
(B[m use serde_json::Value;
 
 /// Plugin that removes all `<style>` elements from the SVG
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs:16:
     fn name(&self) -> &'static str {
         "removeStyleElement"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Remove all <style> elements from SVG document"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs:23:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Remove style elements from the main document tree
         remove_style_elements(&mut document.root);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs:39:
             true
         }
     });
[31m-    
(B[m[32m+
(B[m     // Recursively process child elements
     for child in &mut element.children {
         if let Node::Element(ref mut elem) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs:53:
 mod tests {
     use super::*;
     use crate::parser::Parser;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_style_elements() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs:64:
                 <circle class="cls-2" r="5"/>
             </g>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveStyleElement;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         plugin.apply(&mut document, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // Check that style elements are removed
         assert!(!contains_style_element(&document.root));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs:78:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_multiple_style_elements() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs:84:
             <rect/>
             <style>/* Third style */</style>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveStyleElement;
[31m-        let plugin_info = PluginInfo { path: None, multipass_count: 0 };
(B[m[32m+        let plugin_info = PluginInfo {
(B[m[32m+            path: None,
(B[m[32m+            multipass_count: 0,
(B[m[32m+        };
(B[m         plugin.apply(&mut document, &plugin_info, None).unwrap();
[31m-        
(B[m[32m+
(B[m         // Check that all style elements are removed
         assert!(!contains_style_element(&document.root));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs:98:
[31m-    
(B[m[32m+
(B[m     fn contains_style_element(element: &Element) -> bool {
         for child in &element.children {
             match child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_style_element.rs:113:
         false
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_title.rs:15:
     fn name(&self) -> &'static str {
         "removeTitle"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Remove <title> elements from SVG document"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_title.rs:22:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Remove title elements from the document
         remove_title_from_node(&mut document.root);
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_title.rs:37:
             true
         }
     });
[31m-    
(B[m[32m+
(B[m     // Clean up whitespace-only text nodes if element now only has element children
     let has_element_children = node.children.iter().any(|c| c.is_element());
[31m-    let has_meaningful_text = node.children.iter().any(|c| {
(B[m[31m-        matches!(c, Node::Text(text) if !text.trim().is_empty())
(B[m[31m-    });
(B[m[31m-    
(B[m[32m+    let has_meaningful_text = node
(B[m[32m+        .children
(B[m[32m+        .iter()
(B[m[32m+        .any(|c| matches!(c, Node::Text(text) if !text.trim().is_empty()));
(B[m[32m+
(B[m     if has_element_children && !has_meaningful_text {
         // Remove whitespace-only text nodes
[31m-        node.children.retain(|child| {
(B[m[31m-            !matches!(child, Node::Text(text) if text.trim().is_empty())
(B[m[31m-        });
(B[m[32m+        node.children
(B[m[32m+            .retain(|child| !matches!(child, Node::Text(text) if text.trim().is_empty()));
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Recursively process child elements
     for child in &mut node.children {
         if let Node::Element(element) = child {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_title.rs:65:
     use super::*;
     use crate::ast::Element;
     use crate::parser::Parser;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_title() {
         let svg = r#"<svg>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_title.rs:75:
                 <rect/>
             </g>
         </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveTitlePlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Check that title elements are removed
         assert!(!has_title(&document.root));
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_title.rs:88:
[31m-    
(B[m[32m+
(B[m     fn has_title(element: &Element) -> bool {
         if element.name == "title" {
             return true;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_title.rs:92:
         }
[31m-        
(B[m[32m+
(B[m         for child in &element.children {
             if let Node::Element(el) = child {
                 if has_title(el) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_title.rs:101:
         false
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:54:
     /// Parse parameters from JSON value
     pub fn from_value(value: Option<&Value>) -> Self {
         let mut params = Self::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(map)) = value {
             if let Some(Value::Bool(val)) = map.get("unknownContent") {
                 params.unknown_content = *val;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:81:
                 params.keep_role_attr = *val;
             }
         }
[31m-        
(B[m[32m+
(B[m         params
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:92:
         // Root
         "svg",
         // Structural
[31m-        "defs", "g", "symbol", "use",
(B[m[32m+        "defs",
(B[m[32m+        "g",
(B[m[32m+        "symbol",
(B[m[32m+        "use",
(B[m         // Shape elements
[31m-        "circle", "ellipse", "line", "path", "polygon", "polyline", "rect",
(B[m[32m+        "circle",
(B[m[32m+        "ellipse",
(B[m[32m+        "line",
(B[m[32m+        "path",
(B[m[32m+        "polygon",
(B[m[32m+        "polyline",
(B[m[32m+        "rect",
(B[m         // Text elements
[31m-        "text", "tspan", "tref", "textPath",
(B[m[32m+        "text",
(B[m[32m+        "tspan",
(B[m[32m+        "tref",
(B[m[32m+        "textPath",
(B[m         // Paint server elements
[31m-        "linearGradient", "radialGradient", "pattern",
(B[m[32m+        "linearGradient",
(B[m[32m+        "radialGradient",
(B[m[32m+        "pattern",
(B[m         // Container elements
[31m-        "a", "marker", "mask", "clipPath", "foreignObject", "switch",
(B[m[32m+        "a",
(B[m[32m+        "marker",
(B[m[32m+        "mask",
(B[m[32m+        "clipPath",
(B[m[32m+        "foreignObject",
(B[m[32m+        "switch",
(B[m         // Filter elements
[31m-        "filter", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite",
(B[m[31m-        "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feFlood",
(B[m[31m-        "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology",
(B[m[31m-        "feOffset", "feSpecularLighting", "feTile", "feTurbulence",
(B[m[32m+        "filter",
(B[m[32m+        "feBlend",
(B[m[32m+        "feColorMatrix",
(B[m[32m+        "feComponentTransfer",
(B[m[32m+        "feComposite",
(B[m[32m+        "feConvolveMatrix",
(B[m[32m+        "feDiffuseLighting",
(B[m[32m+        "feDisplacementMap",
(B[m[32m+        "feFlood",
(B[m[32m+        "feGaussianBlur",
(B[m[32m+        "feImage",
(B[m[32m+        "feMerge",
(B[m[32m+        "feMergeNode",
(B[m[32m+        "feMorphology",
(B[m[32m+        "feOffset",
(B[m[32m+        "feSpecularLighting",
(B[m[32m+        "feTile",
(B[m[32m+        "feTurbulence",
(B[m         // Animation elements
[31m-        "animate", "animateTransform", "animateMotion", "set",
(B[m[32m+        "animate",
(B[m[32m+        "animateTransform",
(B[m[32m+        "animateMotion",
(B[m[32m+        "set",
(B[m         // Descriptive elements
[31m-        "desc", "title", "metadata",
(B[m[32m+        "desc",
(B[m[32m+        "title",
(B[m[32m+        "metadata",
(B[m         // Other elements
[31m-        "image", "stop", "script", "style",
(B[m[31m-    ].into_iter().collect()
(B[m[32m+        "image",
(B[m[32m+        "stop",
(B[m[32m+        "script",
(B[m[32m+        "style",
(B[m[32m+    ]
(B[m[32m+    .into_iter()
(B[m[32m+    .collect()
(B[m });
 
 // Common SVG attributes (simplified list)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:119:
 static KNOWN_ATTRIBUTES: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {
     [
         // Core attributes
[31m-        "id", "class", "style", "lang", "tabindex",
(B[m[32m+        "id",
(B[m[32m+        "class",
(B[m[32m+        "style",
(B[m[32m+        "lang",
(B[m[32m+        "tabindex",
(B[m         // Geometry attributes
[31m-        "x", "y", "x1", "y1", "x2", "y2", "cx", "cy", "r", "rx", "ry",
(B[m[31m-        "width", "height", "viewBox", "d", "points", "pathLength",
(B[m[32m+        "x",
(B[m[32m+        "y",
(B[m[32m+        "x1",
(B[m[32m+        "y1",
(B[m[32m+        "x2",
(B[m[32m+        "y2",
(B[m[32m+        "cx",
(B[m[32m+        "cy",
(B[m[32m+        "r",
(B[m[32m+        "rx",
(B[m[32m+        "ry",
(B[m[32m+        "width",
(B[m[32m+        "height",
(B[m[32m+        "viewBox",
(B[m[32m+        "d",
(B[m[32m+        "points",
(B[m[32m+        "pathLength",
(B[m         // Presentation attributes
[31m-        "fill", "stroke", "stroke-width", "stroke-linecap", "stroke-linejoin",
(B[m[31m-        "stroke-dasharray", "stroke-dashoffset", "stroke-opacity", "fill-opacity",
(B[m[31m-        "opacity", "color", "font-family", "font-size", "font-weight", "text-anchor",
(B[m[31m-        "visibility", "display", "overflow", "clip", "clip-path", "clip-rule",
(B[m[31m-        "mask", "filter", "transform", "transform-origin",
(B[m[32m+        "fill",
(B[m[32m+        "stroke",
(B[m[32m+        "stroke-width",
(B[m[32m+        "stroke-linecap",
(B[m[32m+        "stroke-linejoin",
(B[m[32m+        "stroke-dasharray",
(B[m[32m+        "stroke-dashoffset",
(B[m[32m+        "stroke-opacity",
(B[m[32m+        "fill-opacity",
(B[m[32m+        "opacity",
(B[m[32m+        "color",
(B[m[32m+        "font-family",
(B[m[32m+        "font-size",
(B[m[32m+        "font-weight",
(B[m[32m+        "text-anchor",
(B[m[32m+        "visibility",
(B[m[32m+        "display",
(B[m[32m+        "overflow",
(B[m[32m+        "clip",
(B[m[32m+        "clip-path",
(B[m[32m+        "clip-rule",
(B[m[32m+        "mask",
(B[m[32m+        "filter",
(B[m[32m+        "transform",
(B[m[32m+        "transform-origin",
(B[m         // Animation attributes
[31m-        "begin", "dur", "end", "repeatCount", "repeatDur", "from", "to", "by", "values",
(B[m[31m-        "attributeName", "attributeType", "calcMode", "keyTimes", "keySplines",
(B[m[32m+        "begin",
(B[m[32m+        "dur",
(B[m[32m+        "end",
(B[m[32m+        "repeatCount",
(B[m[32m+        "repeatDur",
(B[m[32m+        "from",
(B[m[32m+        "to",
(B[m[32m+        "by",
(B[m[32m+        "values",
(B[m[32m+        "attributeName",
(B[m[32m+        "attributeType",
(B[m[32m+        "calcMode",
(B[m[32m+        "keyTimes",
(B[m[32m+        "keySplines",
(B[m         // Link attributes
[31m-        "href", "target",
(B[m[32m+        "href",
(B[m[32m+        "target",
(B[m         // Gradient attributes
[31m-        "gradientUnits", "gradientTransform", "x1", "y1", "x2", "y2", "fx", "fy",
(B[m[31m-        "spreadMethod", "stop-color", "stop-opacity", "offset",
(B[m[32m+        "gradientUnits",
(B[m[32m+        "gradientTransform",
(B[m[32m+        "x1",
(B[m[32m+        "y1",
(B[m[32m+        "x2",
(B[m[32m+        "y2",
(B[m[32m+        "fx",
(B[m[32m+        "fy",
(B[m[32m+        "spreadMethod",
(B[m[32m+        "stop-color",
(B[m[32m+        "stop-opacity",
(B[m[32m+        "offset",
(B[m         // Pattern attributes
[31m-        "patternUnits", "patternContentUnits", "patternTransform",
(B[m[32m+        "patternUnits",
(B[m[32m+        "patternContentUnits",
(B[m[32m+        "patternTransform",
(B[m         // Filter attributes
[31m-        "filterUnits", "primitiveUnits", "result", "in", "in2",
(B[m[32m+        "filterUnits",
(B[m[32m+        "primitiveUnits",
(B[m[32m+        "result",
(B[m[32m+        "in",
(B[m[32m+        "in2",
(B[m         // Text attributes
[31m-        "text-rendering", "font-style", "font-variant", "text-decoration",
(B[m[31m-        "writing-mode", "glyph-orientation-vertical", "glyph-orientation-horizontal",
(B[m[32m+        "text-rendering",
(B[m[32m+        "font-style",
(B[m[32m+        "font-variant",
(B[m[32m+        "text-decoration",
(B[m[32m+        "writing-mode",
(B[m[32m+        "glyph-orientation-vertical",
(B[m[32m+        "glyph-orientation-horizontal",
(B[m         // Other common attributes
[31m-        "preserveAspectRatio", "version", "xmlns", "xmlns:xlink", "xml:space",
(B[m[31m-    ].into_iter().collect()
(B[m[32m+        "preserveAspectRatio",
(B[m[32m+        "version",
(B[m[32m+        "xmlns",
(B[m[32m+        "xmlns:xlink",
(B[m[32m+        "xml:space",
(B[m[32m+    ]
(B[m[32m+    .into_iter()
(B[m[32m+    .collect()
(B[m });
 
 // Default attribute values (simplified list)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:153:
[31m-static DEFAULT_ATTRIBUTE_VALUES: LazyLock<HashMap<&'static str, &'static str>> = LazyLock::new(|| {
(B[m[31m-    [
(B[m[31m-        ("x", "0"),
(B[m[31m-        ("y", "0"),
(B[m[31m-        ("fill", "#000000"),
(B[m[31m-        ("fill", "black"),
(B[m[31m-        ("stroke", "none"),
(B[m[31m-        ("stroke-width", "1"),
(B[m[31m-        ("stroke-linecap", "butt"),
(B[m[31m-        ("stroke-linejoin", "miter"),
(B[m[31m-        ("stroke-dasharray", "none"),
(B[m[31m-        ("stroke-dashoffset", "0"),
(B[m[31m-        ("stroke-opacity", "1"),
(B[m[31m-        ("fill-opacity", "1"),
(B[m[31m-        ("opacity", "1"),
(B[m[31m-        ("visibility", "visible"),
(B[m[31m-        ("display", "inline"),
(B[m[31m-        ("overflow", "visible"),
(B[m[31m-        ("clip-rule", "nonzero"),
(B[m[31m-        ("font-size", "medium"),
(B[m[31m-        ("font-weight", "normal"),
(B[m[31m-        ("font-style", "normal"),
(B[m[31m-        ("text-anchor", "start"),
(B[m[31m-        ("text-decoration", "none"),
(B[m[31m-        ("preserveAspectRatio", "xMidYMid meet"),
(B[m[31m-        ("gradientUnits", "objectBoundingBox"),
(B[m[31m-        ("spreadMethod", "pad"),
(B[m[31m-        ("patternUnits", "objectBoundingBox"),
(B[m[31m-        ("patternContentUnits", "userSpaceOnUse"),
(B[m[31m-        ("filterUnits", "objectBoundingBox"),
(B[m[31m-        ("primitiveUnits", "userSpaceOnUse"),
(B[m[31m-    ].into_iter().collect()
(B[m[31m-});
(B[m[32m+static DEFAULT_ATTRIBUTE_VALUES: LazyLock<HashMap<&'static str, &'static str>> =
(B[m[32m+    LazyLock::new(|| {
(B[m[32m+        [
(B[m[32m+            ("x", "0"),
(B[m[32m+            ("y", "0"),
(B[m[32m+            ("fill", "#000000"),
(B[m[32m+            ("fill", "black"),
(B[m[32m+            ("stroke", "none"),
(B[m[32m+            ("stroke-width", "1"),
(B[m[32m+            ("stroke-linecap", "butt"),
(B[m[32m+            ("stroke-linejoin", "miter"),
(B[m[32m+            ("stroke-dasharray", "none"),
(B[m[32m+            ("stroke-dashoffset", "0"),
(B[m[32m+            ("stroke-opacity", "1"),
(B[m[32m+            ("fill-opacity", "1"),
(B[m[32m+            ("opacity", "1"),
(B[m[32m+            ("visibility", "visible"),
(B[m[32m+            ("display", "inline"),
(B[m[32m+            ("overflow", "visible"),
(B[m[32m+            ("clip-rule", "nonzero"),
(B[m[32m+            ("font-size", "medium"),
(B[m[32m+            ("font-weight", "normal"),
(B[m[32m+            ("font-style", "normal"),
(B[m[32m+            ("text-anchor", "start"),
(B[m[32m+            ("text-decoration", "none"),
(B[m[32m+            ("preserveAspectRatio", "xMidYMid meet"),
(B[m[32m+            ("gradientUnits", "objectBoundingBox"),
(B[m[32m+            ("spreadMethod", "pad"),
(B[m[32m+            ("patternUnits", "objectBoundingBox"),
(B[m[32m+            ("patternContentUnits", "userSpaceOnUse"),
(B[m[32m+            ("filterUnits", "objectBoundingBox"),
(B[m[32m+            ("primitiveUnits", "userSpaceOnUse"),
(B[m[32m+        ]
(B[m[32m+        .into_iter()
(B[m[32m+        .collect()
(B[m[32m+    });
(B[m 
 impl Plugin for RemoveUnknownsAndDefaultsPlugin {
     fn name(&self) -> &'static str {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:193:
         "removes unknown elements content and attributes, removes attrs with default values"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = RemoveUnknownsAndDefaultsParams::from_value(params);
[31m-        
(B[m[32m+
(B[m         // Process XML declaration if needed
         if config.default_markup_declarations {
             process_xml_declaration(&mut document.metadata);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:202:
         }
[31m-        
(B[m[32m+
(B[m         visit_elements(&mut document.root, &config, None);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:210:
 fn process_xml_declaration(metadata: &mut crate::ast::DocumentMetadata) {
     // Remove standalone="no" from version string if present
     if let Some(version) = &metadata.version {
[31m-        let cleaned = version.replace(" standalone=\"no\"", "").replace(" standalone='no'", "");
(B[m[32m+        let cleaned = version
(B[m[32m+            .replace(" standalone=\"no\"", "")
(B[m[32m+            .replace(" standalone='no'", "");
(B[m         if cleaned != *version {
             metadata.version = Some(cleaned);
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:219:
 
 /// Visit all elements in the AST and remove unknowns and defaults
 fn visit_elements(
[31m-    element: &mut Element, 
(B[m[31m-    config: &RemoveUnknownsAndDefaultsParams, 
(B[m[31m-    parent_element: Option<&Element>
(B[m[32m+    element: &mut Element,
(B[m[32m+    config: &RemoveUnknownsAndDefaultsParams,
(B[m[32m+    parent_element: Option<&Element>,
(B[m ) {
     remove_unknown_and_default_attributes(element, config, parent_element);
[31m-    
(B[m[32m+
(B[m     // First, collect indices of children to remove and process remaining children
     let mut children_to_remove = Vec::new();
     let mut child_elements_to_process = Vec::new();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:231:
[31m-    
(B[m[32m+
(B[m     for (index, child) in element.children.iter().enumerate() {
         if let Node::Element(child_element) = child {
             // Check if this element should be removed
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:240:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Remove unknown elements (in reverse order to maintain indices)
     for &index in children_to_remove.iter().rev() {
         element.children.remove(index);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:247:
     }
[31m-    
(B[m[32m+
(B[m     // Now process the remaining child elements
     for &index in &child_elements_to_process {
         if let Some(Node::Element(child_element)) = element.children.get_mut(index) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:252:
             // We need to collect parent attributes first to avoid borrowing issues
             let parent_attrs = element.attributes.clone();
             let parent_name = element.name.clone();
[31m-            
(B[m[32m+
(B[m             // Create a temporary parent element for reference
             let mut temp_parent = Element::new(&parent_name);
             temp_parent.attributes = parent_attrs;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:259:
[31m-            
(B[m[32m+
(B[m             visit_elements(child_element, config, Some(&temp_parent));
         }
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:268:
     if element.name.contains(':') {
         return false;
     }
[31m-    
(B[m[32m+
(B[m     // Check if it's a known SVG element
     !KNOWN_ELEMENTS.contains(element.name.as_str())
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:277:
 fn remove_unknown_and_default_attributes(
     element: &mut Element,
     config: &RemoveUnknownsAndDefaultsParams,
[31m-    parent_element: Option<&Element>
(B[m[32m+    parent_element: Option<&Element>,
(B[m ) {
     let mut attrs_to_remove = Vec::new();
[31m-    
(B[m[32m+
(B[m     for (attr_name, attr_value) in &element.attributes {
[31m-        let should_remove = should_remove_attribute(
(B[m[31m-            attr_name,
(B[m[31m-            attr_value,
(B[m[31m-            element,
(B[m[31m-            config,
(B[m[31m-            parent_element
(B[m[31m-        );
(B[m[31m-        
(B[m[32m+        let should_remove =
(B[m[32m+            should_remove_attribute(attr_name, attr_value, element, config, parent_element);
(B[m[32m+
(B[m         if should_remove {
             attrs_to_remove.push(attr_name.clone());
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:296:
     }
[31m-    
(B[m[32m+
(B[m     // Remove the attributes
     for attr_name in attrs_to_remove {
         element.attributes.shift_remove(&attr_name);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:307:
     attr_value: &str,
     element: &Element,
     config: &RemoveUnknownsAndDefaultsParams,
[31m-    parent_element: Option<&Element>
(B[m[32m+    parent_element: Option<&Element>,
(B[m ) -> bool {
     // Keep data-* attributes if configured
     if config.keep_data_attrs && attr_name.starts_with("data-") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:314:
         return false;
     }
[31m-    
(B[m[32m+
(B[m     // Keep aria-* attributes if configured
     if config.keep_aria_attrs && attr_name.starts_with("aria-") {
         return false;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:320:
     }
[31m-    
(B[m[32m+
(B[m     // Keep role attribute if configured
     if config.keep_role_attr && attr_name == "role" {
         return false;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:325:
     }
[31m-    
(B[m[32m+
(B[m     // Always keep xmlns
     if attr_name == "xmlns" {
         return false;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:330:
     }
[31m-    
(B[m[32m+
(B[m     // Keep namespaced attributes (xml:*, xlink:*)
     if attr_name.contains(':') {
         let prefix = attr_name.split(':').next().unwrap_or("");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:336:
             return false;
         }
     }
[31m-    
(B[m[32m+
(B[m     // Check for unknown attributes
     if config.unknown_attrs && !is_known_attribute(attr_name) {
         return true;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:343:
     }
[31m-    
(B[m[32m+
(B[m     // Check for default values (only if element doesn't have id)
     if config.default_attrs && !element.has_attr("id") && is_default_value(attr_name, attr_value) {
         return true;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:348:
     }
[31m-    
(B[m[32m+
(B[m     // Check for useless overrides (simplified - only if element doesn't have id)
     if config.useless_overrides && !element.has_attr("id") {
         if let Some(parent) = parent_element {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:357:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     false
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:386:
     fn test_removes_unknown_attributes() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        element.attributes.insert("unknown-attr".to_string(), "value".to_string());
(B[m[31m-        element.attributes.insert("height".to_string(), "50".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("unknown-attr".to_string(), "value".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveUnknownsAndDefaultsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:397:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         assert!(document.root.has_attr("width"));
         assert!(document.root.has_attr("height"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:405:
     fn test_removes_default_values() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[32m+
(B[m         element.attributes.insert("x".to_string(), "0".to_string());
         element.attributes.insert("y".to_string(), "0".to_string());
[31m-        element.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        element.attributes.insert("fill".to_string(), "black".to_string());
(B[m[31m-        
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "black".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveUnknownsAndDefaultsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:417:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         assert!(!document.root.has_attr("x")); // default value removed
         assert!(!document.root.has_attr("y")); // default value removed
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:426:
     fn test_preserves_data_attributes() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("data-test".to_string(), "value".to_string());
(B[m[31m-        element.attributes.insert("unknown-attr".to_string(), "value".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("data-test".to_string(), "value".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("unknown-attr".to_string(), "value".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveUnknownsAndDefaultsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:436:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         assert!(document.root.has_attr("data-test")); // preserved
         assert!(!document.root.has_attr("unknown-attr")); // removed
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:443:
     fn test_preserves_aria_attributes() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("aria-label".to_string(), "test".to_string());
(B[m[31m-        element.attributes.insert("unknown-attr".to_string(), "value".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("aria-label".to_string(), "test".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("unknown-attr".to_string(), "value".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveUnknownsAndDefaultsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:453:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         assert!(document.root.has_attr("aria-label")); // preserved
         assert!(!document.root.has_attr("unknown-attr")); // removed
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:460:
     fn test_role_attribute_handling() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("role".to_string(), "button".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("role".to_string(), "button".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         // Test with keepRoleAttr = false (default)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:469:
         let mut plugin = RemoveUnknownsAndDefaultsPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m         assert!(!document.root.has_attr("role")); // removed
 
         // Test with keepRoleAttr = true
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:474:
         let mut document2 = Document::new();
         let mut element2 = Element::new("rect");
[31m-        element2.attributes.insert("role".to_string(), "button".to_string());
(B[m[32m+        element2
(B[m[32m+            .attributes
(B[m[32m+            .insert("role".to_string(), "button".to_string());
(B[m         document2.root = element2;
 
         let params = json!({"keepRoleAttr": true});
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:480:
[31m-        plugin.apply(&mut document2, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document2,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m         assert!(document2.root.has_attr("role")); // preserved
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:485:
     fn test_preserves_namespaced_attributes() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("xml:space".to_string(), "preserve".to_string());
(B[m[31m-        element.attributes.insert("xlink:href".to_string(), "#test".to_string());
(B[m[31m-        element.attributes.insert("xmlns".to_string(), "http://www.w3.org/2000/svg".to_string());
(B[m[31m-        element.attributes.insert("unknown-attr".to_string(), "value".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("xml:space".to_string(), "preserve".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("xlink:href".to_string(), "#test".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "xmlns".to_string(),
(B[m[32m+            "http://www.w3.org/2000/svg".to_string(),
(B[m[32m+        );
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("unknown-attr".to_string(), "value".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveUnknownsAndDefaultsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:497:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         assert!(document.root.has_attr("xml:space")); // preserved
         assert!(document.root.has_attr("xlink:href")); // preserved
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:507:
         let mut document = Document::new();
         let known_child = Element::new("rect");
         let unknown_child = Element::new("unknown-element");
[31m-        
(B[m[32m+
(B[m         document.root.children.push(Node::Element(known_child));
         document.root.children.push(Node::Element(unknown_child));
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:514:
         let mut plugin = RemoveUnknownsAndDefaultsPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         assert_eq!(document.root.children.len(), 1);
         if let Node::Element(remaining_child) = &document.root.children[0] {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:524:
     fn test_preserves_id_elements_from_default_removal() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("id".to_string(), "test".to_string());
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("id".to_string(), "test".to_string());
(B[m         element.attributes.insert("x".to_string(), "0".to_string()); // default value
[31m-        element.attributes.insert("fill".to_string(), "black".to_string()); // default value
(B[m[31m-        
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "black".to_string()); // default value
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveUnknownsAndDefaultsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:535:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         assert!(document.root.has_attr("id"));
         assert!(document.root.has_attr("x")); // preserved because element has id
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:543:
     fn test_configuration_options() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("unknown-attr".to_string(), "value".to_string());
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("unknown-attr".to_string(), "value".to_string());
(B[m         element.attributes.insert("x".to_string(), "0".to_string());
[31m-        
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = RemoveUnknownsAndDefaultsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:554:
             "unknownAttrs": false,
             "defaultAttrs": false
         });
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         // Both should be preserved due to config
         assert!(document.root.has_attr("unknown-attr"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unknowns_and_defaults.rs:565:
     fn test_plugin_name_and_description() {
         let mut plugin = RemoveUnknownsAndDefaultsPlugin;
         assert_eq!(plugin.name(), "removeUnknownsAndDefaults");
[31m-        assert_eq!(plugin.description(), "removes unknown elements content and attributes, removes attrs with default values");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes unknown elements content and attributes, removes attrs with default values"
(B[m[32m+        );
(B[m     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:22:
         "removes unused namespaces declaration"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // First, collect all namespace declarations from the root SVG element
         let mut unused_namespaces = HashSet::new();
[31m-        
(B[m[32m+
(B[m         // Collect xmlns: attributes from root element
         for attr_name in document.root.attributes.keys() {
             if attr_name.starts_with("xmlns:") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:84:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document() -> Document {
         Document {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:103:
     fn test_plugin_name_and_description() {
         let plugin = RemoveUnusedNSPlugin;
         assert_eq!(plugin.name(), "removeUnusedNS");
[31m-        assert_eq!(plugin.description(), "removes unused namespaces declaration");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes unused namespaces declaration"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:110:
     fn test_remove_unused_namespace() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add unused namespace
[31m-        document.root.attributes.insert("xmlns:unused".to_string(), "http://example.com/unused".to_string());
(B[m[31m-        document.root.attributes.insert("xmlns:xlink".to_string(), "http://www.w3.org/1999/xlink".to_string());
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:unused".to_string(),
(B[m[32m+            "http://example.com/unused".to_string(),
(B[m[32m+        );
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:xlink".to_string(),
(B[m[32m+            "http://www.w3.org/1999/xlink".to_string(),
(B[m[32m+        );
(B[m 
         // Add an element that uses xlink
         let mut rect_attrs = IndexMap::new();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:119:
         rect_attrs.insert("xlink:href".to_string(), "#test".to_string());
[31m-        
(B[m[32m+
(B[m         let rect_element = Element {
             name: "rect".to_string(),
             attributes: rect_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:139:
     #[test]
     fn test_preserve_used_namespace_in_element_name() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add namespace
[31m-        document.root.attributes.insert("xmlns:svg".to_string(), "http://www.w3.org/2000/svg".to_string());
(B[m[31m-        
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:svg".to_string(),
(B[m[32m+            "http://www.w3.org/2000/svg".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         // Add a child element with namespaced name
         let ns_element = Element {
             name: "svg:g".to_string(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:164:
     #[test]
     fn test_preserve_used_namespace_in_attributes() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add namespace
[31m-        document.root.attributes.insert("xmlns:custom".to_string(), "http://example.com/custom".to_string());
(B[m[31m-        
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:custom".to_string(),
(B[m[32m+            "http://example.com/custom".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         // Add an element with namespaced attribute
         let mut element_attrs = IndexMap::new();
         element_attrs.insert("custom:data".to_string(), "value".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:174:
[31m-        
(B[m[32m+
(B[m         let element = Element {
             name: "rect".to_string(),
             attributes: element_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:192:
     #[test]
     fn test_remove_all_unused_namespaces() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add multiple unused namespaces
[31m-        document.root.attributes.insert("xmlns:ns1".to_string(), "http://example.com/ns1".to_string());
(B[m[31m-        document.root.attributes.insert("xmlns:ns2".to_string(), "http://example.com/ns2".to_string());
(B[m[31m-        document.root.attributes.insert("xmlns:ns3".to_string(), "http://example.com/ns3".to_string());
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:ns1".to_string(),
(B[m[32m+            "http://example.com/ns1".to_string(),
(B[m[32m+        );
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:ns2".to_string(),
(B[m[32m+            "http://example.com/ns2".to_string(),
(B[m[32m+        );
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:ns3".to_string(),
(B[m[32m+            "http://example.com/ns3".to_string(),
(B[m[32m+        );
(B[m 
         // Add an element without any namespace usage
         let element = Element {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:221:
     #[test]
     fn test_no_namespaces_to_remove() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // No xmlns: attributes
[31m-        document.root.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        document.root.attributes.insert("height".to_string(), "100".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "100".to_string());
(B[m 
         let mut plugin = RemoveUnusedNSPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:238:
     #[test]
     fn test_nested_element_namespace_usage() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add namespace
[31m-        document.root.attributes.insert("xmlns:deep".to_string(), "http://example.com/deep".to_string());
(B[m[31m-        
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:deep".to_string(),
(B[m[32m+            "http://example.com/deep".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         // Create nested structure where namespace is used deep in the tree
         let mut deep_attrs = IndexMap::new();
         deep_attrs.insert("deep:attr".to_string(), "value".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:248:
[31m-        
(B[m[32m+
(B[m         let deep_element = Element {
             name: "text".to_string(),
             attributes: deep_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:280:
     #[test]
     fn test_mixed_used_and_unused_namespaces() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add multiple namespaces
[31m-        document.root.attributes.insert("xmlns:used".to_string(), "http://example.com/used".to_string());
(B[m[31m-        document.root.attributes.insert("xmlns:unused".to_string(), "http://example.com/unused".to_string());
(B[m[31m-        document.root.attributes.insert("xmlns:alsounused".to_string(), "http://example.com/alsounused".to_string());
(B[m[31m-        
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:used".to_string(),
(B[m[32m+            "http://example.com/used".to_string(),
(B[m[32m+        );
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:unused".to_string(),
(B[m[32m+            "http://example.com/unused".to_string(),
(B[m[32m+        );
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:alsounused".to_string(),
(B[m[32m+            "http://example.com/alsounused".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         // Add an element that uses only one namespace
         let mut element_attrs = IndexMap::new();
         element_attrs.insert("used:data".to_string(), "value".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:292:
[31m-        
(B[m[32m+
(B[m         let element = Element {
             name: "rect".to_string(),
             attributes: element_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_unused_ns.rs:309:
         assert!(!document.root.attributes.contains_key("xmlns:alsounused"));
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:2:
 
 //! Plugin to remove useless elements in `<defs>` without id
 //!
[31m-//! This plugin removes content of defs and properties that aren't rendered 
(B[m[32m+//! This plugin removes content of defs and properties that aren't rendered
(B[m //! directly without ids. Elements with ids or style elements are preserved.
 
 use crate::ast::{Document, Element, Node};
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:12:
 /// Non-rendering SVG elements (elements that define reusable resources)
 const NON_RENDERING_ELEMENTS: &[&str] = &[
     "clipPath",
[31m-    "filter", 
(B[m[32m+    "filter",
(B[m     "linearGradient",
     "marker",
     "mask",
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:34:
         "removes elements in <defs> without id"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         self.process_element(&mut document.root);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:43:
 impl RemoveUselessDefsPlugin {
     fn process_element(&self, element: &mut Element) {
         // Check if this element should have its children filtered
[31m-        if element.name == "defs" || 
(B[m[31m-           (NON_RENDERING_ELEMENTS.contains(&element.name.as_str()) && 
(B[m[31m-            !element.attributes.contains_key("id")) {
(B[m[31m-            
(B[m[32m+        if element.name == "defs"
(B[m[32m+            || (NON_RENDERING_ELEMENTS.contains(&element.name.as_str())
(B[m[32m+                && !element.attributes.contains_key("id"))
(B[m[32m+        {
(B[m             let useful_nodes = self.collect_useful_nodes(element);
             element.children = useful_nodes;
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:68:
     #[allow(clippy::only_used_in_recursion)]
     fn collect_useful_nodes(&self, element: &Element) -> Vec<Node> {
         let mut useful_nodes = Vec::new();
[31m-        
(B[m[32m+
(B[m         for child in &element.children {
             if let Node::Element(ref elem) = child {
                 if elem.attributes.contains_key("id") || elem.name == "style" {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:84:
                 useful_nodes.push(child.clone());
             }
         }
[31m-        
(B[m[32m+
(B[m         useful_nodes
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:94:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document() -> Document {
         Document {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:113:
     fn test_plugin_name_and_description() {
         let plugin = RemoveUselessDefsPlugin;
         assert_eq!(plugin.name(), "removeUselessDefs");
[31m-        assert_eq!(plugin.description(), "removes elements in <defs> without id");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes elements in <defs> without id"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:120:
     fn test_remove_empty_defs() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let defs_element = Element {
             name: "defs".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:145:
     #[test]
     fn test_preserve_elements_with_id() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let mut gradient_attrs = IndexMap::new();
         gradient_attrs.insert("id".to_string(), "grad1".to_string());
[31m-        
(B[m[32m+
(B[m         let gradient_element = Element {
             name: "linearGradient".to_string(),
             attributes: gradient_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:187:
     #[test]
     fn test_remove_elements_without_id() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let gradient_element = Element {
             name: "linearGradient".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:220:
     #[test]
     fn test_preserve_style_elements() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let style_element = Element {
             name: "style".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:258:
     #[test]
     fn test_flatten_nested_useless_elements() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let mut useful_attrs = IndexMap::new();
         useful_attrs.insert("id".to_string(), "useful".to_string());
[31m-        
(B[m[32m+
(B[m         let useful_element = Element {
             name: "stop".to_string(),
             attributes: useful_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:314:
     #[test]
     fn test_non_rendering_elements_without_id() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let mut mask_with_id_attrs = IndexMap::new();
         mask_with_id_attrs.insert("id".to_string(), "mask1".to_string());
[31m-        
(B[m[32m+
(B[m         let mask_with_id = Element {
             name: "mask".to_string(),
             attributes: mask_with_id_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:343:
 
         // Should have 1 element (mask with ID), mask without ID should be empty
         assert_eq!(document.root.children.len(), 2);
[31m-        
(B[m[32m+
(B[m         if let Node::Element(ref mask1) = document.root.children[0] {
             assert_eq!(mask1.name, "mask");
             assert!(mask1.attributes.contains_key("id"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_defs.rs:359:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs:1:
 // this_file: svgn/src/plugins/remove_useless_transforms.rs
 //! Plugin to remove identity/no-op transforms from SVG elements
[31m-use crate::ast::{Element, Document, Node};
(B[m[32m+use crate::ast::{Document, Element, Node};
(B[m use crate::plugin::{Plugin, PluginInfo, PluginResult};
 use serde_json::Value;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs:16:
         "Removes transform attributes that are no-op: translate(0,0), scale(1), rotate(0)"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         remove_useless_transforms_element(&mut document.root);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs:40:
 /// Returns true if the transform string matches a no-op transform
 fn is_useless_transform(s: &str) -> bool {
     let t = s.trim();
[31m-    
(B[m[32m+
(B[m     // Check for various no-op transforms with different syntaxes
     matches!(
         t,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs:47:
[31m-        "translate(0,0)" | "translate(0, 0)" | "translate(0 0)" | 
(B[m[31m-        "rotate(0)" | 
(B[m[31m-        "scale(1)" | "scale(1,1)" | "scale(1, 1)" | "scale(1 1)" |
(B[m[31m-        "skewX(0)" | "skewY(0)" | 
(B[m[31m-        "matrix(1,0,0,1,0,0)" | "matrix(1, 0, 0, 1, 0, 0)" | "matrix(1 0 0 1 0 0)"
(B[m[32m+        "translate(0,0)"
(B[m[32m+            | "translate(0, 0)"
(B[m[32m+            | "translate(0 0)"
(B[m[32m+            | "rotate(0)"
(B[m[32m+            | "scale(1)"
(B[m[32m+            | "scale(1,1)"
(B[m[32m+            | "scale(1, 1)"
(B[m[32m+            | "scale(1 1)"
(B[m[32m+            | "skewX(0)"
(B[m[32m+            | "skewY(0)"
(B[m[32m+            | "matrix(1,0,0,1,0,0)"
(B[m[32m+            | "matrix(1, 0, 0, 1, 0, 0)"
(B[m[32m+            | "matrix(1 0 0 1 0 0)"
(B[m     )
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs:62:
     fn test_remove_identity_translate() {
         let mut doc = Document::new();
         let mut g = Element::new("g");
[31m-        g.attributes.insert("transform".to_string(), "translate(0,0)".to_string());
(B[m[32m+        g.attributes
(B[m[32m+            .insert("transform".to_string(), "translate(0,0)".to_string());
(B[m         doc.root.children.push(Node::Element(g));
 
         let mut plugin = RemoveUselessTransformsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs:80:
     fn test_remove_identity_scale() {
         let mut doc = Document::new();
         let mut g = Element::new("g");
[31m-        g.attributes.insert("transform".to_string(), "scale(1)".to_string());
(B[m[32m+        g.attributes
(B[m[32m+            .insert("transform".to_string(), "scale(1)".to_string());
(B[m         doc.root.children.push(Node::Element(g));
 
         let mut plugin = RemoveUselessTransformsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs:98:
     fn test_preserve_non_identity_transform() {
         let mut doc = Document::new();
         let mut g = Element::new("g");
[31m-        g.attributes.insert("transform".to_string(), "translate(10,20)".to_string());
(B[m[32m+        g.attributes
(B[m[32m+            .insert("transform".to_string(), "translate(10,20)".to_string());
(B[m         doc.root.children.push(Node::Element(g));
 
         let mut plugin = RemoveUselessTransformsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs:109:
             Node::Element(e) => e,
             _ => panic!("Expected element"),
         };
[31m-        assert_eq!(g.attributes.get("transform"), Some(&"translate(10,20)".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            g.attributes.get("transform"),
(B[m[32m+            Some(&"translate(10,20)".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs:125:
         assert!(is_useless_transform("skewY(0)"));
         assert!(is_useless_transform("matrix(1 0 0 1 0 0)"));
         assert!(is_useless_transform(" translate(0,0) "));
[31m-        
(B[m[32m+
(B[m         assert!(!is_useless_transform("translate(10,0)"));
         assert!(!is_useless_transform("translate(0,10)"));
         assert!(!is_useless_transform("rotate(45)"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_useless_transforms.rs:133:
         assert!(!is_useless_transform("scale(1,2)"));
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:3:
 //! Plugin to remove viewBox attribute when possible
 //!
 //! This plugin removes the viewBox attribute when it coincides with width/height box.
[31m-//! For example, `<svg width="100" height="50" viewBox="0 0 100 50">` becomes 
(B[m[32m+//! For example, `<svg width="100" height="50" viewBox="0 0 100 50">` becomes
(B[m //! `<svg width="100" height="50">`.
 
 use crate::ast::{Document, Element, Node};
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:25:
         "removes viewBox attribute when possible"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         self.process_element(&mut document.root, true);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:66:
 
     fn can_remove_viewbox(&self, view_box: &str, width: &str, height: &str) -> bool {
         // Parse viewBox values (format: "min-x min-y width height")
[31m-        let view_box_parts: Vec<&str> = view_box.split(&[' ', ','][..]).filter(|s| !s.is_empty()).collect();
(B[m[31m-        
(B[m[32m+        let view_box_parts: Vec<&str> = view_box
(B[m[32m+            .split(&[' ', ','][..])
(B[m[32m+            .filter(|s| !s.is_empty())
(B[m[32m+            .collect();
(B[m[32m+
(B[m         if view_box_parts.len() != 4 {
             return false;
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:91:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document() -> Document {
         Document {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:110:
     fn test_plugin_name_and_description() {
         let plugin = RemoveViewBoxPlugin;
         assert_eq!(plugin.name(), "removeViewBox");
[31m-        assert_eq!(plugin.description(), "removes viewBox attribute when possible");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes viewBox attribute when possible"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:117:
     fn test_remove_redundant_viewbox() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        document.root.attributes.insert("height".to_string(), "50".to_string());
(B[m[31m-        document.root.attributes.insert("viewBox".to_string(), "0 0 100 50".to_string());
(B[m 
[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("viewBox".to_string(), "0 0 100 50".to_string());
(B[m[32m+
(B[m         let mut plugin = RemoveViewBoxPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:134:
     #[test]
     fn test_keep_viewbox_with_px_units() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("width".to_string(), "100px".to_string());
(B[m[31m-        document.root.attributes.insert("height".to_string(), "50px".to_string());
(B[m[31m-        document.root.attributes.insert("viewBox".to_string(), "0 0 100 50".to_string());
(B[m 
[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100px".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50px".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("viewBox".to_string(), "0 0 100 50".to_string());
(B[m[32m+
(B[m         let mut plugin = RemoveViewBoxPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:150:
     #[test]
     fn test_keep_viewbox_different_origin() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        document.root.attributes.insert("height".to_string(), "50".to_string());
(B[m[31m-        document.root.attributes.insert("viewBox".to_string(), "10 10 100 50".to_string());
(B[m 
[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("viewBox".to_string(), "10 10 100 50".to_string());
(B[m[32m+
(B[m         let mut plugin = RemoveViewBoxPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:167:
     #[test]
     fn test_keep_viewbox_different_dimensions() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        document.root.attributes.insert("height".to_string(), "50".to_string());
(B[m[31m-        document.root.attributes.insert("viewBox".to_string(), "0 0 200 100".to_string());
(B[m 
[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("viewBox".to_string(), "0 0 200 100".to_string());
(B[m[32m+
(B[m         let mut plugin = RemoveViewBoxPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:184:
     #[test]
     fn test_keep_viewbox_missing_width_or_height() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("width".to_string(), "100".to_string());
(B[m[32m+
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m         // Missing height
[31m-        document.root.attributes.insert("viewBox".to_string(), "0 0 100 50".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("viewBox".to_string(), "0 0 100 50".to_string());
(B[m 
         let mut plugin = RemoveViewBoxPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:200:
     #[test]
     fn test_comma_separated_viewbox() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        document.root.attributes.insert("height".to_string(), "50".to_string());
(B[m[31m-        document.root.attributes.insert("viewBox".to_string(), "0,0,100,50".to_string());
(B[m 
[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("viewBox".to_string(), "0,0,100,50".to_string());
(B[m[32m+
(B[m         let mut plugin = RemoveViewBoxPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:216:
     #[test]
     fn test_mixed_separator_viewbox() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        document.root.attributes.insert("height".to_string(), "50".to_string());
(B[m[31m-        document.root.attributes.insert("viewBox".to_string(), "0, 0 100,50".to_string());
(B[m 
[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "50".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("viewBox".to_string(), "0, 0 100,50".to_string());
(B[m[32m+
(B[m         let mut plugin = RemoveViewBoxPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:232:
     #[test]
     fn test_pattern_element() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let mut pattern_attrs = IndexMap::new();
         pattern_attrs.insert("width".to_string(), "20".to_string());
         pattern_attrs.insert("height".to_string(), "30".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:265:
     #[test]
     fn test_nested_svg_preserved() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let mut nested_svg_attrs = IndexMap::new();
         nested_svg_attrs.insert("width".to_string(), "50".to_string());
         nested_svg_attrs.insert("height".to_string(), "25".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_view_box.rs:294:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:14:
 const XLINK_NAMESPACE: &str = "http://www.w3.org/1999/xlink";
 
 /// Elements that use xlink:href but were deprecated in SVG 2
[31m-const LEGACY_ELEMENTS: &[&str] = &[
(B[m[31m-    "cursor",
(B[m[31m-    "filter", 
(B[m[31m-    "font-face-uri",
(B[m[31m-    "glyphRef",
(B[m[31m-    "tref",
(B[m[31m-];
(B[m[32m+const LEGACY_ELEMENTS: &[&str] = &["cursor", "filter", "font-face-uri", "glyphRef", "tref"];
(B[m 
 /// Configuration for the removeXlink plugin
[31m-#[derive(Debug, Clone)]
(B[m[31m-#[derive(Default)]
(B[m[32m+#[derive(Debug, Clone, Default)]
(B[m pub struct RemoveXlinkConfig {
     /// Include legacy elements that don't support SVG 2 href
     pub include_legacy: bool,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:31:
 }
 
[31m-
(B[m /// Plugin to remove xlink namespace and convert to SVG 2 equivalents
 pub struct RemoveXlinkPlugin;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:43:
         "remove xlink namespace and replaces attributes with the SVG 2 equivalent where applicable"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = self.parse_config(params)?;
         let mut context = XlinkContext::new(config);
[31m-        
(B[m[32m+
(B[m         self.process_element(&mut document.root, &mut context);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:71:
 impl RemoveXlinkPlugin {
     fn parse_config(&self, params: Option<&Value>) -> PluginResult<RemoveXlinkConfig> {
         let mut config = RemoveXlinkConfig::default();
[31m-        
(B[m[32m+
(B[m         if let Some(params_obj) = params {
             if let Some(include_legacy) = params_obj.get("includeLegacy") {
                 if let Some(val) = include_legacy.as_bool() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:79:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         Ok(config)
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:86:
     fn process_element(&self, element: &mut Element, context: &mut XlinkContext) {
         // Collect xlink namespace prefixes
         let mut current_xlink_prefixes = Vec::new();
[31m-        
(B[m[32m+
(B[m         for (key, value) in &element.attributes {
             if key.starts_with("xmlns:") && value == XLINK_NAMESPACE {
                 let prefix = key.strip_prefix("xmlns:").unwrap();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:97:
 
         // Handle xlink:href conversion
         let is_legacy = LEGACY_ELEMENTS.contains(&element.name.as_str());
[31m-        
(B[m[32m+
(B[m         if is_legacy && !context.config.include_legacy {
             // Mark prefixes as used in legacy elements - check for any xlink attributes
             let has_xlink_attrs = element.attributes.keys().any(|key| {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:104:
[31m-                context.xlink_prefixes.iter().any(|prefix| key.starts_with(&format!("{}:", prefix)))
(B[m[32m+                context
(B[m[32m+                    .xlink_prefixes
(B[m[32m+                    .iter()
(B[m[32m+                    .any(|prefix| key.starts_with(&format!("{}:", prefix)))
(B[m             });
[31m-            
(B[m[32m+
(B[m             if has_xlink_attrs {
                 for prefix in &context.xlink_prefixes {
                     if !context.used_in_legacy.contains(prefix) {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:125:
             self.convert_title_attributes(element, &context.xlink_prefixes);
 
             // Remove unused xlink attributes
[31m-            self.remove_unused_xlink_attributes(element, &context.xlink_prefixes, &context.used_in_legacy);
(B[m[32m+            self.remove_unused_xlink_attributes(
(B[m[32m+                element,
(B[m[32m+                &context.xlink_prefixes,
(B[m[32m+                &context.used_in_legacy,
(B[m[32m+            );
(B[m         }
 
         // Process children recursively
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:151:
 
     fn convert_href_attributes(&self, element: &mut Element, xlink_prefixes: &[String]) {
         // Find xlink:href attributes
[31m-        let href_attrs: Vec<String> = element.attributes.keys()
(B[m[32m+        let href_attrs: Vec<String> = element
(B[m[32m+            .attributes
(B[m[32m+            .keys()
(B[m             .filter(|key| {
[31m-                xlink_prefixes.iter().any(|prefix| *key == &format!("{}:href", prefix))
(B[m[32m+                xlink_prefixes
(B[m[32m+                    .iter()
(B[m[32m+                    .any(|prefix| *key == &format!("{}:href", prefix))
(B[m             })
             .cloned()
             .collect();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:171:
 
     fn convert_show_attributes(&self, element: &mut Element, xlink_prefixes: &[String]) {
         // Find xlink:show attributes
[31m-        let show_attrs: Vec<String> = element.attributes.keys()
(B[m[32m+        let show_attrs: Vec<String> = element
(B[m[32m+            .attributes
(B[m[32m+            .keys()
(B[m             .filter(|key| {
[31m-                xlink_prefixes.iter().any(|prefix| *key == &format!("{}:show", prefix))
(B[m[32m+                xlink_prefixes
(B[m[32m+                    .iter()
(B[m[32m+                    .any(|prefix| *key == &format!("{}:show", prefix))
(B[m             })
             .cloned()
             .collect();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:184:
                 if !element.attributes.contains_key("target") {
                     let target_value = match show_value.as_str() {
                         "new" => "_blank",
[31m-                        "replace" => "_self", 
(B[m[32m+                        "replace" => "_self",
(B[m                         _ => {
                             // Remove unknown values
                             element.attributes.shift_remove(&show_attr);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:191:
                             continue;
                         }
                     };
[31m-                    element.attributes.insert("target".to_string(), target_value.to_string());
(B[m[32m+                    element
(B[m[32m+                        .attributes
(B[m[32m+                        .insert("target".to_string(), target_value.to_string());
(B[m                 }
                 element.attributes.shift_remove(&show_attr);
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:200:
 
     fn convert_title_attributes(&self, element: &mut Element, xlink_prefixes: &[String]) {
         // Find xlink:title attributes
[31m-        let title_attrs: Vec<String> = element.attributes.keys()
(B[m[32m+        let title_attrs: Vec<String> = element
(B[m[32m+            .attributes
(B[m[32m+            .keys()
(B[m             .filter(|key| {
[31m-                xlink_prefixes.iter().any(|prefix| *key == &format!("{}:title", prefix))
(B[m[32m+                xlink_prefixes
(B[m[32m+                    .iter()
(B[m[32m+                    .any(|prefix| *key == &format!("{}:title", prefix))
(B[m             })
             .cloned()
             .collect();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:210:
         for title_attr in title_attrs {
             if let Some(title_value) = element.attributes.get(&title_attr).cloned() {
                 // Check if element already has a title child
[31m-                let has_title_child = element.children.iter().any(|child| {
(B[m[31m-                    matches!(child, Node::Element(elem) if elem.name == "title")
(B[m[31m-                });
(B[m[32m+                let has_title_child = element
(B[m[32m+                    .children
(B[m[32m+                    .iter()
(B[m[32m+                    .any(|child| matches!(child, Node::Element(elem) if elem.name == "title"));
(B[m 
                 if !has_title_child {
                     // Create title element
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:229:
         }
     }
 
[31m-    fn remove_unused_xlink_attributes(&self, element: &mut Element, xlink_prefixes: &[String], used_in_legacy: &[String]) {
(B[m[32m+    fn remove_unused_xlink_attributes(
(B[m[32m+        &self,
(B[m[32m+        element: &mut Element,
(B[m[32m+        xlink_prefixes: &[String],
(B[m[32m+        used_in_legacy: &[String],
(B[m[32m+    ) {
(B[m         // Remove any remaining xlink attributes that weren't converted
[31m-        let attrs_to_remove: Vec<String> = element.attributes.keys()
(B[m[32m+        let attrs_to_remove: Vec<String> = element
(B[m[32m+            .attributes
(B[m[32m+            .keys()
(B[m             .filter(|key| {
                 if let Some(colon_pos) = key.find(':') {
                     let prefix = &key[..colon_pos];
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:238:
[31m-                    xlink_prefixes.contains(&prefix.to_string()) && 
(B[m[31m-                    !used_in_legacy.contains(&prefix.to_string())
(B[m[32m+                    xlink_prefixes.contains(&prefix.to_string())
(B[m[32m+                        && !used_in_legacy.contains(&prefix.to_string())
(B[m                 } else {
                     false
                 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:255:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document() -> Document {
         Document {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:280:
     #[test]
     fn test_convert_xlink_href_to_href() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add xlink namespace
[31m-        document.root.attributes.insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[31m-        
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[32m+
(B[m         // Add element with xlink:href
         let mut use_attrs = IndexMap::new();
         use_attrs.insert("xlink:href".to_string(), "#symbol1".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:290:
[31m-        
(B[m[32m+
(B[m         let use_element = Element {
             name: "use".to_string(),
             attributes: use_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:304:
         // xlink:href should be converted to href
         if let Node::Element(ref use_elem) = document.root.children[0] {
             assert!(!use_elem.attributes.contains_key("xlink:href"));
[31m-            assert_eq!(use_elem.attributes.get("href"), Some(&"#symbol1".to_string()));
(B[m[32m+            assert_eq!(
(B[m[32m+                use_elem.attributes.get("href"),
(B[m[32m+                Some(&"#symbol1".to_string())
(B[m[32m+            );
(B[m         } else {
             panic!("Expected use element");
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:316:
     #[test]
     fn test_preserve_existing_href() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[32m+
(B[m         let mut element_attrs = IndexMap::new();
         element_attrs.insert("href".to_string(), "#existing".to_string());
         element_attrs.insert("xlink:href".to_string(), "#xlink".to_string());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:325:
[31m-        
(B[m[32m+
(B[m         let element = Element {
             name: "a".to_string(),
             attributes: element_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:348:
     #[test]
     fn test_convert_xlink_show_to_target() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[32m+
(B[m         let mut element_attrs = IndexMap::new();
         element_attrs.insert("xlink:show".to_string(), "new".to_string());
[31m-        
(B[m[32m+
(B[m         let element = Element {
             name: "a".to_string(),
             attributes: element_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:379:
     #[test]
     fn test_convert_xlink_title_to_title_element() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[32m+
(B[m         let mut element_attrs = IndexMap::new();
         element_attrs.insert("xlink:title".to_string(), "Element title".to_string());
[31m-        
(B[m[32m+
(B[m         let element = Element {
             name: "rect".to_string(),
             attributes: element_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:402:
         if let Node::Element(ref elem) = document.root.children[0] {
             assert!(!elem.attributes.contains_key("xlink:title"));
             assert_eq!(elem.children.len(), 1);
[31m-            
(B[m[32m+
(B[m             if let Node::Element(ref title) = elem.children[0] {
                 assert_eq!(title.name, "title");
                 assert_eq!(title.children.len(), 1);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:422:
     #[test]
     fn test_preserve_legacy_elements() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[32m+
(B[m         let mut filter_attrs = IndexMap::new();
         filter_attrs.insert("xlink:href".to_string(), "#filter1".to_string());
[31m-        
(B[m[32m+
(B[m         let filter_element = Element {
             name: "filter".to_string(),
             attributes: filter_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:456:
     #[test]
     fn test_include_legacy_option() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("xmlns:xlink".to_string(), XLINK_NAMESPACE.to_string());
(B[m[32m+
(B[m         let mut filter_attrs = IndexMap::new();
         filter_attrs.insert("xlink:href".to_string(), "#filter1".to_string());
[31m-        
(B[m[32m+
(B[m         let filter_element = Element {
             name: "filter".to_string(),
             attributes: filter_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xlink.rs:485:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs:17:
     fn name(&self) -> &'static str {
         "removeXMLProcInst"
     }
[31m-    
(B[m[32m+
(B[m     fn description(&self) -> &'static str {
         "Remove XML processing instructions"
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs:24:
[31m-    
(B[m[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         // Remove the XML declaration by clearing metadata
         // In SVGO, the XML declaration is treated as a processing instruction,
         // but in our parser it's stored as metadata
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs:29:
         document.metadata.version = None;
         document.metadata.encoding = None;
[31m-        
(B[m[32m+
(B[m         // Also remove any actual XML processing instructions from prologue
         document.prologue.retain(|node| {
             match node {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs:39:
                 _ => true,
             }
         });
[31m-        
(B[m[32m+
(B[m         // Remove XML processing instructions from epilogue (shouldn't be there, but check anyway)
[31m-        document.epilogue.retain(|node| {
(B[m[31m-            match node {
(B[m[31m-                Node::ProcessingInstruction { target, .. } => {
(B[m[31m-                    target != "xml"
(B[m[31m-                }
(B[m[31m-                _ => true,
(B[m[31m-            }
(B[m[32m+        document.epilogue.retain(|node| match node {
(B[m[32m+            Node::ProcessingInstruction { target, .. } => target != "xml",
(B[m[32m+            _ => true,
(B[m         });
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs:59:
 mod tests {
     use super::*;
     use crate::parser::Parser;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_remove_xml_declaration() {
         let svg = r#"<?xml version="1.0" encoding="utf-8"?>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs:66:
 <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
     <rect x="10" y="10" width="80" height="80"/>
 </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         // Verify XML declaration metadata is present
         assert!(document.metadata.version.is_some());
         assert!(document.metadata.encoding.is_some());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs:76:
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveXMLProcInstPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Verify XML declaration metadata is removed
         assert!(document.metadata.version.is_none());
         assert!(document.metadata.encoding.is_none());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs:83:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_preserve_other_pi() {
         let svg = r#"<?xml version="1.0" encoding="utf-8"?>
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs:89:
 <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
     <rect x="10" y="10" width="80" height="80"/>
 </svg>"#;
[31m-        
(B[m[32m+
(B[m         let parser = Parser::new();
         let mut document = parser.parse(svg).unwrap();
[31m-        
(B[m[32m+
(B[m         let mut plugin = RemoveXMLProcInstPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[31m-        
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Verify XML declaration is removed but other PIs are kept
[31m-        let has_xml_pi = document.prologue.iter().any(|n| {
(B[m[31m-            matches!(n, Node::ProcessingInstruction { target, .. } if target == "xml")
(B[m[31m-        });
(B[m[32m+        let has_xml_pi = document
(B[m[32m+            .prologue
(B[m[32m+            .iter()
(B[m[32m+            .any(|n| matches!(n, Node::ProcessingInstruction { target, .. } if target == "xml"));
(B[m         assert!(!has_xml_pi);
[31m-        
(B[m[32m+
(B[m         let has_stylesheet_pi = document.prologue.iter().any(|n| {
             matches!(n, Node::ProcessingInstruction { target, .. } if target == "xml-stylesheet")
         });
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xml_proc_inst.rs:108:
         assert!(has_stylesheet_pi);
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:21:
         "removes xmlns attribute (for inline svg, disabled by default)"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         self.process_element(&mut document.root);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:49:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document() -> Document {
         Document {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:68:
     fn test_plugin_name_and_description() {
         let plugin = RemoveXMLNSPlugin;
         assert_eq!(plugin.name(), "removeXMLNS");
[31m-        assert_eq!(plugin.description(), "removes xmlns attribute (for inline svg, disabled by default)");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "removes xmlns attribute (for inline svg, disabled by default)"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:75:
     fn test_remove_xmlns_from_svg() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("xmlns".to_string(), "http://www.w3.org/2000/svg".to_string());
(B[m[31m-        document.root.attributes.insert("viewBox".to_string(), "0 0 100 100".to_string());
(B[m 
[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns".to_string(),
(B[m[32m+            "http://www.w3.org/2000/svg".to_string(),
(B[m[32m+        );
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("viewBox".to_string(), "0 0 100 100".to_string());
(B[m[32m+
(B[m         let mut plugin = RemoveXMLNSPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:91:
     #[test]
     fn test_remove_xmlns_from_nested_svg() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add nested SVG element with xmlns
         let mut nested_svg_attrs = IndexMap::new();
[31m-        nested_svg_attrs.insert("xmlns".to_string(), "http://www.w3.org/2000/svg".to_string());
(B[m[32m+        nested_svg_attrs.insert(
(B[m[32m+            "xmlns".to_string(),
(B[m[32m+            "http://www.w3.org/2000/svg".to_string(),
(B[m[32m+        );
(B[m         nested_svg_attrs.insert("width".to_string(), "50".to_string());
[31m-        
(B[m[32m+
(B[m         let nested_svg = Element {
             name: "svg".to_string(),
             attributes: nested_svg_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:124:
     #[test]
     fn test_preserve_other_xmlns_attributes() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("xmlns".to_string(), "http://www.w3.org/2000/svg".to_string());
(B[m[31m-        document.root.attributes.insert("xmlns:xlink".to_string(), "http://www.w3.org/1999/xlink".to_string());
(B[m[31m-        document.root.attributes.insert("xmlns:custom".to_string(), "http://example.com/custom".to_string());
(B[m 
[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns".to_string(),
(B[m[32m+            "http://www.w3.org/2000/svg".to_string(),
(B[m[32m+        );
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:xlink".to_string(),
(B[m[32m+            "http://www.w3.org/1999/xlink".to_string(),
(B[m[32m+        );
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns:custom".to_string(),
(B[m[32m+            "http://example.com/custom".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         let mut plugin = RemoveXMLNSPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:142:
     #[test]
     fn test_ignore_non_svg_elements() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Add a non-SVG element with xmlns (shouldn't happen but test anyway)
         let mut rect_attrs = IndexMap::new();
[31m-        rect_attrs.insert("xmlns".to_string(), "http://www.w3.org/2000/svg".to_string());
(B[m[32m+        rect_attrs.insert(
(B[m[32m+            "xmlns".to_string(),
(B[m[32m+            "http://www.w3.org/2000/svg".to_string(),
(B[m[32m+        );
(B[m         rect_attrs.insert("width".to_string(), "100".to_string());
[31m-        
(B[m[32m+
(B[m         let rect_element = Element {
             name: "rect".to_string(),
             attributes: rect_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:174:
     #[test]
     fn test_no_xmlns_attribute() {
         let mut document = create_test_document();
[31m-        
(B[m[31m-        document.root.attributes.insert("viewBox".to_string(), "0 0 100 100".to_string());
(B[m[31m-        document.root.attributes.insert("width".to_string(), "100".to_string());
(B[m 
[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("viewBox".to_string(), "0 0 100 100".to_string());
(B[m[32m+        document
(B[m[32m+            .root
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+
(B[m         let mut plugin = RemoveXMLNSPlugin;
         let result = plugin.apply(&mut document, &PluginInfo::default(), Some(&Value::Null));
         assert!(result.is_ok());
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:191:
     #[test]
     fn test_complex_nested_structure() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Root SVG with xmlns
[31m-        document.root.attributes.insert("xmlns".to_string(), "http://www.w3.org/2000/svg".to_string());
(B[m[31m-        
(B[m[32m+        document.root.attributes.insert(
(B[m[32m+            "xmlns".to_string(),
(B[m[32m+            "http://www.w3.org/2000/svg".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         // Nested structure: svg -> g -> svg
         let mut inner_svg_attrs = IndexMap::new();
[31m-        inner_svg_attrs.insert("xmlns".to_string(), "http://www.w3.org/2000/svg".to_string());
(B[m[32m+        inner_svg_attrs.insert(
(B[m[32m+            "xmlns".to_string(),
(B[m[32m+            "http://www.w3.org/2000/svg".to_string(),
(B[m[32m+        );
(B[m         inner_svg_attrs.insert("x".to_string(), "10".to_string());
[31m-        
(B[m[32m+
(B[m         let inner_svg = Element {
             name: "svg".to_string(),
             attributes: inner_svg_attrs,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:222:
 
         // Both root and nested SVG should have xmlns removed
         assert!(!document.root.attributes.contains_key("xmlns"));
[31m-        
(B[m[32m+
(B[m         if let Node::Element(ref g) = document.root.children[0] {
             if let Node::Element(ref inner_svg) = g.children[0] {
                 assert_eq!(inner_svg.name, "svg");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/remove_xmlns.rs:236:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:7:
 
 use crate::ast::{Document, Element, Node};
 use crate::plugin::{Plugin, PluginInfo, PluginResult};
[31m-use serde_json::Value;
(B[m use indexmap::IndexMap;
[32m+use serde_json::Value;
(B[m use std::cmp::Ordering;
 
 /// Plugin to sort element attributes
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:62:
     /// Parse parameters from JSON value
     pub fn from_value(value: Option<&Value>) -> Self {
         let mut params = Self::default();
[31m-        
(B[m[32m+
(B[m         if let Some(Value::Object(map)) = value {
             // Parse custom order array
             if let Some(Value::Array(order_array)) = map.get("order") {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:76:
                     params.order = order;
                 }
             }
[31m-            
(B[m[32m+
(B[m             // Parse xmlns order preference
             if let Some(Value::String(xmlns_order)) = map.get("xmlnsOrder") {
                 match xmlns_order.as_str() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:86:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         params
     }
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:100:
         "Sort element attributes for better compression"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _plugin_info: &PluginInfo, params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _plugin_info: &PluginInfo,
(B[m[32m+        params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         let config = SortAttrsParams::from_value(params);
         visit_elements(&mut document.root, &config);
         Ok(())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:110:
 /// Visit all elements in the AST and sort their attributes
 fn visit_elements(element: &mut Element, config: &SortAttrsParams) {
     sort_element_attributes(element, config);
[31m-    
(B[m[32m+
(B[m     for child in &mut element.children {
         if let Node::Element(child_element) = child {
             visit_elements(child_element, config);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:121:
 /// Sort attributes in a single element
 fn sort_element_attributes(element: &mut Element, config: &SortAttrsParams) {
     // Convert attributes to a vector of (name, value) pairs
[31m-    let mut attrs: Vec<(String, String)> = element.attributes.iter()
(B[m[32m+    let mut attrs: Vec<(String, String)> = element
(B[m[32m+        .attributes
(B[m[32m+        .iter()
(B[m         .map(|(k, v)| (k.clone(), v.clone()))
         .collect();
[31m-    
(B[m[32m+
(B[m     // Sort the attributes
     attrs.sort_by(|a, b| compare_attrs(&a.0, &b.0, config));
[31m-    
(B[m[32m+
(B[m     // Rebuild the attributes map in sorted order
     let mut sorted_attributes = IndexMap::new();
     for (name, value) in attrs {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:134:
         sorted_attributes.insert(name, value);
     }
[31m-    
(B[m[32m+
(B[m     element.attributes = sorted_attributes;
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:142:
     // Get namespace priorities
     let a_priority = get_namespace_priority(a_name, &config.xmlns_order);
     let b_priority = get_namespace_priority(b_name, &config.xmlns_order);
[31m-    
(B[m[32m+
(B[m     // Sort by namespace priority first (higher priority comes first)
     match b_priority.cmp(&a_priority) {
         Ordering::Equal => {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:150:
         }
         other => return other,
     }
[31m-    
(B[m[32m+
(B[m     // Extract the first part from attributes (e.g., "fill" from "fill-opacity")
     let a_part = a_name.split('-').next().unwrap_or(a_name);
     let b_part = b_name.split('-').next().unwrap_or(b_name);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:157:
[31m-    
(B[m[32m+
(B[m     // If the first parts are different, apply order-based sorting
     if a_part != b_part {
         let a_in_order = config.order.iter().position(|x| x == a_part);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:161:
         let b_in_order = config.order.iter().position(|x| x == b_part);
[31m-        
(B[m[32m+
(B[m         match (a_in_order, b_in_order) {
             (Some(a_pos), Some(b_pos)) => {
                 // Both are in the custom order, sort by position
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:178:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Sort alphabetically
     a_name.cmp(b_name)
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:195:
             return 2;
         }
     }
[31m-    
(B[m[32m+
(B[m     // Other namespaces after and sort them alphabetically
     if name.contains(':') {
         return 1;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:202:
     }
[31m-    
(B[m[32m+
(B[m     // Other attributes (lowest priority)
     0
 }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:216:
     fn test_sorts_by_default_order() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[32m+
(B[m         // Add attributes in random order
[31m-        element.attributes.insert("stroke".to_string(), "black".to_string());
(B[m[31m-        element.attributes.insert("id".to_string(), "rect1".to_string());
(B[m[31m-        element.attributes.insert("height".to_string(), "100".to_string());
(B[m[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        element.attributes.insert("width".to_string(), "200".to_string());
(B[m[31m-        
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "black".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("id".to_string(), "rect1".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "100".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "200".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = SortAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:230:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Check that attributes are in the expected order
         let attr_names: Vec<&String> = document.root.attributes.keys().collect();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:234:
[31m-        
(B[m[32m+
(B[m         // id should come first, then width, height, fill, stroke
[31m-        let expected_positions = [("id", 0), ("width", 1), ("height", 2), ("fill", 3), ("stroke", 4)];
(B[m[31m-        
(B[m[32m+        let expected_positions = [
(B[m[32m+            ("id", 0),
(B[m[32m+            ("width", 1),
(B[m[32m+            ("height", 2),
(B[m[32m+            ("fill", 3),
(B[m[32m+            ("stroke", 4),
(B[m[32m+        ];
(B[m[32m+
(B[m         for (attr, expected_pos) in expected_positions {
             let actual_pos = attr_names.iter().position(|x| *x == attr).unwrap();
[31m-            assert_eq!(actual_pos, expected_pos, "Attribute '{}' should be at position {}", attr, expected_pos);
(B[m[32m+            assert_eq!(
(B[m[32m+                actual_pos, expected_pos,
(B[m[32m+                "Attribute '{}' should be at position {}",
(B[m[32m+                attr, expected_pos
(B[m[32m+            );
(B[m         }
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:245:
     fn test_xmlns_front_ordering() {
         let mut document = Document::new();
         let mut element = Element::new("svg");
[31m-        
(B[m[31m-        element.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        element.attributes.insert("xmlns:xlink".to_string(), "http://www.w3.org/1999/xlink".to_string());
(B[m[31m-        element.attributes.insert("id".to_string(), "svg1".to_string());
(B[m[31m-        element.attributes.insert("xmlns".to_string(), "http://www.w3.org/2000/svg".to_string());
(B[m[31m-        element.attributes.insert("height".to_string(), "100".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "xmlns:xlink".to_string(),
(B[m[32m+            "http://www.w3.org/1999/xlink".to_string(),
(B[m[32m+        );
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("id".to_string(), "svg1".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "xmlns".to_string(),
(B[m[32m+            "http://www.w3.org/2000/svg".to_string(),
(B[m[32m+        );
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("height".to_string(), "100".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = SortAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:258:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         let attr_names: Vec<&String> = document.root.attributes.keys().collect();
[31m-        
(B[m[32m+
(B[m         // xmlns should be first, xmlns:xlink second, then regular attributes
         assert_eq!(attr_names[0], "xmlns");
         assert_eq!(attr_names[1], "xmlns:xlink");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:265:
         // id should come before width and height according to default order
[31m-        assert!(attr_names.iter().position(|x| *x == "id").unwrap() < 
(B[m[31m-                attr_names.iter().position(|x| *x == "width").unwrap());
(B[m[32m+        assert!(
(B[m[32m+            attr_names.iter().position(|x| *x == "id").unwrap()
(B[m[32m+                < attr_names.iter().position(|x| *x == "width").unwrap()
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:271:
     fn test_xmlns_alphabetical_ordering() {
         let mut document = Document::new();
         let mut element = Element::new("svg");
[31m-        
(B[m[31m-        element.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        element.attributes.insert("xmlns:xlink".to_string(), "http://www.w3.org/1999/xlink".to_string());
(B[m[31m-        element.attributes.insert("xmlns".to_string(), "http://www.w3.org/2000/svg".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "xmlns:xlink".to_string(),
(B[m[32m+            "http://www.w3.org/1999/xlink".to_string(),
(B[m[32m+        );
(B[m[32m+        element.attributes.insert(
(B[m[32m+            "xmlns".to_string(),
(B[m[32m+            "http://www.w3.org/2000/svg".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = SortAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:282:
         let params = json!({"xmlnsOrder": "alphabetical"});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         let attr_names: Vec<&String> = document.root.attributes.keys().collect();
[31m-        
(B[m[32m+
(B[m         // With alphabetical ordering, regular attributes and xmlns should be mixed
         // width comes before xmlns alphabetically
[31m-        assert!(attr_names.iter().position(|x| *x == "width").unwrap() < 
(B[m[31m-                attr_names.iter().position(|x| *x == "xmlns").unwrap());
(B[m[32m+        assert!(
(B[m[32m+            attr_names.iter().position(|x| *x == "width").unwrap()
(B[m[32m+                < attr_names.iter().position(|x| *x == "xmlns").unwrap()
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:294:
     fn test_grouped_attributes() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[31m-        element.attributes.insert("fill-opacity".to_string(), "0.5".to_string());
(B[m[31m-        element.attributes.insert("stroke-width".to_string(), "2".to_string());
(B[m[31m-        element.attributes.insert("fill".to_string(), "red".to_string());
(B[m[31m-        element.attributes.insert("stroke".to_string(), "black".to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill-opacity".to_string(), "0.5".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke-width".to_string(), "2".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("stroke".to_string(), "black".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = SortAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:306:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         let attr_names: Vec<&String> = document.root.attributes.keys().collect();
[31m-        
(B[m[32m+
(B[m         // fill should come before stroke (default order)
         let fill_pos = attr_names.iter().position(|x| *x == "fill").unwrap();
         let stroke_pos = attr_names.iter().position(|x| *x == "stroke").unwrap();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:313:
         assert!(fill_pos < stroke_pos);
[31m-        
(B[m[32m+
(B[m         // fill-opacity should come after fill (alphabetical within group)
[31m-        let fill_opacity_pos = attr_names.iter().position(|x| *x == "fill-opacity").unwrap();
(B[m[32m+        let fill_opacity_pos = attr_names
(B[m[32m+            .iter()
(B[m[32m+            .position(|x| *x == "fill-opacity")
(B[m[32m+            .unwrap();
(B[m         assert!(fill_pos < fill_opacity_pos);
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:321:
     fn test_custom_order() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[32m+
(B[m         element.attributes.insert("y".to_string(), "10".to_string());
         element.attributes.insert("x".to_string(), "5".to_string());
[31m-        element.attributes.insert("id".to_string(), "rect1".to_string());
(B[m[31m-        
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("id".to_string(), "rect1".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = SortAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:332:
         let params = json!({"order": ["y", "x", "id"]});
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), Some(&params)).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(
(B[m[32m+                &mut document,
(B[m[32m+                &crate::plugin::PluginInfo::default(),
(B[m[32m+                Some(&params),
(B[m[32m+            )
(B[m[32m+            .unwrap();
(B[m 
         let attr_names: Vec<&String> = document.root.attributes.keys().collect();
[31m-        
(B[m[32m+
(B[m         // Should follow the custom order: y, x, id
         assert_eq!(attr_names[0], "y");
         assert_eq!(attr_names[1], "x");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:344:
     fn test_alphabetical_fallback() {
         let mut document = Document::new();
         let mut element = Element::new("rect");
[31m-        
(B[m[32m+
(B[m         // Add attributes not in the default order
[31m-        element.attributes.insert("z-index".to_string(), "1".to_string());
(B[m[31m-        element.attributes.insert("class".to_string(), "rect".to_string());
(B[m[31m-        element.attributes.insert("data-test".to_string(), "value".to_string());
(B[m[31m-        
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("z-index".to_string(), "1".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("class".to_string(), "rect".to_string());
(B[m[32m+        element
(B[m[32m+            .attributes
(B[m[32m+            .insert("data-test".to_string(), "value".to_string());
(B[m[32m+
(B[m         document.root = element;
 
         let mut plugin = SortAttrsPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:356:
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         let attr_names: Vec<&String> = document.root.attributes.keys().collect();
[31m-        
(B[m[32m+
(B[m         // Should be in alphabetical order: class, data-test, z-index
         assert_eq!(attr_names[0], "class");
         assert_eq!(attr_names[1], "data-test");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:368:
         let mut document = Document::new();
         let mut root = Element::new("svg");
         let mut child = Element::new("rect");
[31m-        
(B[m[32m+
(B[m         // Root element attributes
[31m-        root.attributes.insert("height".to_string(), "100".to_string());
(B[m[32m+        root.attributes
(B[m[32m+            .insert("height".to_string(), "100".to_string());
(B[m         root.attributes.insert("id".to_string(), "svg1".to_string());
[31m-        root.attributes.insert("width".to_string(), "100".to_string());
(B[m[31m-        
(B[m[32m+        root.attributes
(B[m[32m+            .insert("width".to_string(), "100".to_string());
(B[m[32m+
(B[m         // Child element attributes
         child.attributes.insert("y".to_string(), "10".to_string());
[31m-        child.attributes.insert("fill".to_string(), "red".to_string());
(B[m[32m+        child
(B[m[32m+            .attributes
(B[m[32m+            .insert("fill".to_string(), "red".to_string());
(B[m         child.attributes.insert("x".to_string(), "5".to_string());
[31m-        
(B[m[32m+
(B[m         root.children.push(Node::Element(child));
         document.root = root;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:385:
         let mut plugin = SortAttrsPlugin;
[31m-        plugin.apply(&mut document, &crate::plugin::PluginInfo::default(), None).unwrap();
(B[m[32m+        plugin
(B[m[32m+            .apply(&mut document, &crate::plugin::PluginInfo::default(), None)
(B[m[32m+            .unwrap();
(B[m 
         // Check root attributes are sorted
         let root_attr_names: Vec<&String> = document.root.attributes.keys().collect();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:390:
         assert_eq!(root_attr_names[0], "id");
         assert_eq!(root_attr_names[1], "width");
         assert_eq!(root_attr_names[2], "height");
[31m-        
(B[m[32m+
(B[m         // Check child attributes are sorted
         if let Node::Element(child_element) = &document.root.children[0] {
             let child_attr_names: Vec<&String> = child_element.attributes.keys().collect();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_attrs.rs:404:
     fn test_plugin_name_and_description() {
         let mut plugin = SortAttrsPlugin;
         assert_eq!(plugin.name(), "sortAttrs");
[31m-        assert_eq!(plugin.description(), "Sort element attributes for better compression");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "Sort element attributes for better compression"
(B[m[32m+        );
(B[m     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:3:
 //! Plugin to sort children of `<defs>` elements to improve compression
 //!
 //! This plugin sorts children of defs in order to improve compression. Elements are
[31m-//! sorted first by frequency (most frequent first), then by element name length 
(B[m[32m+//! sorted first by frequency (most frequent first), then by element name length
(B[m //! (longer names first), then alphabetically by element name.
 
 use crate::ast::{Document, Element, Node};
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:10:
 use crate::plugin::{Plugin, PluginInfo, PluginResult};
 use serde_json::Value;
[31m-use std::collections::HashMap;
(B[m use std::cmp::Ordering;
[32m+use std::collections::HashMap;
(B[m 
 /// Plugin to sort defs children for better compression
 pub struct SortDefsChildrenPlugin;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:24:
         "Sorts children of <defs> to improve compression"
     }
 
[31m-    fn apply(&mut self, document: &mut Document, _info: &PluginInfo, _params: Option<&Value>) -> PluginResult<()> {
(B[m[32m+    fn apply(
(B[m[32m+        &mut self,
(B[m[32m+        document: &mut Document,
(B[m[32m+        _info: &PluginInfo,
(B[m[32m+        _params: Option<&Value>,
(B[m[32m+    ) -> PluginResult<()> {
(B[m         self.process_element(&mut document.root);
         Ok(())
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:48:
     fn sort_defs_children(&self, defs: &mut Element) {
         // Count frequencies of element names
         let mut frequencies: HashMap<String, usize> = HashMap::new();
[31m-        
(B[m[32m+
(B[m         for child in &defs.children {
             if let Node::Element(ref elem) = child {
                 *frequencies.entry(elem.name.clone()).or_insert(0) += 1;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:62:
                     // First, sort by frequency (descending)
                     let freq_a = frequencies.get(&elem_a.name).unwrap_or(&0);
                     let freq_b = frequencies.get(&elem_b.name).unwrap_or(&0);
[31m-                    
(B[m[32m+
(B[m                     match freq_b.cmp(freq_a) {
                         Ordering::Equal => {
                             // Then by name length (descending)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:71:
                                     // Finally by name (descending/reverse alphabetical)
                                     elem_b.name.cmp(&elem_a.name)
                                 }
[31m-                                other => other
(B[m[32m+                                other => other,
(B[m                             }
                         }
[31m-                        other => other
(B[m[32m+                        other => other,
(B[m                     }
                 }
                 // Non-element nodes maintain their relative order
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:81:
[31m-                _ => Ordering::Equal
(B[m[32m+                _ => Ordering::Equal,
(B[m             }
         });
     }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:89:
 mod tests {
     use super::*;
     use crate::ast::{Document, Element, Node};
[31m-    use std::collections::HashMap;
(B[m     use indexmap::IndexMap;
[32m+    use std::collections::HashMap;
(B[m 
     fn create_test_document() -> Document {
         Document {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:117:
     fn test_plugin_name_and_description() {
         let plugin = SortDefsChildrenPlugin;
         assert_eq!(plugin.name(), "sortDefsChildren");
[31m-        assert_eq!(plugin.description(), "Sorts children of <defs> to improve compression");
(B[m[32m+        assert_eq!(
(B[m[32m+            plugin.description(),
(B[m[32m+            "Sorts children of <defs> to improve compression"
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:124:
     fn test_sort_by_frequency() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let defs = Element {
             name: "defs".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:146:
 
         // Should be sorted by frequency: pattern (3), linearGradient (2), mask (1)
         if let Node::Element(ref defs) = document.root.children[0] {
[31m-            let names: Vec<&str> = defs.children.iter()
(B[m[32m+            let names: Vec<&str> = defs
(B[m[32m+                .children
(B[m[32m+                .iter()
(B[m                 .filter_map(|child| {
                     if let Node::Element(elem) = child {
                         Some(elem.name.as_str())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:155:
                     }
                 })
                 .collect();
[31m-            
(B[m[31m-            assert_eq!(names, vec!["pattern", "pattern", "pattern", "linearGradient", "linearGradient", "mask"]);
(B[m[32m+
(B[m[32m+            assert_eq!(
(B[m[32m+                names,
(B[m[32m+                vec![
(B[m[32m+                    "pattern",
(B[m[32m+                    "pattern",
(B[m[32m+                    "pattern",
(B[m[32m+                    "linearGradient",
(B[m[32m+                    "linearGradient",
(B[m[32m+                    "mask"
(B[m[32m+                ]
(B[m[32m+            );
(B[m         } else {
             panic!("Expected defs element");
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:165:
     #[test]
     fn test_sort_by_name_length() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let defs = Element {
             name: "defs".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:186:
 
         // Should be sorted by name length (all have frequency 1)
         if let Node::Element(ref defs) = document.root.children[0] {
[31m-            let names: Vec<&str> = defs.children.iter()
(B[m[32m+            let names: Vec<&str> = defs
(B[m[32m+                .children
(B[m[32m+                .iter()
(B[m                 .filter_map(|child| {
                     if let Node::Element(elem) = child {
                         Some(elem.name.as_str())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:195:
                     }
                 })
                 .collect();
[31m-            
(B[m[32m+
(B[m             // Length 4 elements come first, then sorted alphabetically in reverse
             assert_eq!(names, vec!["rect", "path", "use", "g"]);
         } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:206:
     #[test]
     fn test_sort_alphabetically() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let defs = Element {
             name: "defs".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:227:
 
         // Should be sorted reverse alphabetically (all same length and frequency)
         if let Node::Element(ref defs) = document.root.children[0] {
[31m-            let names: Vec<&str> = defs.children.iter()
(B[m[32m+            let names: Vec<&str> = defs
(B[m[32m+                .children
(B[m[32m+                .iter()
(B[m                 .filter_map(|child| {
                     if let Node::Element(elem) = child {
                         Some(elem.name.as_str())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:236:
                     }
                 })
                 .collect();
[31m-            
(B[m[32m+
(B[m             assert_eq!(names, vec!["xyz", "mno", "def", "abc"]);
         } else {
             panic!("Expected defs element");
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:246:
     #[test]
     fn test_preserve_non_element_nodes() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let defs = Element {
             name: "defs".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:281:
     #[test]
     fn test_nested_defs() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         // Create nested defs structure
         let inner_defs = Element {
             name: "defs".to_string(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:313:
         // Both outer and inner defs should be sorted
         if let Node::Element(ref outer_defs) = document.root.children[0] {
             // Check outer defs sorting
[31m-            let outer_names: Vec<&str> = outer_defs.children.iter()
(B[m[32m+            let outer_names: Vec<&str> = outer_defs
(B[m[32m+                .children
(B[m[32m+                .iter()
(B[m                 .filter_map(|child| {
                     if let Node::Element(elem) = child {
                         Some(elem.name.as_str())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:322:
                     }
                 })
                 .collect();
[31m-            
(B[m[32m+
(B[m             // Should be sorted by length: ellipse(7), path(4), defs(4)
             assert_eq!(outer_names, vec!["ellipse", "path", "defs"]);
[31m-            
(B[m[32m+
(B[m             // Check inner defs sorting
             if let Node::Element(ref inner_defs) = outer_defs.children[2] {
[31m-                let inner_names: Vec<&str> = inner_defs.children.iter()
(B[m[32m+                let inner_names: Vec<&str> = inner_defs
(B[m[32m+                    .children
(B[m[32m+                    .iter()
(B[m                     .filter_map(|child| {
                         if let Node::Element(elem) = child {
                             Some(elem.name.as_str())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:337:
                         }
                     })
                     .collect();
[31m-                
(B[m[32m+
(B[m                 // Should be sorted by length: circle(6), rect(4)
                 assert_eq!(inner_names, vec!["circle", "rect"]);
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:349:
     #[test]
     fn test_empty_defs() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let defs = Element {
             name: "defs".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:374:
     #[test]
     fn test_complex_sorting() {
         let mut document = create_test_document();
[31m-        
(B[m[32m+
(B[m         let defs = Element {
             name: "defs".to_string(),
             attributes: IndexMap::new(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:381:
             namespaces: HashMap::new(),
             children: vec![
                 // Mix of frequencies and lengths
[31m-                Node::Element(create_element("a")),     // freq=1, len=1
(B[m[31m-                Node::Element(create_element("bb")),    // freq=2, len=2
(B[m[31m-                Node::Element(create_element("ccc")),   // freq=1, len=3
(B[m[31m-                Node::Element(create_element("a")),     // freq=2 now
(B[m[31m-                Node::Element(create_element("bb")),    // freq=2, len=2
(B[m[31m-                Node::Element(create_element("dddd")),  // freq=1, len=4
(B[m[32m+                Node::Element(create_element("a")), // freq=1, len=1
(B[m[32m+                Node::Element(create_element("bb")), // freq=2, len=2
(B[m[32m+                Node::Element(create_element("ccc")), // freq=1, len=3
(B[m[32m+                Node::Element(create_element("a")), // freq=2 now
(B[m[32m+                Node::Element(create_element("bb")), // freq=2, len=2
(B[m[32m+                Node::Element(create_element("dddd")), // freq=1, len=4
(B[m             ],
         };
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:397:
         assert!(result.is_ok());
 
         if let Node::Element(ref defs) = document.root.children[0] {
[31m-            let names: Vec<&str> = defs.children.iter()
(B[m[32m+            let names: Vec<&str> = defs
(B[m[32m+                .children
(B[m[32m+                .iter()
(B[m                 .filter_map(|child| {
                     if let Node::Element(elem) = child {
                         Some(elem.name.as_str())
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:406:
                     }
                 })
                 .collect();
[31m-            
(B[m[32m+
(B[m             // Expected order:
             // - First by frequency: a(2), bb(2), then ccc(1), dddd(1)
             // - Within same frequency, by length: bb(2) before a(1), dddd(4) before ccc(3)
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/plugins/sort_defs_children.rs:416:
         }
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:86:
         // Add XML declaration if needed
         if let Some(version) = &document.metadata.version {
             if let Some(encoding) = &document.metadata.encoding {
[31m-                writeln!(output, r#"<?xml version="{}" encoding="{}"?>"#, version, encoding)?;
(B[m[32m+                writeln!(
(B[m[32m+                    output,
(B[m[32m+                    r#"<?xml version="{}" encoding="{}"?>"#,
(B[m[32m+                    version, encoding
(B[m[32m+                )?;
(B[m             } else {
                 writeln!(output, r#"<?xml version="{}"?>"#, version)?;
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:119:
     }
 
     /// Stringify an element
[31m-    fn stringify_element(&self, element: &Element, output: &mut String, depth: usize) -> StringifyResult<()> {
(B[m[32m+    fn stringify_element(
(B[m[32m+        &self,
(B[m[32m+        element: &Element,
(B[m[32m+        output: &mut String,
(B[m[32m+        depth: usize,
(B[m[32m+    ) -> StringifyResult<()> {
(B[m         // Add indentation if pretty-printing
         if self.pretty && depth > 0 {
             self.write_indent(output, depth);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:132:
         self.write_attributes(element, output)?;
 
         // Handle empty elements or elements with only whitespace
[31m-        let is_effectively_empty = element.children.is_empty() || 
(B[m[31m-            (self.pretty && element.is_whitespace_only());
(B[m[31m-            
(B[m[32m+        let is_effectively_empty =
(B[m[32m+            element.children.is_empty() || (self.pretty && element.is_whitespace_only());
(B[m[32m+
(B[m         if is_effectively_empty {
             if self.self_closing {
                 write!(output, "/>")?;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:141:
             } else {
                 write!(output, "></{}>", element.name)?;
             }
[31m-            
(B[m[32m+
(B[m             if self.pretty {
                 writeln!(output)?;
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:233:
     }
 
     /// Stringify a node (for use with prologue/epilogue)
[31m-    fn stringify_node(&self, node: &Node, output: &mut String, _depth: usize) -> StringifyResult<()> {
(B[m[32m+    fn stringify_node(
(B[m[32m+        &self,
(B[m[32m+        node: &Node,
(B[m[32m+        output: &mut String,
(B[m[32m+        _depth: usize,
(B[m[32m+    ) -> StringifyResult<()> {
(B[m         match node {
             Node::Comment(comment) => {
                 write!(output, "<!--{}-->", comment)?;
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:262:
         attrs.sort_by(|(a_idx, (a_name, _)), (b_idx, (b_name, _))| {
             let a_priority = get_attribute_priority(a_name);
             let b_priority = get_attribute_priority(b_name);
[31m-            
(B[m[32m+
(B[m             // First sort by priority, then by original index to preserve insertion order
             match a_priority.cmp(&b_priority) {
                 std::cmp::Ordering::Equal => a_idx.cmp(b_idx),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:272:
 
         for (_idx, (name, value)) in attrs {
             write!(output, " {}", name)?;
[31m-            
(B[m[32m+
(B[m             if !value.is_empty() {
                 let quote_char = self.choose_quote_char(value);
[31m-                write!(output, "={}{}{}", quote_char, self.escape_attr_value(value, quote_char), quote_char)?;
(B[m[32m+                write!(
(B[m[32m+                    output,
(B[m[32m+                    "={}{}{}",
(B[m[32m+                    quote_char,
(B[m[32m+                    self.escape_attr_value(value, quote_char),
(B[m[32m+                    quote_char
(B[m[32m+                )?;
(B[m             }
         }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:288:
             QuoteAttrsStyle::Always => '"',
             QuoteAttrsStyle::Never => {
                 // Only use quotes if necessary
[31m-                if value.contains(' ') || value.contains('\t') || value.contains('\n') || 
(B[m[31m-                   value.contains('\r') || value.contains('"') || value.contains('\'') ||
(B[m[31m-                   value.contains('<') || value.contains('>') || value.contains('&') {
(B[m[32m+                if value.contains(' ')
(B[m[32m+                    || value.contains('\t')
(B[m[32m+                    || value.contains('\n')
(B[m[32m+                    || value.contains('\r')
(B[m[32m+                    || value.contains('"')
(B[m[32m+                    || value.contains('\'')
(B[m[32m+                    || value.contains('<')
(B[m[32m+                    || value.contains('>')
(B[m[32m+                    || value.contains('&')
(B[m[32m+                {
(B[m                     if value.contains('"') && !value.contains('\'') {
                         '\''
                     } else {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:297:
                         '"'
                     }
                 } else {
[31m-                    '\0'// No quotes needed
(B[m[32m+                    '\0' // No quotes needed
(B[m                 }
             }
             QuoteAttrsStyle::Auto => {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:313:
     /// Escape attribute value based on quote character
     fn escape_attr_value(&self, value: &str, quote_char: char) -> String {
         let mut result = String::with_capacity(value.len());
[31m-        
(B[m[32m+
(B[m         for ch in value.chars() {
             match ch {
                 '&' => result.push_str("&amp;"),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:323:
                 _ => result.push(ch),
             }
         }
[31m-        
(B[m[32m+
(B[m         result
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:330:
     /// Escape text content
     fn escape_text(&self, text: &str) -> String {
         let mut result = String::with_capacity(text.len());
[31m-        
(B[m[32m+
(B[m         for ch in text.chars() {
             match ch {
                 '&' => result.push_str("&amp;"),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:339:
                 _ => result.push(ch),
             }
         }
[31m-        
(B[m[32m+
(B[m         result
     }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:422:
     fn test_stringify_pretty() {
         let mut element = Element::new("svg");
         element.add_child(Node::Element(create_test_element()));
[31m-        
(B[m[32m+
(B[m         let mut document = Document::new();
         document.root = element;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:435:
     fn test_stringify_with_text() {
         let mut element = Element::new("text");
         element.add_child(Node::Text("Hello & World".to_string()));
[31m-        
(B[m[32m+
(B[m         let mut document = Document::new();
         document.root = element;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:447:
     fn test_stringify_with_comment() {
         let mut element = Element::new("svg");
         element.add_child(Node::Comment(" This is a comment ".to_string()));
[31m-        
(B[m[32m+
(B[m         let mut document = Document::new();
         document.root = element;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:458:
     #[test]
     fn test_attribute_escaping() {
         let mut element = Element::new("test");
[31m-        element.set_attr("attr".to_string(), "value with \"quotes\" & <tags>".to_string());
(B[m[31m-        
(B[m[32m+        element.set_attr(
(B[m[32m+            "attr".to_string(),
(B[m[32m+            "value with \"quotes\" & <tags>".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         let mut document = Document::new();
         document.root = element;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:466:
         let result = stringify(&document).unwrap();
[31m-        assert!(result.contains("attr='value with \"quotes\" &amp; &lt;tags>'")); 
(B[m[32m+        assert!(result.contains("attr='value with \"quotes\" &amp; &lt;tags>'"));
(B[m     }
 
     #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:486:
     fn test_quote_styles() {
         let mut element = Element::new("test");
         element.set_attr("simple".to_string(), "value".to_string());
[31m-        element.set_attr("with_quotes".to_string(), "value with \"quotes\"".to_string());
(B[m[31m-        
(B[m[32m+        element.set_attr(
(B[m[32m+            "with_quotes".to_string(),
(B[m[32m+            "value with \"quotes\"".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         let mut document = Document::new();
         document.root = element;
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/src/stringifier.rs:498:
         assert!(result.contains("with_quotes='value with \"quotes\"'"));
     }
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:3:
 //! Tests that load and process SVGO-style test fixtures
 //! This matches the pattern used in SVGO's test suite
 
[31m-use svgn::{optimize, OptimizeOptions, Config, PluginConfig};
(B[m use svgn::config::Js2SvgOptions;
[32m+use svgn::{optimize, Config, OptimizeOptions, PluginConfig};
(B[m 
 /// Parse a test fixture file in SVGO format:
 /// ```
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:27:
 impl TestFixture {
     fn parse(content: &str) -> Result<Self, String> {
         let normalized = content.trim().replace("\r\n", "\n");
[31m-        
(B[m[32m+
(B[m         // Split by === to separate description from test case
         let parts: Vec<&str> = normalized.split("\n===\n").collect();
         let (description, test_content) = if parts.len() == 2 {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:35:
         } else {
             (None, normalized.as_str())
         };
[31m-        
(B[m[32m+
(B[m         // Split test content by @@@
         let test_parts: Vec<&str> = test_content.split("\n@@@\n").collect();
[31m-        
(B[m[32m+
(B[m         if test_parts.len() < 2 {
             return Err("Invalid fixture format: missing @@@ separator".to_string());
         }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:45:
[31m-        
(B[m[32m+
(B[m         let input = test_parts[0].trim().to_string();
         let expected = test_parts[1].trim().to_string();
[31m-        
(B[m[32m+
(B[m         let params = if test_parts.len() > 2 && !test_parts[2].trim().is_empty() {
             match serde_json::from_str(test_parts[2].trim()) {
                 Ok(p) => Some(p),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:54:
         } else {
             None
         };
[31m-        
(B[m[32m+
(B[m         Ok(TestFixture {
             description,
             input,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:68:
 fn run_plugin_fixture_test(plugin_name: &str, fixture: &TestFixture) {
     let mut plugin_config = PluginConfig::new(plugin_name.to_string());
     plugin_config.params = fixture.params.clone();
[31m-    
(B[m[32m+
(B[m     let config = Config {
         plugins: vec![plugin_config],
         multipass: false,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:84:
     let mut last_result = fixture.input.clone();
     for i in 0..2 {
         let options = OptimizeOptions::new(config.clone());
[31m-        let result = optimize(&last_result, options)
(B[m[31m-            .expect("Optimization should succeed");
(B[m[31m-        
(B[m[32m+        let result = optimize(&last_result, options).expect("Optimization should succeed");
(B[m[32m+
(B[m         let output = result.data.trim();
         last_result = result.data.clone();
         let expected = fixture.expected.trim();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:93:
[31m-        
(B[m[32m+
(B[m         assert_eq!(output, expected, 
             "\nPlugin: {} (iteration {})\nDescription: {:?}\nInput:\n{}\nExpected:\n{}\nActual:\n{}\n", 
             plugin_name, i + 1, fixture.description, fixture.input, expected, output);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:110:
 <svg xmlns="http://www.w3.org/2000/svg" attr="a b" attr2="a b">
     test
 </svg>"#;
[31m-    
(B[m[31m-    let fixture = TestFixture::parse(fixture_content)
(B[m[31m-        .expect("Should parse fixture");
(B[m[31m-    
(B[m[32m+
(B[m[32m+    let fixture = TestFixture::parse(fixture_content).expect("Should parse fixture");
(B[m[32m+
(B[m     run_plugin_fixture_test("cleanupAttrs", &fixture);
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:120:
 #[test]
 fn test_convert_colors_fixture() {
     let input = "<svg xmlns=\"http://www.w3.org/2000/svg\">\n    <g color=\"black\"/>\n    <g color=\"BLACK\"/>\n    <path fill=\"rgb(64 64 64)\"/>\n    <path fill=\"rgb(64, 64, 64)\"/>\n    <path fill=\"rgb(86.27451%,86.666667%,87.058824%)\"/>\n    <path fill=\"rgb(-255,100,500)\"/>\n</svg>";
[31m-    
(B[m[32m+
(B[m     let expected = "<svg xmlns=\"http://www.w3.org/2000/svg\">\n    <g color=\"#000\"/>\n    <g color=\"#000\"/>\n    <path fill=\"#404040\"/>\n    <path fill=\"#404040\"/>\n    <path fill=\"#dcddde\"/>\n    <path fill=\"#0064ff\"/>\n</svg>";
[31m-    
(B[m[32m+
(B[m     let fixture = TestFixture {
         description: None,
         input: input.to_string(),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:129:
         expected: expected.to_string(),
         params: None,
     };
[31m-    
(B[m[32m+
(B[m     run_plugin_fixture_test("convertColors", &fixture);
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:148:
 <svg xmlns="http://www.w3.org/2000/svg">
     <g/>
 </svg>"#;
[31m-    
(B[m[31m-    let fixture = TestFixture::parse(fixture_content)
(B[m[31m-        .expect("Should parse fixture");
(B[m[31m-    
(B[m[32m+
(B[m[32m+    let fixture = TestFixture::parse(fixture_content).expect("Should parse fixture");
(B[m[32m+
(B[m     run_plugin_fixture_test("removeEmptyAttrs", &fixture);
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:173:
 {
     "preservePatterns": false
 }"#;
[31m-    
(B[m[31m-    let fixture = TestFixture::parse(fixture_content)
(B[m[31m-        .expect("Should parse fixture");
(B[m[31m-    
(B[m[32m+
(B[m[32m+    let fixture = TestFixture::parse(fixture_content).expect("Should parse fixture");
(B[m[32m+
(B[m     run_plugin_fixture_test("removeComments", &fixture);
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:219:
     let result = optimize(input, options).expect("Optimization should succeed");
     let output = result.data.trim();
     let expected = expected.trim();
[31m-    
(B[m[31m-    assert_eq!(output, expected, 
(B[m[31m-        "\nMultipass optimization\nInput:\n{}\nExpected:\n{}\nActual:\n{}\n", 
(B[m[31m-        input, expected, output);
(B[m[32m+
(B[m[32m+    assert_eq!(
(B[m[32m+        output, expected,
(B[m[32m+        "\nMultipass optimization\nInput:\n{}\nExpected:\n{}\nActual:\n{}\n",
(B[m[32m+        input, expected, output
(B[m[32m+    );
(B[m }
 
[1;38;5;9merror[internal][0m: [1mleft behind trailing whitespace[0m
  [1;38;5;12m-->[0m /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/fixture_tests.rs:93:93:37
[1;38;5;12m   |[0m
[1;38;5;12m93 |[0m         assert_eq!(output, expected, 
[1;38;5;12m   |[0m[1;38;5;9m                                     ^[0m
[1;38;5;12m   |[0m

[1;38;5;11mwarning[0m: [1mrustfmt has failed to format. See previous 1 errors.[0m

Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/integration_test.rs:2:
 
 //! Integration tests for svgn
 
[31m-use svgn::{optimize, OptimizeOptions, Config, PluginConfig};
(B[m use svgn::config::{Js2SvgOptions, QuoteAttrsStyle};
[32m+use svgn::{optimize, Config, OptimizeOptions, PluginConfig};
(B[m 
 #[test]
 fn test_full_optimization_pipeline() {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/integration_test.rs:60:
     assert!(!result.data.contains("enable-background"));
     assert!(!result.data.contains("unused-gradient"));
     assert!(!result.data.contains("myVeryLongGradientId")); // Should be minified
[31m-    // Accept url(#b) or url(#a) depending on optimization result
(B[m[32m+                                                            // Accept url(#b) or url(#a) depending on optimization result
(B[m     assert!(result.data.contains("url(#b)") || result.data.contains("url(#a)"));
     assert!(result.data.contains(r#"x="10 20""#)); // Newline replaced with space
     assert!(result.data.contains(r#"y="30 40""#)); // Multiple spaces reduced
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/integration_test.rs:145:
     assert!(!result.data.contains("width=\"200\"")); // Should be removed due to viewBox
     assert!(!result.data.contains("height=\"100\"")); // Should be removed due to viewBox
     assert!(!result.data.contains("fill=\"\"")); // Empty fill should be removed
[31m-    // Accept transform removal, or tolerate quote/whitespace variation. Robust check:
(B[m[32m+                                                 // Accept transform removal, or tolerate quote/whitespace variation. Robust check:
(B[m     use regex::Regex;
     let re = Regex::new(r#"transform\s*=\s*['\"]translate\(0,0\)['\"]"#).unwrap();
[31m-    assert!(!re.is_match(&result.data), "Output should not contain identity transform: {:?}", result.data);
(B[m[32m+    assert!(
(B[m[32m+        !re.is_match(&result.data),
(B[m[32m+        "Output should not contain identity transform: {:?}",
(B[m[32m+        result.data
(B[m[32m+    );
(B[m     assert!(!result.data.contains("my-class  other-class")); // Classes should be cleaned
     assert!(result.data.contains("fill=\"#f00\"")); // Color converted to hex
     assert!(result.data.contains("viewBox=\"0 0 200 100\"")); // ViewBox preserved
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/integration_test.rs:169:
 
     let config = Config::default();
     let options = OptimizeOptions::new(config);
[31m-    
(B[m[32m+
(B[m     // Should handle invalid SVG gracefully
     let result = optimize(invalid_svg, options);
[31m-    
(B[m[32m+
(B[m     // Depending on implementation, this might error or attempt to fix
     // For now, let's expect it to either succeed with fixes or fail gracefully
     match result {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/integration_test.rs:179:
         Ok(r) => {
             // If it succeeds, it should have attempted to fix the markup
             assert!(r.data.len() > 0);
[31m-        },
(B[m[32m+        }
(B[m         Err(_) => {
             // If it fails, that's also acceptable for malformed input
             // The error should be informative
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/integration_test.rs:215:
     assert!(result.data.contains("  </g>"));
     assert!(result.data.trim_end().ends_with("</svg>"));
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins.rs:18:
 //     pub mod remove_empty_attrs;
 // }
 
[31m-use svgn::{optimize_with_config, Config, PluginConfig};
(B[m use serde_json::json;
[32m+use svgn::{optimize_with_config, Config, PluginConfig};
(B[m 
 /// Helper function to run a plugin test
[31m-fn run_plugin_test(input: &str, expected: &str, plugin_name: &str, params: Option<serde_json::Value>) {
(B[m[32m+fn run_plugin_test(
(B[m[32m+    input: &str,
(B[m[32m+    expected: &str,
(B[m[32m+    plugin_name: &str,
(B[m[32m+    params: Option<serde_json::Value>,
(B[m[32m+) {
(B[m     let mut config = Config::new();
[31m-    config.js2svg.pretty = true;  // Enable pretty printing to match expected output
(B[m[31m-    config.js2svg.indent = 4;     // Use 4 spaces for indentation
(B[m[31m-    config.parser.preserve_comments = true;  // Preserve comments during parsing
(B[m[31m-    config.parser.preserve_whitespace = true;  // Preserve whitespace during parsing
(B[m[31m-    
(B[m[32m+    config.js2svg.pretty = true; // Enable pretty printing to match expected output
(B[m[32m+    config.js2svg.indent = 4; // Use 4 spaces for indentation
(B[m[32m+    config.parser.preserve_comments = true; // Preserve comments during parsing
(B[m[32m+    config.parser.preserve_whitespace = true; // Preserve whitespace during parsing
(B[m[32m+
(B[m     let mut plugin_config = PluginConfig::new(plugin_name.to_string());
     if let Some(p) = params {
         plugin_config.params = Some(p);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins.rs:35:
     }
     config.plugins.push(plugin_config);
[31m-    
(B[m[32m+
(B[m     let result = optimize_with_config(input, config).expect("Optimization should succeed");
     let output = result.data.trim();
     let expected = expected.trim();
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins.rs:41:
[31m-    
(B[m[31m-    assert_eq!(output, expected, 
(B[m[31m-        "\nPlugin: {}\nInput:\n{}\nExpected:\n{}\nActual:\n{}\n", 
(B[m[31m-        plugin_name, input, expected, output);
(B[m[32m+
(B[m[32m+    assert_eq!(
(B[m[32m+        output, expected,
(B[m[32m+        "\nPlugin: {}\nInput:\n{}\nExpected:\n{}\nActual:\n{}\n",
(B[m[32m+        plugin_name, input, expected, output
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/plugins.rs:122:
 
     run_plugin_test(input, expected, "removeTitle", None);
 }
[32m+
(B[mDiff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:3:
 //! SVGO compatibility tests - comprehensive test suite inspired by SVGO patterns
 //! These tests verify that SVGN is feature-compatible with SVGO
 
[31m-use svgn::{optimize, OptimizeOptions, Config, PluginConfig};
(B[m[31m-use svgn::config::{Js2SvgOptions, QuoteAttrsStyle};
(B[m use serde_json::json;
[32m+use svgn::config::{Js2SvgOptions, QuoteAttrsStyle};
(B[m[32m+use svgn::{optimize, Config, OptimizeOptions, PluginConfig};
(B[m 
 /// Test helper function to run optimization with specific plugins
[31m-fn test_optimization(input: &str, expected: &str, plugin_names: Vec<&str>, params: Option<serde_json::Value>) {
(B[m[32m+fn test_optimization(
(B[m[32m+    input: &str,
(B[m[32m+    expected: &str,
(B[m[32m+    plugin_names: Vec<&str>,
(B[m[32m+    params: Option<serde_json::Value>,
(B[m[32m+) {
(B[m     let mut plugins = Vec::new();
     let first_plugin = plugin_names.get(0).copied();
     for name in &plugin_names {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:18:
         }
         plugins.push(plugin);
     }
[31m-    
(B[m[32m+
(B[m     // If expected output is the same as input, use inline format (no change expected)
     let use_pretty = input != expected;
[31m-    
(B[m[32m+
(B[m     let config = Config {
         plugins,
         multipass: false,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:40:
     let result = optimize(input, options).expect("Optimization should succeed");
     let output = result.data.trim();
     let expected = expected.trim();
[31m-    
(B[m[31m-    assert_eq!(output, expected, 
(B[m[31m-        "\nInput:\n{}\nExpected:\n{}\nActual:\n{}\n", 
(B[m[31m-        input, expected, output);
(B[m[32m+
(B[m[32m+    assert_eq!(
(B[m[32m+        output, expected,
(B[m[32m+        "\nInput:\n{}\nExpected:\n{}\nActual:\n{}\n",
(B[m[32m+        input, expected, output
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:63:
 #[test]
 fn test_remove_comments_preserve_legal() {
     let input = "<!--! legal comment --><svg xmlns=\"http://www.w3.org/2000/svg\"><g/></svg>";
[31m-    let expected = "<!--! legal comment -->\n<svg xmlns=\"http://www.w3.org/2000/svg\">\n    <g/>\n</svg>";
(B[m[32m+    let expected =
(B[m[32m+        "<!--! legal comment -->\n<svg xmlns=\"http://www.w3.org/2000/svg\">\n    <g/>\n</svg>";
(B[m     test_optimization(input, expected, vec!["removeComments"], None);
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:91:
 #[test]
 fn test_remove_dimensions_with_viewbox() {
     let input = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"50\" viewBox=\"0 0 100 50\"><g/></svg>";
[31m-    let expected = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 50\">\n    <g/>\n</svg>";
(B[m[32m+    let expected =
(B[m[32m+        "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 50\">\n    <g/>\n</svg>";
(B[m     test_optimization(input, expected, vec!["removeDimensions"], None);
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:125:
 
     let options = OptimizeOptions::new(config);
     let result = optimize(input, options).expect("Optimization should succeed");
[31m-    
(B[m[32m+
(B[m     // Just verify it processes without error and produces output
     assert!(!result.data.is_empty());
     assert!(result.data.contains("<svg"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:144:
 
     let expected = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\">\n    <g>\n        <rect x=\"10\" y=\"20\" width=\"50\" fill=\"red\"/>\n    </g>\n</svg>";
 
[31m-    test_optimization(input, expected, vec![
(B[m[31m-        "removeComments",
(B[m[31m-        "removeMetadata", 
(B[m[31m-        "removeTitle",
(B[m[31m-        "removeEmptyAttrs",
(B[m[31m-        "removeDimensions"
(B[m[31m-    ], None);
(B[m[32m+    test_optimization(
(B[m[32m+        input,
(B[m[32m+        expected,
(B[m[32m+        vec![
(B[m[32m+            "removeComments",
(B[m[32m+            "removeMetadata",
(B[m[32m+            "removeTitle",
(B[m[32m+            "removeEmptyAttrs",
(B[m[32m+            "removeDimensions",
(B[m[32m+        ],
(B[m[32m+        None,
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:157:
 fn test_multipass_optimization() {
     // Test that multipass optimization works
     let input = "<svg xmlns=\"http://www.w3.org/2000/svg\"><g><g><rect/></g></g></svg>";
[31m-    
(B[m[32m+
(B[m     let config = Config {
         plugins: vec![PluginConfig::new("collapseGroups".to_string())],
         multipass: true,
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:174:
 
     let options = OptimizeOptions::new(config);
     let result = optimize(input, options).expect("Optimization should succeed");
[31m-    
(B[m[32m+
(B[m     // Verify optimization occurred (groups should be collapsed)
     assert!(!result.data.contains("<g><g>"));
     assert!(result.data.contains("<rect"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:182:
 
 #[test]
 fn test_plugin_with_params() {
[31m-    let input = "<svg xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"10px\" height=\"20px\"/></svg>";
(B[m[31m-    
(B[m[32m+    let input =
(B[m[32m+        "<svg xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"10px\" height=\"20px\"/></svg>";
(B[m[32m+
(B[m     let params = json!({
         "floatPrecision": 2,
         "defaultPx": false
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:190:
     });
[31m-    
(B[m[32m+
(B[m     test_optimization(input, input, vec!["cleanupNumericValues"], Some(params));
 }
 
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:200:
         "<svg xmlns=\"http://www.w3.org/2000/svg\"><g/></svg>", // Simple SVG
         "<svg xmlns=\"http://www.w3.org/2000/svg\"><unknown-element/></svg>", // Unknown element
     ];
[31m-    
(B[m[32m+
(B[m     for input in inputs {
         let config = Config {
             plugins: vec![
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:216:
 
         let options = OptimizeOptions::new(config);
         let result = optimize(input, options);
[31m-        
(B[m[32m+
(B[m         // Should either succeed or fail gracefully
         match result {
             Ok(r) => {
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:223:
                 assert!(!r.data.is_empty());
                 assert!(r.data.contains("<svg"));
[31m-            },
(B[m[32m+            }
(B[m             Err(_) => {
                 // Errors are acceptable for malformed input
             }
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:233:
 #[test]
 fn test_optimization_info() {
     let input = "<svg xmlns=\"http://www.w3.org/2000/svg\"><!-- comment --><metadata>data</metadata><g/></svg>";
[31m-    
(B[m[32m+
(B[m     let config = Config {
         plugins: vec![
             PluginConfig::new("removeComments".to_string()),
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:248:
 
     let options = OptimizeOptions::new(config);
     let result = optimize(input, options).expect("Optimization should succeed");
[31m-    
(B[m[32m+
(B[m     // Check that optimization info is populated
     assert!(result.info.original_size > 0);
     assert!(result.info.optimized_size > 0);
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:260:
 #[test]
 fn test_pretty_print_vs_minified() {
     let input = "<svg xmlns=\"http://www.w3.org/2000/svg\"><g><rect/></g></svg>";
[31m-    
(B[m[32m+
(B[m     // Test pretty-printed output
     let pretty_config = Config {
         plugins: vec![],
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:275:
         datauri: None,
         parser: Default::default(),
     };
[31m-    
(B[m[32m+
(B[m     let pretty_result = optimize(input, OptimizeOptions::new(pretty_config)).unwrap();
     assert!(pretty_result.data.contains("\n  <g>"));
     assert!(pretty_result.data.contains("\n    <rect"));
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:282:
[31m-    
(B[m[32m+
(B[m     // Test minified output
     let minified_config = Config {
         plugins: vec![],
Diff in /Users/adam/Developer/vcs/github.twardoch/pub/svgn/svgn/tests/svgo_compatibility_tests.rs:294:
         datauri: None,
         parser: Default::default(),
     };
[31m-    
(B[m[32m+
(B[m     let minified_result = optimize(input, OptimizeOptions::new(minified_config)).unwrap();
     assert!(!minified_result.data.contains("\n  <g>"));
[31m-    
(B[m[32m+
(B[m     // Pretty output should be longer than minified
     assert!(pretty_result.data.len() > minified_result.data.len());
 }
