This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
_sass/
  custom/
    custom.scss
_config.yml
architecture.md
comparison.md
Gemfile
index.md
plugins.md
usage.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="_sass/custom/custom.scss">
// Custom styles for SVGN documentation

// Color theme overrides
$body-background-color: $white;
$sidebar-color: $grey-lt-100;
$border-color: $grey-lt-100;

// Custom styling
.code-example {
  border: 1px solid $border-color;
  border-radius: 6px;
  padding: 16px;
  margin-bottom: 16px;
  background-color: $grey-lt-000;
}

// Table styling improvements
table {
  border-collapse: collapse;
  width: 100%;
  margin-bottom: 16px;
  
  th, td {
    border: 1px solid $border-color;
    padding: 8px 12px;
    text-align: left;
  }
  
  th {
    background-color: $grey-lt-000;
    font-weight: 600;
  }
}

// Improve code block styling
pre.highlight {
  padding: 16px;
  border-radius: 6px;
  border: 1px solid $border-color;
}

// Better link styling
a {
  text-decoration: none;
  
  &:hover {
    text-decoration: underline;
  }
}
</file>

<file path="_config.yml">
remote_theme: just-the-docs/just-the-docs

# GitHub Pages plugins
plugins:
  - jekyll-remote-theme
  - jekyll-sitemap
  - jekyll-feed

# Site settings
title: SVGN Documentation
description: A native Rust SVG optimizer - API-compatible port of SVGO
baseurl: ""
url: "https://twardoch.github.io/svgn"

# Just the Docs specific settings
search_enabled: true
search:
  heading_level: 2
  previews: 3
  preview_words_before: 5
  preview_words_after: 10
  tokenizer_separator: /[\s/]+/
  rel_url: true
  button: false

# Navigation
nav_sort: case_insensitive
nav_external_links:
  - title: GitHub Repository
    url: https://github.com/twardoch/svgn
  - title: SVGO Reference
    url: https://github.com/svg/svgo

# Footer
footer_content: "Copyright &copy; 2024 Adam Twardoch. Distributed under the MIT License."

# Color scheme
color_scheme: light

# Enable copy to clipboard
enable_copy_code_button: true

# Aux links
aux_links:
  "View on GitHub":
    - "https://github.com/twardoch/svgn"

# Collections
collections:
  data:
    output: true
</file>

<file path="architecture.md">
---
layout: default
title: Architecture
nav_order: 5
description: "SVGN internal architecture and design"
---

# SVGN Architecture

`svgn` is designed as a native Rust port of `svgo`, aiming to replicate its core architectural principles while leveraging Rust's strengths for performance and reliability. The architecture closely mirrors `svgo`'s modular design, consisting of a core engine, parser, stringifier, and a robust plugin system.

## Core Components

### 1. Core Engine (`svgn/src/optimizer.rs`)

Similar to `svgo`'s `lib/svgo.js`, the `svgn` core engine orchestrates the SVG optimization process. It takes an SVG string and a configuration object, then applies a pipeline of plugins to the parsed SVG Abstract Syntax Tree (AST). The engine manages the order of plugin execution and handles multi-pass optimizations if configured.

### 2. Parser (`svgn/src/parser.rs`)

The parser component is responsible for transforming an SVG string into an Abstract Syntax Tree (AST). In `svgo`, this is handled by `lib/parser.js`, which uses a SAX-like approach. `svgn` implements its own efficient SVG parser in Rust, converting the raw SVG XML into a structured, traversable AST representation that plugins can operate on.

### 3. Plugins (`svgn/src/plugins/`)

Plugins are the heart of `svgn`'s optimization capabilities. Each plugin is a self-contained module that performs a specific optimization or transformation on the SVG AST. `svgn`'s plugin system is designed to be compatible with `svgo`'s plugin API concepts, allowing for a systematic porting of existing `svgo` plugins.

-   **Modularity**: Each optimization is encapsulated within its own plugin, promoting code organization and reusability.
-   **AST Transformation**: Plugins receive and modify the SVG AST, enabling complex manipulations of SVG elements, attributes, and styles.
-   **Configurability**: Plugins can be enabled, disabled, and configured with specific parameters via the `SvgnConfig` object.

### 4. Stringifier (`svgn/src/stringifier.rs`)

After all plugins have processed the AST, the stringifier component converts the optimized AST back into a minified SVG string. This component is analogous to `svgo`'s `lib/stringifier.js`. The stringifier handles proper XML serialization, including attribute ordering, whitespace management, and numeric precision, to ensure the smallest possible output size while maintaining valid SVG syntax.

### 5. Command-Line Interface (CLI) (`svgn/src/bin/svgn.rs`)

The `svgn` CLI provides a user-friendly interface for optimizing SVG files directly from the terminal. It parses command-line arguments, loads configuration, invokes the core optimization engine, and outputs the results. This component mirrors the functionality of `svgo`'s `bin/svgo` and `lib/svgo-node.js`.

## Design Principles

`svgn`'s architecture is guided by several key design principles:

-   **Performance**: Leveraging Rust's capabilities for zero-cost abstractions, memory safety, and concurrency to achieve superior optimization speeds.
-   **Functional Parity**: Ensuring that `svgn` produces identical optimization results to `svgo` for the same inputs and configurations.
-   **Modularity**: Maintaining a clear separation of concerns between parsing, optimization, and stringification, and promoting a plugin-based approach for extensibility.
-   **API Compatibility**: Designing the Rust API to be conceptually similar to `svgo`'s JavaScript API where appropriate, to ease migration for developers.
-   **WASM Readiness**: Structuring the codebase to facilitate efficient compilation to WebAssembly, enabling broad deployment scenarios.

By adhering to these principles, `svgn` aims to be a robust, high-performance, and functionally equivalent alternative to `svgo` in the Rust ecosystem.
</file>

<file path="comparison.md">
---
layout: default
title: Comparison
nav_order: 4
description: "SVGN vs. SVGO: A detailed comparison"
---

# SVGN vs. SVGO: A Comparison

`svgn` is a native Rust port of `svgo`, the popular JavaScript-based SVG optimizer. While `svgn` aims for functional parity and API compatibility with `svgo`, there are fundamental differences stemming from their underlying technologies (Rust vs. JavaScript) that impact performance, deployment, and ecosystem integration.

## Key Differences

| Feature             | SVGN (Rust)                                     | SVGO (JavaScript)                               |
| :------------------ | :---------------------------------------------- | :---------------------------------------------- |
| **Language**        | Rust                                            | JavaScript (Node.js)                            |
| **Performance**     | Generally faster due to Rust's native execution and memory management. Ideal for CPU-bound tasks. | Good performance, but limited by JavaScript runtime overhead. |
| **Memory Usage**    | Lower memory footprint due to Rust's ownership model and lack of garbage collector. | Higher memory usage due to JavaScript's garbage collection and runtime. |
| **Ecosystem**       | Integrates seamlessly with Rust projects and the Cargo ecosystem. | Integrates with Node.js projects and the npm/Yarn ecosystem. |
| **Deployment**      | Compiles to native executables, WebAssembly (WASM), or can be used as a library. | Requires Node.js runtime for execution. Browser usage requires bundling. |
| **Concurrency**     | Leverages Rust's strong concurrency primitives for potential parallel processing of SVG optimization tasks. | Primarily single-threaded, though asynchronous operations are common. |
| **Error Handling**  | Rust's robust type system and `Result`/`Option` enums enforce explicit error handling at compile time. | Relies on exceptions and runtime error handling. |
| **Binary Size**     | Native executables can be larger due to static linking, but WASM output can be compact. | Smaller package size, but requires Node.js runtime. |
| **Use Cases**       | High-performance backend services, desktop applications, CLI tools, WASM in browsers. | Web development workflows, build tools, Node.js applications, browser-based optimization (with bundling). |

## Functional Parity

`svgn`'s primary goal is to achieve full functional parity with `svgo` v4.0.0. This means that for a given SVG input and configuration, `svgn` should produce an identical (or byte-for-byte equivalent) optimized SVG output as `svgo`.

-   **Plugin Porting**: All `svgo` plugins are being systematically ported to `svgn`, ensuring that the same optimization rules and logic are applied.
-   **Test Suite Replication**: `svgn` utilizes a comprehensive test suite that includes many of `svgo`'s original test cases, ensuring that the output matches the reference implementation.
-   **Configuration Mapping**: `svgn`'s configuration structure (`SvgnConfig`) is designed to directly map to `svgo`'s configuration object, allowing for easy migration of existing `svgo` configurations.

## When to Choose SVGN?

Consider using `svgn` if:

-   You require maximum performance for SVG optimization, especially for large batches of files or in performance-critical environments.
-   You are working within a Rust ecosystem and prefer a native solution without Node.js dependencies.
-   You plan to deploy SVG optimization to WebAssembly (WASM) for client-side or edge computing scenarios.
-   You value strong type safety and compile-time error checking.

## When to Choose SVGO?

`svgo` remains an excellent choice if:

-   You are already heavily invested in the Node.js/JavaScript ecosystem.
-   Your performance requirements are met by `svgo`'s current capabilities.
-   You need immediate access to the latest `svgo` features and plugins as they are released (as `svgn` will have a slight lag for porting).
-   You prefer the flexibility and rapid development cycles often associated with JavaScript.

Ultimately, the choice between `svgn` and `svgo` depends on your specific project requirements, performance needs, and technology stack preferences.
</file>

<file path="Gemfile">
source 'https://rubygems.org'

gem 'github-pages', group: :jekyll_plugins
</file>

<file path="index.md">
---
layout: default
title: Home
nav_order: 1
description: "SVGN: A Native Rust SVG Optimizer"
permalink: /
---

# SVGN: A Native Rust SVG Optimizer

## 1. Introduction

`svgn` is a high-performance, native Rust port of `svgo` (SVG Optimizer), the popular Node.js-based tool for optimizing SVG vector graphics files. While `svgo` has been instrumental in reducing SVG file sizes by removing redundant information, minifying code, and applying various optimizations, `svgn` aims to bring these benefits to a new level with the power and efficiency of Rust.

This documentation serves as a comprehensive guide to `svgn`, detailing its structure, API, and plugin system. Throughout these pages, we will draw parallels and highlight key differences with the original JavaScript `svgo` reference implementation, providing context for developers familiar with `svgo` and a clear understanding for newcomers.

## 2. Why SVGN?

The primary motivations behind developing `svgn` are rooted in the desire for superior performance, broader integration capabilities, and enhanced reliability for SVG optimization tasks.

-   **Unmatched Performance**: Leveraging Rust's focus on zero-cost abstractions, memory safety, and efficient concurrency, `svgn` processes SVG files significantly faster than its JavaScript counterpart. This makes it an ideal choice for:
    *   **Large-scale batch processing**: Optimizing thousands of SVG assets in build pipelines.
    *   **Real-time applications**: Where low latency SVG manipulation is critical.
    *   **Server-side rendering**: Reducing payload sizes and improving page load times.
-   **Seamless Native Integration**: As a native Rust library, `svgn` can be effortlessly integrated into a wide array of applications without the overhead of a Node.js runtime. This includes:
    *   **Desktop applications**: Building performant SVG tools.
    *   **Command-line interfaces (CLIs)**: Creating fast and efficient SVG optimization scripts.
    *   **Backend services**: Optimizing SVGs directly within Rust-based web servers or microservices.
    *   **Embedded systems**: Where resource constraints demand highly optimized code.
-   **WebAssembly (WASM) Compatibility**: `svgn` is meticulously designed with WebAssembly compilation in mind. This enables high-performance SVG optimization directly within web browsers, edge computing environments, or other WASM-compatible runtimes, unlocking new possibilities for client-side SVG processing.
-   **API Compatibility with `svgo`**: `svgn` strives for a high degree of API compatibility with `svgo` v4.0.0. This design choice significantly eases the transition for developers already familiar with `svgo`, allowing them to leverage their existing knowledge and configurations with minimal adjustments. Our goal is to ensure that if you know `svgo`, you'll feel right at home with `svgn`.

## 3. Key Features

`svgn` offers a robust set of features designed to provide comprehensive SVG optimization:

-   **Plugin-based Architecture**: A flexible and extensible system where individual optimization rules are encapsulated as plugins, allowing for fine-grained control over the optimization process.
-   **AST-based Transformations**: Utilizes an Abstract Syntax Tree (AST) for SVG manipulation, ensuring precise and reliable transformations.
-   **Comprehensive Optimization Plugins**: A growing collection of plugins, systematically ported from `svgo`, covering a wide range of optimization techniques from removing redundant attributes to converting shapes.
-   **CLI Tool**: A user-friendly command-line interface for quick and easy SVG optimization.
-   **Rust Library**: A powerful and efficient Rust library for programmatic integration into your projects.
-   **WASM Target**: Future-proof design with WebAssembly compilation support for browser and edge environments.

## 4. Project Structure

The `svgn` repository is organized to reflect its native Rust implementation while maintaining a clear reference to the original `svgo` structure for architectural guidance and functional parity testing:

-   **/svgn**: Contains the core Rust library and the `svgn` CLI application. This is where the primary Rust source code resides.
-   **/src**: Within the `svgn` directory, this folder holds the Rust source code for `svgn`'s core components, including the parser, optimizer, stringifier, and individual plugin implementations.
-   **/ref/svgo**: This directory contains the complete `svgo` v4.0.0 JavaScript reference implementation. It serves as a crucial benchmark for functional parity testing and provides architectural insights during the porting process.
-   **/docs**: This folder contains the project's documentation, which you are currently reading.
-   **/tests**: Comprehensive test suites for `svgn`, including integration and unit tests. Many of these tests are designed to mirror `svgo`'s test cases, ensuring that `svgn` produces identical optimization results.

## 5. Installation

To get started with `svgn`, you'll need to have Rust and Cargo (Rust's package manager) installed on your system. If you don't have them, you can install them conveniently via `rustup`, the recommended Rust toolchain installer:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Follow the on-screen instructions to complete the `rustup` installation. Once Rust and Cargo are set up, you have two primary ways to use `svgn`:

### 5.1. As a Command-Line Tool

You can install `svgn` as a global command-line tool, making it accessible from any directory in your terminal:

```bash
cargo install svgn
```

This command compiles and installs the `svgn` executable to your Cargo bin directory, which should be in your system's `PATH`.

### 5.2. As a Rust Library

If you want to integrate `svgn` directly into your Rust project as a dependency, add it to your `Cargo.toml` file:

```toml
[dependencies]
svgn = "0.1.0" # Replace "0.1.0" with the latest version available on crates.io
```

After adding the dependency, Cargo will automatically download and compile `svgn` when you build your project. You can then import and use `svgn`'s functionalities within your Rust code.
</file>

<file path="plugins.md">
---
layout: default
title: Plugins
nav_order: 3
description: "SVGN plugin architecture and available plugins"
---

# SVGN Plugins

Plugins are the core of `svgn`'s optimization capabilities, just as they are for `svgo`. They perform specific transformations on the SVG's Abstract Syntax Tree (AST) to reduce file size and improve rendering efficiency. `svgn` aims to port all of `svgo`'s plugins, maintaining functional parity and API compatibility where it makes sense in a Rust context.

## Plugin Architecture

Similar to `svgo`, `svgn` utilizes a plugin-based architecture. Each plugin is a distinct module responsible for a specific optimization task. This modularity allows for flexible configuration and extensibility.

In `svgn`, plugins are implemented as Rust functions or structs that operate on the SVG's AST. The core optimizer iterates through the enabled plugins, applying their transformations sequentially.

## Default Preset

`svgn`, like `svgo`, includes a default preset of plugins that are generally safe and provide good optimization results. This preset is applied by default when no custom plugin configuration is provided. The specific plugins included in the default preset and their order of execution will mirror `svgo`'s `preset-default` as closely as possible.

## Ported Plugins

The following `svgo` plugins have been ported to `svgn`:

-   **`addAttributesToSVGElement`**: Adds attributes to the root `<svg>` element.
-   **`addClassesToSVGElement`**: Adds class names to the root `<svg>` element.
-   **`cleanupAttrs`**: Cleans up attributes from newlines, trailing, and repeating spaces.
-   **`cleanupEnableBackground`**: Removes or cleans up the `enable-background` attribute.
-   **`cleanupIds`**: Minifies and removes unused IDs.
-   **`cleanupListOfValues`**: Rounds numeric values in attributes that have a list of numbers (like `viewBox` or `stroke-dasharray`).
-   **`cleanupNumericValues`**: Rounds numeric values to a fixed precision.
-   **`collapseGroups`**: Collapses useless groups (`<g>`).
-   **`convertColors`**: Converts colors from `rgb()` to `#rrggbb`, `rgba()` to `#rrggbbaa`, and color names to hex values.
-   **`convertEllipseToCircle`**: Converts `<ellipse>` elements to `<circle>` elements when possible.
-   **`convertOneStopGradients`**: Converts gradients with only one stop to a solid color.
-   **`convertStyleToAttrs`**: Converts styles from `<style>` elements to attributes.
-   **`mergeStyles`**: Merges multiple `<style>` elements into one.
-   **`removeAttributesBySelector`**: Removes attributes of elements that match a CSS selector.
-   **`removeAttrs`**: Removes attributes by name.
-   **`removeComments`**: Removes comments.
-   **`removeDeprecatedAttrs`**: Removes deprecated attributes.
-   **`removeDesc`**: Removes `<desc>` elements.
-   **`removeDoctype`**: Removes doctype declarations.
-   **`removeEmptyAttrs`**: Removes empty attributes.
-   **`removeEmptyContainers`**: Removes empty container elements.
-   **`removeEmptyText`**: Removes empty text elements.
-   **`removeMetadata`**: Removes `<metadata>` elements.
-   **`removeStyleElement`**: Removes `<style>` elements.
-   **`removeTitle`**: Removes `<title>` elements.
-   **`removeUnknownsAndDefaults`**: Removes unknown elements' content and attributes, and removes default attribute values.
-   **`removeXMLProcInst`**: Removes XML processing instructions.
-   **`sortAttrs`**: Sorts element attributes for better gzip compression.

*(This list will be updated as more plugins are ported and verified.)*

## Plugin Configuration

Configuring plugins in `svgn` is similar to `svgo`. You can enable or disable plugins, and for some, provide specific parameters to control their behavior. This is done through the `SvgnConfig` structure, as shown in the [Usage documentation](./usage.md).

### Example: Disabling a Plugin

To disable a plugin, you would omit it from your `plugins` list in the `SvgnConfig` or explicitly set it to `false` if using a preset override mechanism (which will be implemented to mirror `svgo`'s behavior).

### Example: Configuring a Plugin with Parameters

```rust
use svgn::config::{SvgnConfig, PluginConfig};
use serde_json::json;

let config = SvgnConfig {
    plugins: vec![
        PluginConfig::WithParams {
            name: "cleanupNumericValues".to_string(),
            params: json!({
                "floatPrecision": 2,
                "leadingZero": false,
            }),
        },
    ],
    ..SvgnConfig::default()
};
```

This example demonstrates how to configure the `cleanupNumericValues` plugin to round to 2 decimal places and keep leading zeros, mirroring `svgo`'s parameter structure.
</file>

<file path="usage.md">
---
layout: default
title: Usage
nav_order: 2
description: "How to use SVGN CLI and library"
---

# SVGN Usage

`svgn` provides a powerful and efficient way to optimize SVG files, leveraging the performance benefits of Rust. It aims for API compatibility with `svgo` where applicable, making the transition for users familiar with the JavaScript version as smooth as possible.

## Command-Line Interface (CLI)

`svgn` offers a command-line interface for direct file optimization, similar to `svgo`.

### Basic Usage

To optimize a single SVG file:

```bash
svgn input.svg -o output.svg
```

To optimize all SVG files in a folder and overwrite them:

```bash
svgn -f input_folder
```

### Options

`svgn` CLI options largely mirror `svgo`'s, providing a familiar experience:

-   `-i, --input <file|dir>`: Input file or directory. (Similar to `svgo`)
-   `-o, --output <file|dir>`: Output file or directory. (Similar to `svgo`)
-   `-f, --folder <dir>`: Input folder, optimize and rewrite all `*.svg` files. (Similar to `svgo`)
-   `-p, --pretty`: Make SVG pretty printed. (Similar to `svgo`)
-   `--config <file>`: Custom config file. (Similar to `svgo`)
-   `--disable <plugin_name>`: Disable a plugin by name. (Similar to `svgo`)
-   `--enable <plugin_name>`: Enable a plugin by name. (Similar to `svgo`)
-   `--datauri <type>`: Output as Data URI string (`'base64'`, `'enc'`, or `'unenc'`). (Similar to `svgo`)
-   `--multipass`: Optimize SVG multiple times. (Similar to `svgo`)
-   `--quiet`: Only output error messages. (Similar to `svgo`)
-   `-v, --version`: Show version.
-   `-h, --help`: Show help.

## As a Rust Library

`svgn` can be integrated directly into your Rust projects for programmatic SVG optimization. The core optimization function is designed to be intuitive and efficient.

### Basic Example

To use `svgn` in your Rust code, first ensure you've added it to your `Cargo.toml` (as described in the [Installation](/#installation) section). Then, you can use the `optimize` function:

```rust
use svgn::optimize;
use svgn::config::SvgnConfig;

fn main() {
    let svg_string = r#"
<svg xmlns="http://www.w3.org/2000/svg"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  viewBox="0 0 100 100">
  <text x="50" y="50" text-anchor="middle">•ᴗ•</text>
</svg>
"#;

    let config = SvgnConfig::default();
    let result = optimize(svg_string, &config);

    match result {
        Ok(optimized_svg) => {
            println!("Optimized SVG:\n{}", optimized_svg.data);
        }
        Err(e) => {
            eprintln!("Error optimizing SVG: {}", e);
        }
    }
}
```

### Configuration

The `optimize` function in `svgn` takes an SVG string and a configuration object, similar to `svgo`'s `optimize(input, config)`.

```rust
pub struct SvgnConfig {
    pub path: Option<String>,
    pub plugins: Vec<PluginConfig>,
    pub multipass: bool,
    pub js2svg: Js2SvgConfig,
    pub datauri: Option<String>,
}

pub struct Js2SvgConfig {
    pub pretty: bool,
    pub indent: usize,
}

pub enum PluginConfig {
    // Represents a plugin enabled by its name (e.g., "removeDimensions")
    Enabled(String),
    // Represents a plugin with custom parameters
    WithParams {
        name: String,
        params: serde_json::Value, // Use serde_json::Value for flexible parameters
    },
}
```

**Comparison with `svgo`'s Configuration:**

`svgn`'s `SvgnConfig` directly maps to `svgo`'s configuration object. The `plugins` array in `svgo` can contain either plugin names (strings) or objects with `name` and `params`. In `svgn`, this is represented by the `PluginConfig` enum, allowing for both simple enablement and parameter customization.

### Example with Custom Plugins

```rust
use svgn::optimize;
use svgn::config::{SvgnConfig, PluginConfig};
use serde_json::json;

fn main() {
    let svg_string = r#"<svg width="100" height="100"><rect x="10" y="10" width="80" height="80" fill="red"/></svg>"#;

    let config = SvgnConfig {
        plugins: vec![
            PluginConfig::Enabled("removeDimensions".to_string()),
            PluginConfig::WithParams {
                name: "sortAttrs".to_string(),
                params: json!({
                    "xmlnsOrder": "alphabetical",
                }),
            },
        ],
        ..SvgnConfig::default()
    };

    let result = optimize(svg_string, &config);

    match result {
        Ok(optimized_svg) => {
            println!("Optimized SVG:\n{}", optimized_svg.data);
        }
        Err(e) => {
            eprintln!("Error optimizing SVG: {}", e);
        }
    }
}
```

## WebAssembly (WASM)

`svgn` is designed to be compiled to WebAssembly, allowing you to run SVG optimization directly in the browser or other WASM environments. This provides a significant performance boost compared to JavaScript-based optimizers in the browser.

*(Details on WASM usage will be added as the WASM compilation target matures.)*
</file>

</files>
